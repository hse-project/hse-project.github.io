{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Heterogeneous-Memory Storage Engine HSE is a fast embeddable key-value store designed for SSDs and persistent memory. HSE optimizes performance and endurance by orchestrating data placement across DRAM and multiple classes of solid-state storage devices. HSE is ideal for powering Databases, Software-Defined Storage (SDS), High-Performance Computing (HPC), Internet of Things (IoT), and Machine Learning (ML). Key Features Rich set of key-value operations Full transactions with snapshot-isolation spanning multiple independent key-value collections Cursors for iterating over snapshot views Data model for optimizing mixed use-case workloads in a single data store Key and value compression Flexible durability controls Configurable data orchestration schemes Native C library that can be embedded in any application Benefits Scales to terabytes of data and hundreds of billions of keys per store Efficiently handles thousands of concurrent operations Dramatically improves throughput, latency, write-amplification, and read-amplification versus common alternatives for many workloads Optionally combines multiple classes of solid-state storage to optimize performance and endurance","title":"Home"},{"location":"#heterogeneous-memory-storage-engine","text":"HSE is a fast embeddable key-value store designed for SSDs and persistent memory. HSE optimizes performance and endurance by orchestrating data placement across DRAM and multiple classes of solid-state storage devices. HSE is ideal for powering Databases, Software-Defined Storage (SDS), High-Performance Computing (HPC), Internet of Things (IoT), and Machine Learning (ML).","title":"Heterogeneous-Memory Storage Engine"},{"location":"#key-features","text":"Rich set of key-value operations Full transactions with snapshot-isolation spanning multiple independent key-value collections Cursors for iterating over snapshot views Data model for optimizing mixed use-case workloads in a single data store Key and value compression Flexible durability controls Configurable data orchestration schemes Native C library that can be embedded in any application","title":"Key Features"},{"location":"#benefits","text":"Scales to terabytes of data and hundreds of billions of keys per store Efficiently handles thousands of concurrent operations Dramatically improves throughput, latency, write-amplification, and read-amplification versus common alternatives for many workloads Optionally combines multiple classes of solid-state storage to optimize performance and endurance","title":"Benefits"},{"location":"api/","text":"Overview The documentation here is geared towards describing the structure of the HSE API and the specifics of each entry point's operation. Refer to https://hse-project.github.io/2.x/dev/concepts/ for a conceptual overview of HSE. Terminology KVS - Key-value store, containing zero or more key-value pairs KVDB - Key-value database, comprised of one or more KVSs and defining a transaction domain key - A byte string used to uniquely identify values for storage, retrieval, and deletion in a KVS segmented key - A key that is logically divided into N segments (N >= 2), arranged to group related key-value pairs when keys are sorted lexicographically key prefix - For segmented keys, the first K segments (1 <= K < N). key prefix length - The length of a key prefix (bytes) Updated on 1 October 2021 at 17:03:30 CDT","title":"Overview"},{"location":"api/#overview","text":"The documentation here is geared towards describing the structure of the HSE API and the specifics of each entry point's operation. Refer to https://hse-project.github.io/2.x/dev/concepts/ for a conceptual overview of HSE.","title":"Overview"},{"location":"api/#terminology","text":"KVS - Key-value store, containing zero or more key-value pairs KVDB - Key-value database, comprised of one or more KVSs and defining a transaction domain key - A byte string used to uniquely identify values for storage, retrieval, and deletion in a KVS segmented key - A key that is logically divided into N segments (N >= 2), arranged to group related key-value pairs when keys are sorted lexicographically key prefix - For segmented keys, the first K segments (1 <= K < N). key prefix length - The length of a key prefix (bytes) Updated on 1 October 2021 at 17:03:30 CDT","title":"Terminology"},{"location":"api/Files/","text":"Files dir include dir hse file hse/version.h dir include dir hse file hse/flags.h file hse/hse.h file hse/limits.h file hse/types.h Updated on 1 October 2021 at 17:03:30 CDT","title":"Files"},{"location":"api/Files/#files","text":"dir include dir hse file hse/version.h dir include dir hse file hse/flags.h file hse/hse.h file hse/limits.h file hse/types.h Updated on 1 October 2021 at 17:03:30 CDT","title":"Files"},{"location":"api/Files/dir_04700ab32882dd6f5919291731388d84/","text":"hse Files Name hse/version.h Updated on 1 October 2021 at 17:03:30 CDT","title":"hse"},{"location":"api/Files/dir_04700ab32882dd6f5919291731388d84/#hse","text":"","title":"hse"},{"location":"api/Files/dir_04700ab32882dd6f5919291731388d84/#files","text":"Name hse/version.h Updated on 1 October 2021 at 17:03:30 CDT","title":"Files"},{"location":"api/Files/dir_74519b06cb360fd5deb315947aad9941/","text":"hse Files Name hse/flags.h hse/hse.h hse/limits.h hse/types.h Updated on 1 October 2021 at 17:03:30 CDT","title":"hse"},{"location":"api/Files/dir_74519b06cb360fd5deb315947aad9941/#hse","text":"","title":"hse"},{"location":"api/Files/dir_74519b06cb360fd5deb315947aad9941/#files","text":"Name hse/flags.h hse/hse.h hse/limits.h hse/types.h Updated on 1 October 2021 at 17:03:30 CDT","title":"Files"},{"location":"api/Files/dir_8f2980731aba7ec7b9fcae5764f196e3/","text":"include Directories Name hse Updated on 1 October 2021 at 17:03:30 CDT","title":"include"},{"location":"api/Files/dir_8f2980731aba7ec7b9fcae5764f196e3/#include","text":"","title":"include"},{"location":"api/Files/dir_8f2980731aba7ec7b9fcae5764f196e3/#directories","text":"Name hse Updated on 1 October 2021 at 17:03:30 CDT","title":"Directories"},{"location":"api/Files/dir_d44c64559bbebec7f509842c48db8b23/","text":"include Directories Name hse Updated on 1 October 2021 at 17:03:30 CDT","title":"include"},{"location":"api/Files/dir_d44c64559bbebec7f509842c48db8b23/#include","text":"","title":"include"},{"location":"api/Files/dir_d44c64559bbebec7f509842c48db8b23/#directories","text":"Name hse Updated on 1 October 2021 at 17:03:30 CDT","title":"Directories"},{"location":"api/Files/flags_8h/","text":"hse/flags.h Defines Name HSE_KVDB_SYNC_ASYNC HSE_KVDB_SYNC_RSVD1 HSE_KVS_PUT_PRIO HSE_KVS_PUT_VCOMP_OFF HSE_CURSOR_CREATE_REV Macros Documentation define HSE_KVDB_SYNC_ASYNC #define HSE_KVDB_SYNC_ASYNC (1u << 0) define HSE_KVDB_SYNC_RSVD1 #define HSE_KVDB_SYNC_RSVD1 (1u << 1) define HSE_KVS_PUT_PRIO #define HSE_KVS_PUT_PRIO (1u << 0) define HSE_KVS_PUT_VCOMP_OFF #define HSE_KVS_PUT_VCOMP_OFF (1u << 1) define HSE_CURSOR_CREATE_REV #define HSE_CURSOR_CREATE_REV (1u << 0) Source code /* SPDX-License-Identifier: Apache-2.0 */ /* * Copyright (C) 2021 Micron Technology, Inc. All rights reserved. */ #ifndef HSE_FLAGS_H #define HSE_FLAGS_H #ifdef __cplusplus extern \"C\" { #endif /* Documentation for these flags appears in hse.h */ /* hse_kvdb_sync() flags */ #define HSE_KVDB_SYNC_ASYNC (1u << 0) #define HSE_KVDB_SYNC_RSVD1 (1u << 1) /* hse_kvs_put() flags */ #define HSE_KVS_PUT_PRIO (1u << 0) #define HSE_KVS_PUT_VCOMP_OFF (1u << 1) /* hse_kvs_cursor_create() flags */ #define HSE_CURSOR_CREATE_REV (1u << 0) #ifdef HSE_EXPERIMENTAL /* hse_kvdb_compact() flags */ #define HSE_KVDB_COMPACT_CANCEL (1u << 0) #define HSE_KVDB_COMPACT_SAMP_LWM (1u << 1) #endif #ifdef __cplusplus } #endif #endif Updated on 1 October 2021 at 17:03:30 CDT","title":"hse/flags.h"},{"location":"api/Files/flags_8h/#hseflagsh","text":"","title":"hse/flags.h"},{"location":"api/Files/flags_8h/#defines","text":"Name HSE_KVDB_SYNC_ASYNC HSE_KVDB_SYNC_RSVD1 HSE_KVS_PUT_PRIO HSE_KVS_PUT_VCOMP_OFF HSE_CURSOR_CREATE_REV","title":"Defines"},{"location":"api/Files/flags_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"api/Files/flags_8h/#define-hse_kvdb_sync_async","text":"#define HSE_KVDB_SYNC_ASYNC (1u << 0)","title":"define HSE_KVDB_SYNC_ASYNC"},{"location":"api/Files/flags_8h/#define-hse_kvdb_sync_rsvd1","text":"#define HSE_KVDB_SYNC_RSVD1 (1u << 1)","title":"define HSE_KVDB_SYNC_RSVD1"},{"location":"api/Files/flags_8h/#define-hse_kvs_put_prio","text":"#define HSE_KVS_PUT_PRIO (1u << 0)","title":"define HSE_KVS_PUT_PRIO"},{"location":"api/Files/flags_8h/#define-hse_kvs_put_vcomp_off","text":"#define HSE_KVS_PUT_VCOMP_OFF (1u << 1)","title":"define HSE_KVS_PUT_VCOMP_OFF"},{"location":"api/Files/flags_8h/#define-hse_cursor_create_rev","text":"#define HSE_CURSOR_CREATE_REV (1u << 0)","title":"define HSE_CURSOR_CREATE_REV"},{"location":"api/Files/flags_8h/#source-code","text":"/* SPDX-License-Identifier: Apache-2.0 */ /* * Copyright (C) 2021 Micron Technology, Inc. All rights reserved. */ #ifndef HSE_FLAGS_H #define HSE_FLAGS_H #ifdef __cplusplus extern \"C\" { #endif /* Documentation for these flags appears in hse.h */ /* hse_kvdb_sync() flags */ #define HSE_KVDB_SYNC_ASYNC (1u << 0) #define HSE_KVDB_SYNC_RSVD1 (1u << 1) /* hse_kvs_put() flags */ #define HSE_KVS_PUT_PRIO (1u << 0) #define HSE_KVS_PUT_VCOMP_OFF (1u << 1) /* hse_kvs_cursor_create() flags */ #define HSE_CURSOR_CREATE_REV (1u << 0) #ifdef HSE_EXPERIMENTAL /* hse_kvdb_compact() flags */ #define HSE_KVDB_COMPACT_CANCEL (1u << 0) #define HSE_KVDB_COMPACT_SAMP_LWM (1u << 1) #endif #ifdef __cplusplus } #endif #endif Updated on 1 October 2021 at 17:03:30 CDT","title":"Source code"},{"location":"api/Files/hse_8h/","text":"hse/hse.h Functions Name HSE_EXPORT size_t hse_strerror ( hse_err_t err, char * buf, size_t buf_len) Return an hse_err_t value's string representation. HSE_EXPORT int hse_err_to_errno ( hse_err_t err) Return an hse_err_t value's errno representation. HSE_EXPORT hse_err_t hse_init (const char * config, size_t paramc, const char *const * paramv) Initialize the HSE subsystem. HSE_EXPORT void hse_fini (void ) Shutdown the HSE subsystem. HSE_EXPORT hse_err_t hse_kvdb_create (const char * kvdb_home, size_t paramc, const char *const * paramv) Create a KVDB. HSE_EXPORT hse_err_t hse_kvdb_drop (const char * kvdb_home) Drop a KVDB. HSE_EXPORT hse_err_t hse_kvdb_open (const char * kvdb_home, size_t paramc, const char const * paramv, struct hse_kvdb * kvdb) Open a KVDB. HSE_EXPORT hse_err_t hse_kvdb_close (struct hse_kvdb * kvdb) Close a KVDB. HSE_EXPORT hse_err_t hse_kvdb_kvs_names_get (struct hse_kvdb * kvdb, size_t * namec, char *** namev) Get the names of the KVSs within the given KVDB. HSE_EXPORT void hse_kvdb_kvs_names_free (struct hse_kvdb * kvdb, char ** namev) Free the names collection obtained through hse_kvdb_kvs_names_get() . HSE_EXPORT hse_err_t hse_kvdb_kvs_create (struct hse_kvdb * kvdb, const char * kvs_name, size_t paramc, const char *const * paramv) Create a KVS within the referenced KVDB. HSE_EXPORT hse_err_t hse_kvdb_kvs_drop (struct hse_kvdb * kvdb, const char * kvs_name) Drop a KVS from the referenced KVDB. HSE_EXPORT hse_err_t hse_kvdb_kvs_open (struct hse_kvdb * handle, const char * kvs_name, const size_t paramc, const char const * paramv, struct hse_kvs * kvs_out) Open a KVS in a KVDB. HSE_EXPORT hse_err_t hse_kvdb_kvs_close (struct hse_kvs * kvs) Close an open KVS. HSE_EXPORT hse_err_t hse_kvs_put (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * key, size_t key_len, const void * val, size_t val_len) Put a key-value pair into KVS. HSE_EXPORT hse_err_t hse_kvs_get (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * key, size_t key_len, bool * found, void * buf, size_t buf_len, size_t * val_len) Retrieve the value for a given key from KVS. HSE_EXPORT hse_err_t hse_kvs_delete (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * key, size_t key_len) Delete the key and its associated value from KVS. HSE_EXPORT hse_err_t hse_kvs_prefix_delete (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * pfx, size_t pfx_len) Delete all key-value pairs matching the key prefix from a KVS storing segmented keys. HSE_EXPORT struct hse_kvdb_txn * hse_kvdb_txn_alloc (struct hse_kvdb * kvdb) Allocate transaction object. HSE_EXPORT void hse_kvdb_txn_free (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Free transaction object. HSE_EXPORT hse_err_t hse_kvdb_txn_begin (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Initiate transaction. HSE_EXPORT hse_err_t hse_kvdb_txn_commit (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Commit all the mutations of the referenced transaction. HSE_EXPORT hse_err_t hse_kvdb_txn_abort (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Abort/rollback transaction. HSE_EXPORT enum hse_kvdb_txn_state hse_kvdb_txn_state_get (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Retrieve the state of the referenced transaction. HSE_EXPORT hse_err_t hse_kvs_cursor_create (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * filter, size_t filter_len, struct hse_kvs_cursor ** cursor) Creates a cursor used to iterate over key-value pairs in a KVS. HSE_EXPORT hse_err_t hse_kvs_cursor_update_view (struct hse_kvs_cursor * cursor, unsigned int flags) Update a plain cursor or modify any cursor. HSE_EXPORT hse_err_t hse_kvs_cursor_seek (struct hse_kvs_cursor * cursor, unsigned int flags, const void * key, size_t key_len, const void ** found, size_t * found_len) Move the cursor to point at the key-value pair at or closest to \"key\". HSE_EXPORT hse_err_t hse_kvs_cursor_seek_range (struct hse_kvs_cursor * cursor, unsigned int flags, const void * filt_min, size_t filt_min_len, const void * filt_max, size_t filt_max_len, const void ** found, size_t * found_len) Move the cursor to the closest match to key, gated by the given filter. HSE_EXPORT hse_err_t hse_kvs_cursor_read (struct hse_kvs_cursor * cursor, unsigned int flags, const void key, size_t * key_len, const void val, size_t * val_len, bool * eof) Iteratively access the elements pointed to by the cursor. HSE_EXPORT hse_err_t hse_kvs_cursor_destroy (struct hse_kvs_cursor * cursor) Destroy cursor. HSE_EXPORT hse_err_t hse_kvdb_sync (struct hse_kvdb * kvdb, unsigned int flags) Sync data in all of the referenced KVDB's KVSs to stable media and return. HSE_EXPORT hse_err_t hse_kvdb_storage_add (const char * kvdb_home, size_t paramc, const char *const * paramv) Defines Name HSE_EXPORT HSE_EXPORT_EXPERIMENTAL Functions Documentation function hse_strerror HSE_EXPORT size_t hse_strerror ( hse_err_t err , char * buf , size_t buf_len ) Return an hse_err_t value's string representation. Parameters : err Error value returned from an HSE API function. buf Buffer to hold the formatted string. buf_len Length of buffer. Return : The number of characters (excluding the terminating null byte) which would have been written to the final string if enough space had been available. The hse_err_t scalar value err is decoded into a NULL-terminated string representation giving more information about the error and where it occurred. The string will be truncated if buf_len is too small (a buf_len value of 128 is sufficient to avoid truncation of most error strings). This function is thread safe. function hse_err_to_errno HSE_EXPORT int hse_err_to_errno ( hse_err_t err ) Return an hse_err_t value's errno representation. Parameters : err Error value returned from an HSE API function. Return : The error's errno equivalent. The hse_err_t scalar value err is translated into its errno equivalent. This function is thread safe. function hse_init HSE_EXPORT hse_err_t hse_init ( const char * config , size_t paramc , const char * const * paramv ) Initialize the HSE subsystem. Parameters : config Path to a global configuration file. paramc Number of initialization parameters in paramv . paramv List of parameters in key=value format. Return : Error status This function initializes a range of different internal HSE structures. It must be called before any other HSE functions are used. It is not thread safe and is idempotent. function hse_fini HSE_EXPORT void hse_fini ( void ) Shutdown the HSE subsystem. This function cleanly finalizes a range of different internal HSE structures. It should be called prior to application exit and is not thread safe. After it is invoked (and even before it returns), calling any other HSE functions will result in undefined behavior. This function is not thread safe. function hse_kvdb_create HSE_EXPORT hse_err_t hse_kvdb_create ( const char * kvdb_home , size_t paramc , const char * const * paramv ) Create a KVDB. Parameters : kvdb_home KVDB home directory, NULL means current working directory. paramc Number of configuration parameters in paramv . paramv List of parameters in key=value format. Return : The function's error status This function is not thread safe. function hse_kvdb_drop HSE_EXPORT hse_err_t hse_kvdb_drop ( const char * kvdb_home ) Drop a KVDB. Parameters : kvdb_home KVDB home directory, NULL means current working directory. Return : Error status It is an error to call this function on a KVDB that is open. This function is not thread safe. function hse_kvdb_open HSE_EXPORT hse_err_t hse_kvdb_open ( const char * kvdb_home , size_t paramc , const char * const * paramv , struct hse_kvdb ** kvdb ) Open a KVDB. Parameters : kvdb_home KVDB home directory, NULL means current working directory paramc Number of configuration parameters in paramv . paramv List of parameters in key=value format. kvdb Handle to access the opened KVDB. Return : Error status The KVDB must already exist and the client must have permission to use it. This function is not thread safe. function hse_kvdb_close HSE_EXPORT hse_err_t hse_kvdb_close ( struct hse_kvdb * kvdb ) Close a KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() . Return : Error status No client thread may enter the HSE KVDB API with the referenced KVDB after this function starts. This function is not thread safe. function hse_kvdb_kvs_names_get HSE_EXPORT hse_err_t hse_kvdb_kvs_names_get ( struct hse_kvdb * kvdb , size_t * namec , char *** namev ) Get the names of the KVSs within the given KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() . namec Number of KVSs in the KVDB. namev Vector of KVSs. Allocated by the function. Return : Error status Key-value stores (KVSs) are opened by name. This function allocates a vector of allocated strings, each containing the NULL-terminated name of a KVS. The memory must be freed via hse_kvdb_kvs_names_free() . This function is thread safe. Example Usage: int namec , i , rc ; char ** namev ; rc = hse_kvdb_kvs_names_get ( kvdb , & namec , & namev ); if ( ! rc ) { for ( i = 0 ; i < namec ; i ++ ) printf ( \"%s \\n \" , namev [ i ]); } hse_kvdb_kvs_names_free ( namev ); Filename: .c function hse_kvdb_kvs_names_free HSE_EXPORT void hse_kvdb_kvs_names_free ( struct hse_kvdb * kvdb , char ** namev ) Free the names collection obtained through hse_kvdb_kvs_names_get() . Parameters : kvdb KVDB handle from hse_kvdb_open() . namev Vector of KVS names that hse_kvdb_kvs_names_get() output. This function is thread safe. function hse_kvdb_kvs_create HSE_EXPORT hse_err_t hse_kvdb_kvs_create ( struct hse_kvdb * kvdb , const char * kvs_name , size_t paramc , const char * const * paramv ) Create a KVS within the referenced KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() . kvs_name KVS name (NULL terminated, strlen() < HSE_KVS_NAME_LEN_MAX) paramc Number of configuration parameters in paramv . paramv List of parameters in key=value format. Return : Error status If the KVS will store segmented keys then the parameter \"pfx_len\" should be set to the desired key prefix length. An error will result if there is already a KVS with the given name. This function is not thread safe. function hse_kvdb_kvs_drop HSE_EXPORT hse_err_t hse_kvdb_kvs_drop ( struct hse_kvdb * kvdb , const char * kvs_name ) Drop a KVS from the referenced KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() kvs_name KVS name (NULL-terminated string) Return : The function's error status It is an error to call this function on a KVS that is open. This function is not thread safe. function hse_kvdb_kvs_open HSE_EXPORT hse_err_t hse_kvdb_kvs_open ( struct hse_kvdb * handle , const char * kvs_name , const size_t paramc , const char * const * paramv , struct hse_kvs ** kvs_out ) Open a KVS in a KVDB. Parameters : handle KVDB handle from hse_kvdb_open() . kvs_name KVS name (NULL terminated string). paramc Number of configuration parameters in paramv . paramv List of parameters in key=value format. kvs_out Handle to access the opened KVS. Return : The function's error status This function is not thread safe. function hse_kvdb_kvs_close HSE_EXPORT hse_err_t hse_kvdb_kvs_close ( struct hse_kvs * kvs ) Close an open KVS. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . Return : The function's error status No client thread may enter the HSE KVDB API with the referenced KVS after this function starts. This function is not thread safe. function hse_kvs_put HSE_EXPORT hse_err_t hse_kvs_put ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * key , size_t key_len , const void * val , size_t val_len ) Put a key-value pair into KVS. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . flags Flags for operation specialization. txn Transaction context. key Key to put into kvs. key_len Length of key. val Value associated with key. val_len Length of value. Return : Error status If the key already exists in the KVS then the value is effectively overwritten. The key length must be in the range [1, HSE_KVS_KEY_LEN_MAX] while the value length must be in the range [0, HSE_KVS_VALUE_LEN_MAX]. See the section on transactions for information on how puts within transactions are handled. This function is thread safe. The HSE KVDB attempts to maintain reasonable QoS and for high-throughput clients this results in very short sleep's being inserted into the put path. For some kinds of data (e.g., control metadata) the client may wish to not experience that delay. For relatively low data rate uses, the caller can set the HSE_FLAG_PUT_PRIORITY flag for an hse_kvs_put() . Care should be taken when doing so to ensure that the system does not become overrun. As a rough approximation, doing 1M priority puts per second marked as PRIORITY is likely an issue. On the other hand, doing 1K small puts per second marked as PRIORITY is almost certainly fine. If compression is enabled for the given kvs, then hse_kvs_put() will attempt to compress the value unless the HSE_FLAG_PUT_VCOMP_OFF flag is given. Otherwise, the HSE_FLAG_PUT_VCOMP_OFF flag is ignored. Flags: HSE_FLAG_PUT_PRIORITY - Operation will not be throttled HSE_FLAG_PUT_VCOMP_OFF - Value will not be compressed function hse_kvs_get HSE_EXPORT hse_err_t hse_kvs_get ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * key , size_t key_len , bool * found , void * buf , size_t buf_len , size_t * val_len ) Retrieve the value for a given key from KVS. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . flags Flags for operation specialization. txn Transaction context. key Key to get from kvs. key_len Length of key. found Whether or not key was found. buf Buffer into which the value associated with key will be copied. buf_len Length of buffer. val_len Actual length of value if key was found. Return : Error status If the key exists in the KVS then the referent of \"found\" is set to true. If the caller's value buffer is large enough then the data will be returned. Regardless, the actual length of the value is placed in \"val_len\". See the section on transactions for information on how gets within transactions are handled. This function is thread safe. Flags: 0 - reserved for future use function hse_kvs_delete HSE_EXPORT hse_err_t hse_kvs_delete ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * key , size_t key_len ) Delete the key and its associated value from KVS. Parameters : kvs KVS handle from hse_kvdb_kvs_open() flags Flags for operation specialization txn Transaction context (optional) key Key to be deleted from kvs key_len Length of key Return : Error status It is not an error if the key does not exist within the KVS. See the section on transactions for information on how deletes within transactions are handled. This function is thread safe. Flags: 0 - reserved for future use function hse_kvs_prefix_delete HSE_EXPORT hse_err_t hse_kvs_prefix_delete ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * pfx , size_t pfx_len ) Delete all key-value pairs matching the key prefix from a KVS storing segmented keys. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . flags Flags for operation specialization. txn Transaction context (optional). pfx Prefix of keys to delete. pfx_len Prefix length. Return : Error status This interface is used to delete an entire range of segmented keys. To do this the caller passes a filter with a length equal to the KVS's key prefix length. It is not an error if no keys exist matching the filter. If there is a filtered iteration in progress, then that iteration can fail if hse_kvs_prefix_delete() is called with a filter matching the iteration. This function is thread safe. If hse_kvs_prefix_delete() is called from a transaction context, it affects no key-value mutations that are part of the same transaction. Stated differently, for KVS commands issued within a transaction, all calls to hse_kvs_prefix_delete() are treated as though they were issued serially at the beginning of the transaction regardless of the actual order these commands appeared in. Flags: 0 - reserved for future use function hse_kvdb_txn_alloc HSE_EXPORT struct hse_kvdb_txn * hse_kvdb_txn_alloc ( struct hse_kvdb * kvdb ) Allocate transaction object. Parameters : kvdb KVDB handle from hse_kvdb_open() . Return : The allocated transaction structure. This object can and should be re-used many times to avoid the overhead of allocation. This function is thread safe. function hse_kvdb_txn_free HSE_EXPORT void hse_kvdb_txn_free ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Free transaction object. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle. If the transaction handle refers to an ACTIVE transaction, the transaction is aborted prior to being freed. This function is thread safe with different transactions. function hse_kvdb_txn_begin HSE_EXPORT hse_err_t hse_kvdb_txn_begin ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Initiate transaction. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle from hse_kvdb_txn_alloc() . Return : The function's error status The call fails if the transaction handle refers to an ACTIVE transaction. This function is thread safe with different transactions. function hse_kvdb_txn_commit HSE_EXPORT hse_err_t hse_kvdb_txn_commit ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Commit all the mutations of the referenced transaction. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle from hse_kvdb_txn_alloc() . Return : Error status The call fails if the referenced transaction is not in the ACTIVE state. This function is thread safe with different transactions. function hse_kvdb_txn_abort HSE_EXPORT hse_err_t hse_kvdb_txn_abort ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Abort/rollback transaction. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle from hse_kvdb_txn_alloc() . Return : Error status The call fails if the referenced transaction is not in the ACTIVE state. This function is thread safe with different transactions. function hse_kvdb_txn_state_get HSE_EXPORT enum hse_kvdb_txn_state hse_kvdb_txn_state_get ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Retrieve the state of the referenced transaction. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle from hse_kvdb_txn_alloc() . Return : The transaction's state This function is thread safe with different transactions. function hse_kvs_cursor_create HSE_EXPORT hse_err_t hse_kvs_cursor_create ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * filter , size_t filter_len , struct hse_kvs_cursor ** cursor ) Creates a cursor used to iterate over key-value pairs in a KVS. Parameters : kvs KVS to iterate over, handle from hse_kvdb_kvs_open() . flags Flags for operation specialization. txn Transaction context (optional). filter Iteration limited to keys matching this prefix filter (optional). filter_len Length of filter (optional). cursor Cursor handle. Return : Error status Non-transaction cursors: If txn is NULL, a non-transaction cursor is created. Non-transaction cursors have an ephemeral snapshot view of the KVS at the time it the cursor is created. The snapshot view is maintained for the life of the cursor. Writes to the KVS (put, deletes, etc.) made after the cursor is created will not be visible to the cursor unless hse_kvs_cursor_update_view() is used to obtain a more recent snapshot view. Non transaction cursors can be used on transaction and non-transaction KVSs. Transaction cursors: If txn is not NULL, it must be a valid transaction handle or undefined behavior will result. If it is a valid handle to a transaction in the ACTIVE state, a transaction cursor is created. A transaction cursor's view includes the transaction's writes overlaid on the transaction's ephemeral snapshot view of the KVS. If the transaction is committed or aborted before the cursor is destroyed, the cursor's view reverts to same snaphsot view the transaction had when first became active. The cursor will no longer be able to see the transaction's writes. Calling hse_kvs_cursor_update_view() on a transaction cursor is a no-op and has no effect on the cursor's view. Transaction cursors can only be used on transaction KVSs. Prefix vs non-prefix cursors: Parameters filter and filter_len can be used to iterate over the subset of keys in the KVS whose first filter_len bytes match the filter_len bytes pointed to by filter . A prefix cursor is created when: KVS was created with pfx_len > 0 (i.e., it is a prefix KVS), and filter != NULL and filter_len >= @ pfx_len. Otherwise, a non-prefix cursor is created. Applications should arrange their key-value data to avoid the need for non-prefix cursors as they are significantly slower and more resource-intensive than prefix cursors. Note that simply using a filter doesn't create a prefix cursor \u2013 it must meet the two conditions listed above. Flags: HSE_FLAG_CURSOR_REVERSE - iterate in reverse lexicographic order This function is thread safe across disparate cursors. function hse_kvs_cursor_update_view HSE_EXPORT hse_err_t hse_kvs_cursor_update_view ( struct hse_kvs_cursor * cursor , unsigned int flags ) Update a plain cursor or modify any cursor. Parameters : cursor Cursor handle from hse_kvs_cursor_create() . flags Flags for operation specialization. Return : The function's error status This operation updates the snapshot view of a non-transaction cursor. It is a no-op on transaction cursors. This function is thread safe across disparate cursors. Flags: 0 - reserved for future use function hse_kvs_cursor_seek HSE_EXPORT hse_err_t hse_kvs_cursor_seek ( struct hse_kvs_cursor * cursor , unsigned int flags , const void * key , size_t key_len , const void ** found , size_t * found_len ) Move the cursor to point at the key-value pair at or closest to \"key\". Parameters : cursor Cursor handle from hse_kvs_cursor_create() . flags Flags for operation specialization. key Key to find. key_len Length of key. found If non-NULL, referent point to next key in sequence (optional). found_len If \"found\" is non-NULL, referent is length of \"found\" key. Return : Error status The next hse_kvs_cursor_read() will start at this point. Both \"found\" and \"found_len\" must be non-NULL for that functionality to work. This function is thread safe across disparate cursors. Flags: 0 - reserved for future use function hse_kvs_cursor_seek_range HSE_EXPORT hse_err_t hse_kvs_cursor_seek_range ( struct hse_kvs_cursor * cursor , unsigned int flags , const void * filt_min , size_t filt_min_len , const void * filt_max , size_t filt_max_len , const void ** found , size_t * found_len ) Move the cursor to the closest match to key, gated by the given filter. Parameters : cursor Cursor handle from hse_kvs_cursor_create() . flags Flags for operation specialization. filt_min Filter minimum. filt_min_len Length of filter minimum. filt_max Filter maximum. filt_max_len Length of filter maximum. found If non-NULL, referent points to next key in sequence (optional). found_len If non-NULL, referent is length of \"found\" key (optional). Return : Error status Keys read from this cursor will belong to the closed interval defined by the given filter: [ filt_min , filt_max ]. For KVSs storing segmented keys, performance will be enhanced when filt_min_len and filt_max_len are greater than or equal to the KVS key prefix length. Both found and found_len must be non-NULL for that functionality to work. This function is thread safe across disparate cursors. Note: this is only supported for forward cursors. Flags: 0 - reserved for future use function hse_kvs_cursor_read HSE_EXPORT hse_err_t hse_kvs_cursor_read ( struct hse_kvs_cursor * cursor , unsigned int flags , const void ** key , size_t * key_len , const void ** val , size_t * val_len , bool * eof ) Iteratively access the elements pointed to by the cursor. Parameters : cursor Cursor handle from hse_kvs_cursor_create() . flags Flags for operation specialization. key Next key in sequence. key_len Length of key. val Next value in sequence. val_len Length of value. eof If true, no more key-value pairs in sequence. Return : Error status Read a key-value pair from the cursor, advancing the cursor past its current location. If the cursor is at EOF, attempts to read from it will not change the state of the cursor. This function is thread safe across disparate cursors. Flags: 0 - reserved for future use function hse_kvs_cursor_destroy HSE_EXPORT hse_err_t hse_kvs_cursor_destroy ( struct hse_kvs_cursor * cursor ) Destroy cursor. Parameters : cursor Cursor handle from hse_kvs_cursor_create() . Return : The function's error status This function is thread safe. function hse_kvdb_sync HSE_EXPORT hse_err_t hse_kvdb_sync ( struct hse_kvdb * kvdb , unsigned int flags ) Sync data in all of the referenced KVDB's KVSs to stable media and return. Parameters : kvdb KVDB handle from hse_kvdb_open() . flags Flags for operation specialization. Return : Error status Flags: HSE_KVDB_SYNC_ASYNC - Return immediately after initiating operation instead of waiting for completion. function hse_kvdb_storage_add HSE_EXPORT hse_err_t hse_kvdb_storage_add ( const char * kvdb_home , size_t paramc , const char * const * paramv ) Parameters : kvdb_home KVDB home directory, NULL means current working directory. paramc Number of configuration parameters in paramv . paramv List of KVDB create-time parameters in key=value format. Return : The function's error status Add a new media class storage to an existing offline KVDB This function is not thread safe. Macros Documentation define HSE_EXPORT #define HSE_EXPORT define HSE_EXPORT_EXPERIMENTAL #define HSE_EXPORT_EXPERIMENTAL Source code /* SPDX-License-Identifier: Apache-2.0 */ /* * Copyright (C) 2015-2021 Micron Technology, Inc. All rights reserved. */ #ifndef HSE_KVDB_API_H #define HSE_KVDB_API_H /* MTF_MOCK_DECL(hse) */ #include <hse/flags.h> #include <hse/limits.h> #include <hse/types.h> #include <hse/version.h> #include <stdbool.h> #include <stddef.h> #include <stdint.h> #include <stdlib.h> #include <limits.h> #ifdef __cplusplus extern \"C\" { #endif #ifdef __has_attribute # if __has_attribute(visibility) # define HSE_EXPORT __attribute__((visibility(\"default\"))) # else # define HSE_EXPORT # endif #else # define HSE_EXPORT #endif #ifdef HSE_EXPORT_EXPERIMENTAL #undef HSE_EXPORT_EXPERIMENTAL #define HSE_EXPORT_EXPERIMENTAL HSE_EXPORT #else #define HSE_EXPORT_EXPERIMENTAL #endif HSE_EXPORT size_t hse_strerror ( hse_err_t err , char * buf , size_t buf_len ); HSE_EXPORT int hse_err_to_errno ( hse_err_t err ); HSE_EXPORT hse_err_t hse_init ( const char * config , size_t paramc , const char * const * paramv ); HSE_EXPORT void hse_fini ( void ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvdb_create ( const char * kvdb_home , size_t paramc , const char * const * paramv ); HSE_EXPORT hse_err_t hse_kvdb_drop ( const char * kvdb_home ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvdb_open ( const char * kvdb_home , size_t paramc , const char * const * paramv , struct hse_kvdb ** kvdb ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvdb_close ( struct hse_kvdb * kvdb ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvdb_kvs_names_get ( struct hse_kvdb * kvdb , size_t * namec , char *** namev ); HSE_EXPORT void hse_kvdb_kvs_names_free ( struct hse_kvdb * kvdb , char ** namev ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvdb_kvs_create ( struct hse_kvdb * kvdb , const char * kvs_name , size_t paramc , const char * const * paramv ); HSE_EXPORT hse_err_t hse_kvdb_kvs_drop ( struct hse_kvdb * kvdb , const char * kvs_name ); HSE_EXPORT hse_err_t hse_kvdb_kvs_open ( struct hse_kvdb * handle , const char * kvs_name , const size_t paramc , const char * const * paramv , struct hse_kvs ** kvs_out ); HSE_EXPORT hse_err_t hse_kvdb_kvs_close ( struct hse_kvs * kvs ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvs_put ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * key , size_t key_len , const void * val , size_t val_len ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvs_get ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * key , size_t key_len , bool * found , void * buf , size_t buf_len , size_t * val_len ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvs_delete ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * key , size_t key_len ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvs_prefix_delete ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * pfx , size_t pfx_len ); #ifdef HSE_EXPERIMENTAL HSE_EXPORT_EXPERIMENTAL hse_err_t hse_kvs_prefix_probe ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * pfx , size_t pfx_len , enum hse_kvs_pfx_probe_cnt * found , void * keybuf , size_t keybuf_sz , size_t * key_len , void * valbuf , size_t valbuf_sz , size_t * val_len ); #endif /* MTF_MOCK */ HSE_EXPORT struct hse_kvdb_txn * hse_kvdb_txn_alloc ( struct hse_kvdb * kvdb ); /* MTF_MOCK */ HSE_EXPORT void hse_kvdb_txn_free ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvdb_txn_begin ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvdb_txn_commit ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvdb_txn_abort ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ); /* MTF_MOCK */ HSE_EXPORT enum hse_kvdb_txn_state hse_kvdb_txn_state_get ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvs_cursor_create ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * filter , size_t filter_len , struct hse_kvs_cursor ** cursor ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvs_cursor_update_view ( struct hse_kvs_cursor * cursor , unsigned int flags ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvs_cursor_seek ( struct hse_kvs_cursor * cursor , unsigned int flags , const void * key , size_t key_len , const void ** found , size_t * found_len ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvs_cursor_seek_range ( struct hse_kvs_cursor * cursor , unsigned int flags , const void * filt_min , size_t filt_min_len , const void * filt_max , size_t filt_max_len , const void ** found , size_t * found_len ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvs_cursor_read ( struct hse_kvs_cursor * cursor , unsigned int flags , const void ** key , size_t * key_len , const void ** val , size_t * val_len , bool * eof ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvs_cursor_destroy ( struct hse_kvs_cursor * cursor ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvdb_sync ( struct hse_kvdb * kvdb , unsigned int flags ); /* empty here to maintain the order in doxygen output, see include/hse/limits.h */ #ifdef HSE_EXPERIMENTAL HSE_EXPORT_EXPERIMENTAL hse_err_t hse_kvdb_compact ( struct hse_kvdb * kvdb , unsigned int flags ); HSE_EXPORT_EXPERIMENTAL hse_err_t hse_kvdb_compact_status_get ( struct hse_kvdb * kvdb , struct hse_kvdb_compact_status * status ); HSE_EXPORT_EXPERIMENTAL hse_err_t hse_kvdb_storage_info_get ( struct hse_kvdb * kvdb , struct hse_kvdb_storage_info * info ); #endif HSE_EXPORT hse_err_t hse_kvdb_storage_add ( const char * kvdb_home , size_t paramc , const char * const * paramv ); #undef HSE_EXPORT_EXPERIMENTAL #undef HSE_EXPORT #if HSE_MOCKING /* This is a complete hack because of the way mocks are generated. HSE_EXPORT * gets pulled as part of the function declaration when creating the function * pointers types for each mocked function. */ #define HSE_EXPORT #define HSE_EXPORT_EXPERIMENTAL #include \"hse_ut.h\" #undef HSE_EXPORT_EXPERIMENTAL #undef HSE_EXPORT #endif /* HSE_MOCKING */ #ifdef __cplusplus } #endif #endif Updated on 1 October 2021 at 17:03:30 CDT","title":"hse/hse.h"},{"location":"api/Files/hse_8h/#hsehseh","text":"","title":"hse/hse.h"},{"location":"api/Files/hse_8h/#functions","text":"Name HSE_EXPORT size_t hse_strerror ( hse_err_t err, char * buf, size_t buf_len) Return an hse_err_t value's string representation. HSE_EXPORT int hse_err_to_errno ( hse_err_t err) Return an hse_err_t value's errno representation. HSE_EXPORT hse_err_t hse_init (const char * config, size_t paramc, const char *const * paramv) Initialize the HSE subsystem. HSE_EXPORT void hse_fini (void ) Shutdown the HSE subsystem. HSE_EXPORT hse_err_t hse_kvdb_create (const char * kvdb_home, size_t paramc, const char *const * paramv) Create a KVDB. HSE_EXPORT hse_err_t hse_kvdb_drop (const char * kvdb_home) Drop a KVDB. HSE_EXPORT hse_err_t hse_kvdb_open (const char * kvdb_home, size_t paramc, const char const * paramv, struct hse_kvdb * kvdb) Open a KVDB. HSE_EXPORT hse_err_t hse_kvdb_close (struct hse_kvdb * kvdb) Close a KVDB. HSE_EXPORT hse_err_t hse_kvdb_kvs_names_get (struct hse_kvdb * kvdb, size_t * namec, char *** namev) Get the names of the KVSs within the given KVDB. HSE_EXPORT void hse_kvdb_kvs_names_free (struct hse_kvdb * kvdb, char ** namev) Free the names collection obtained through hse_kvdb_kvs_names_get() . HSE_EXPORT hse_err_t hse_kvdb_kvs_create (struct hse_kvdb * kvdb, const char * kvs_name, size_t paramc, const char *const * paramv) Create a KVS within the referenced KVDB. HSE_EXPORT hse_err_t hse_kvdb_kvs_drop (struct hse_kvdb * kvdb, const char * kvs_name) Drop a KVS from the referenced KVDB. HSE_EXPORT hse_err_t hse_kvdb_kvs_open (struct hse_kvdb * handle, const char * kvs_name, const size_t paramc, const char const * paramv, struct hse_kvs * kvs_out) Open a KVS in a KVDB. HSE_EXPORT hse_err_t hse_kvdb_kvs_close (struct hse_kvs * kvs) Close an open KVS. HSE_EXPORT hse_err_t hse_kvs_put (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * key, size_t key_len, const void * val, size_t val_len) Put a key-value pair into KVS. HSE_EXPORT hse_err_t hse_kvs_get (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * key, size_t key_len, bool * found, void * buf, size_t buf_len, size_t * val_len) Retrieve the value for a given key from KVS. HSE_EXPORT hse_err_t hse_kvs_delete (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * key, size_t key_len) Delete the key and its associated value from KVS. HSE_EXPORT hse_err_t hse_kvs_prefix_delete (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * pfx, size_t pfx_len) Delete all key-value pairs matching the key prefix from a KVS storing segmented keys. HSE_EXPORT struct hse_kvdb_txn * hse_kvdb_txn_alloc (struct hse_kvdb * kvdb) Allocate transaction object. HSE_EXPORT void hse_kvdb_txn_free (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Free transaction object. HSE_EXPORT hse_err_t hse_kvdb_txn_begin (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Initiate transaction. HSE_EXPORT hse_err_t hse_kvdb_txn_commit (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Commit all the mutations of the referenced transaction. HSE_EXPORT hse_err_t hse_kvdb_txn_abort (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Abort/rollback transaction. HSE_EXPORT enum hse_kvdb_txn_state hse_kvdb_txn_state_get (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Retrieve the state of the referenced transaction. HSE_EXPORT hse_err_t hse_kvs_cursor_create (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * filter, size_t filter_len, struct hse_kvs_cursor ** cursor) Creates a cursor used to iterate over key-value pairs in a KVS. HSE_EXPORT hse_err_t hse_kvs_cursor_update_view (struct hse_kvs_cursor * cursor, unsigned int flags) Update a plain cursor or modify any cursor. HSE_EXPORT hse_err_t hse_kvs_cursor_seek (struct hse_kvs_cursor * cursor, unsigned int flags, const void * key, size_t key_len, const void ** found, size_t * found_len) Move the cursor to point at the key-value pair at or closest to \"key\". HSE_EXPORT hse_err_t hse_kvs_cursor_seek_range (struct hse_kvs_cursor * cursor, unsigned int flags, const void * filt_min, size_t filt_min_len, const void * filt_max, size_t filt_max_len, const void ** found, size_t * found_len) Move the cursor to the closest match to key, gated by the given filter. HSE_EXPORT hse_err_t hse_kvs_cursor_read (struct hse_kvs_cursor * cursor, unsigned int flags, const void key, size_t * key_len, const void val, size_t * val_len, bool * eof) Iteratively access the elements pointed to by the cursor. HSE_EXPORT hse_err_t hse_kvs_cursor_destroy (struct hse_kvs_cursor * cursor) Destroy cursor. HSE_EXPORT hse_err_t hse_kvdb_sync (struct hse_kvdb * kvdb, unsigned int flags) Sync data in all of the referenced KVDB's KVSs to stable media and return. HSE_EXPORT hse_err_t hse_kvdb_storage_add (const char * kvdb_home, size_t paramc, const char *const * paramv)","title":"Functions"},{"location":"api/Files/hse_8h/#defines","text":"Name HSE_EXPORT HSE_EXPORT_EXPERIMENTAL","title":"Defines"},{"location":"api/Files/hse_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/Files/hse_8h/#function-hse_strerror","text":"HSE_EXPORT size_t hse_strerror ( hse_err_t err , char * buf , size_t buf_len ) Return an hse_err_t value's string representation. Parameters : err Error value returned from an HSE API function. buf Buffer to hold the formatted string. buf_len Length of buffer. Return : The number of characters (excluding the terminating null byte) which would have been written to the final string if enough space had been available. The hse_err_t scalar value err is decoded into a NULL-terminated string representation giving more information about the error and where it occurred. The string will be truncated if buf_len is too small (a buf_len value of 128 is sufficient to avoid truncation of most error strings). This function is thread safe.","title":"function hse_strerror"},{"location":"api/Files/hse_8h/#function-hse_err_to_errno","text":"HSE_EXPORT int hse_err_to_errno ( hse_err_t err ) Return an hse_err_t value's errno representation. Parameters : err Error value returned from an HSE API function. Return : The error's errno equivalent. The hse_err_t scalar value err is translated into its errno equivalent. This function is thread safe.","title":"function hse_err_to_errno"},{"location":"api/Files/hse_8h/#function-hse_init","text":"HSE_EXPORT hse_err_t hse_init ( const char * config , size_t paramc , const char * const * paramv ) Initialize the HSE subsystem. Parameters : config Path to a global configuration file. paramc Number of initialization parameters in paramv . paramv List of parameters in key=value format. Return : Error status This function initializes a range of different internal HSE structures. It must be called before any other HSE functions are used. It is not thread safe and is idempotent.","title":"function hse_init"},{"location":"api/Files/hse_8h/#function-hse_fini","text":"HSE_EXPORT void hse_fini ( void ) Shutdown the HSE subsystem. This function cleanly finalizes a range of different internal HSE structures. It should be called prior to application exit and is not thread safe. After it is invoked (and even before it returns), calling any other HSE functions will result in undefined behavior. This function is not thread safe.","title":"function hse_fini"},{"location":"api/Files/hse_8h/#function-hse_kvdb_create","text":"HSE_EXPORT hse_err_t hse_kvdb_create ( const char * kvdb_home , size_t paramc , const char * const * paramv ) Create a KVDB. Parameters : kvdb_home KVDB home directory, NULL means current working directory. paramc Number of configuration parameters in paramv . paramv List of parameters in key=value format. Return : The function's error status This function is not thread safe.","title":"function hse_kvdb_create"},{"location":"api/Files/hse_8h/#function-hse_kvdb_drop","text":"HSE_EXPORT hse_err_t hse_kvdb_drop ( const char * kvdb_home ) Drop a KVDB. Parameters : kvdb_home KVDB home directory, NULL means current working directory. Return : Error status It is an error to call this function on a KVDB that is open. This function is not thread safe.","title":"function hse_kvdb_drop"},{"location":"api/Files/hse_8h/#function-hse_kvdb_open","text":"HSE_EXPORT hse_err_t hse_kvdb_open ( const char * kvdb_home , size_t paramc , const char * const * paramv , struct hse_kvdb ** kvdb ) Open a KVDB. Parameters : kvdb_home KVDB home directory, NULL means current working directory paramc Number of configuration parameters in paramv . paramv List of parameters in key=value format. kvdb Handle to access the opened KVDB. Return : Error status The KVDB must already exist and the client must have permission to use it. This function is not thread safe.","title":"function hse_kvdb_open"},{"location":"api/Files/hse_8h/#function-hse_kvdb_close","text":"HSE_EXPORT hse_err_t hse_kvdb_close ( struct hse_kvdb * kvdb ) Close a KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() . Return : Error status No client thread may enter the HSE KVDB API with the referenced KVDB after this function starts. This function is not thread safe.","title":"function hse_kvdb_close"},{"location":"api/Files/hse_8h/#function-hse_kvdb_kvs_names_get","text":"HSE_EXPORT hse_err_t hse_kvdb_kvs_names_get ( struct hse_kvdb * kvdb , size_t * namec , char *** namev ) Get the names of the KVSs within the given KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() . namec Number of KVSs in the KVDB. namev Vector of KVSs. Allocated by the function. Return : Error status Key-value stores (KVSs) are opened by name. This function allocates a vector of allocated strings, each containing the NULL-terminated name of a KVS. The memory must be freed via hse_kvdb_kvs_names_free() . This function is thread safe. Example Usage: int namec , i , rc ; char ** namev ; rc = hse_kvdb_kvs_names_get ( kvdb , & namec , & namev ); if ( ! rc ) { for ( i = 0 ; i < namec ; i ++ ) printf ( \"%s \\n \" , namev [ i ]); } hse_kvdb_kvs_names_free ( namev ); Filename: .c","title":"function hse_kvdb_kvs_names_get"},{"location":"api/Files/hse_8h/#function-hse_kvdb_kvs_names_free","text":"HSE_EXPORT void hse_kvdb_kvs_names_free ( struct hse_kvdb * kvdb , char ** namev ) Free the names collection obtained through hse_kvdb_kvs_names_get() . Parameters : kvdb KVDB handle from hse_kvdb_open() . namev Vector of KVS names that hse_kvdb_kvs_names_get() output. This function is thread safe.","title":"function hse_kvdb_kvs_names_free"},{"location":"api/Files/hse_8h/#function-hse_kvdb_kvs_create","text":"HSE_EXPORT hse_err_t hse_kvdb_kvs_create ( struct hse_kvdb * kvdb , const char * kvs_name , size_t paramc , const char * const * paramv ) Create a KVS within the referenced KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() . kvs_name KVS name (NULL terminated, strlen() < HSE_KVS_NAME_LEN_MAX) paramc Number of configuration parameters in paramv . paramv List of parameters in key=value format. Return : Error status If the KVS will store segmented keys then the parameter \"pfx_len\" should be set to the desired key prefix length. An error will result if there is already a KVS with the given name. This function is not thread safe.","title":"function hse_kvdb_kvs_create"},{"location":"api/Files/hse_8h/#function-hse_kvdb_kvs_drop","text":"HSE_EXPORT hse_err_t hse_kvdb_kvs_drop ( struct hse_kvdb * kvdb , const char * kvs_name ) Drop a KVS from the referenced KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() kvs_name KVS name (NULL-terminated string) Return : The function's error status It is an error to call this function on a KVS that is open. This function is not thread safe.","title":"function hse_kvdb_kvs_drop"},{"location":"api/Files/hse_8h/#function-hse_kvdb_kvs_open","text":"HSE_EXPORT hse_err_t hse_kvdb_kvs_open ( struct hse_kvdb * handle , const char * kvs_name , const size_t paramc , const char * const * paramv , struct hse_kvs ** kvs_out ) Open a KVS in a KVDB. Parameters : handle KVDB handle from hse_kvdb_open() . kvs_name KVS name (NULL terminated string). paramc Number of configuration parameters in paramv . paramv List of parameters in key=value format. kvs_out Handle to access the opened KVS. Return : The function's error status This function is not thread safe.","title":"function hse_kvdb_kvs_open"},{"location":"api/Files/hse_8h/#function-hse_kvdb_kvs_close","text":"HSE_EXPORT hse_err_t hse_kvdb_kvs_close ( struct hse_kvs * kvs ) Close an open KVS. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . Return : The function's error status No client thread may enter the HSE KVDB API with the referenced KVS after this function starts. This function is not thread safe.","title":"function hse_kvdb_kvs_close"},{"location":"api/Files/hse_8h/#function-hse_kvs_put","text":"HSE_EXPORT hse_err_t hse_kvs_put ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * key , size_t key_len , const void * val , size_t val_len ) Put a key-value pair into KVS. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . flags Flags for operation specialization. txn Transaction context. key Key to put into kvs. key_len Length of key. val Value associated with key. val_len Length of value. Return : Error status If the key already exists in the KVS then the value is effectively overwritten. The key length must be in the range [1, HSE_KVS_KEY_LEN_MAX] while the value length must be in the range [0, HSE_KVS_VALUE_LEN_MAX]. See the section on transactions for information on how puts within transactions are handled. This function is thread safe. The HSE KVDB attempts to maintain reasonable QoS and for high-throughput clients this results in very short sleep's being inserted into the put path. For some kinds of data (e.g., control metadata) the client may wish to not experience that delay. For relatively low data rate uses, the caller can set the HSE_FLAG_PUT_PRIORITY flag for an hse_kvs_put() . Care should be taken when doing so to ensure that the system does not become overrun. As a rough approximation, doing 1M priority puts per second marked as PRIORITY is likely an issue. On the other hand, doing 1K small puts per second marked as PRIORITY is almost certainly fine. If compression is enabled for the given kvs, then hse_kvs_put() will attempt to compress the value unless the HSE_FLAG_PUT_VCOMP_OFF flag is given. Otherwise, the HSE_FLAG_PUT_VCOMP_OFF flag is ignored. Flags: HSE_FLAG_PUT_PRIORITY - Operation will not be throttled HSE_FLAG_PUT_VCOMP_OFF - Value will not be compressed","title":"function hse_kvs_put"},{"location":"api/Files/hse_8h/#function-hse_kvs_get","text":"HSE_EXPORT hse_err_t hse_kvs_get ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * key , size_t key_len , bool * found , void * buf , size_t buf_len , size_t * val_len ) Retrieve the value for a given key from KVS. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . flags Flags for operation specialization. txn Transaction context. key Key to get from kvs. key_len Length of key. found Whether or not key was found. buf Buffer into which the value associated with key will be copied. buf_len Length of buffer. val_len Actual length of value if key was found. Return : Error status If the key exists in the KVS then the referent of \"found\" is set to true. If the caller's value buffer is large enough then the data will be returned. Regardless, the actual length of the value is placed in \"val_len\". See the section on transactions for information on how gets within transactions are handled. This function is thread safe. Flags: 0 - reserved for future use","title":"function hse_kvs_get"},{"location":"api/Files/hse_8h/#function-hse_kvs_delete","text":"HSE_EXPORT hse_err_t hse_kvs_delete ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * key , size_t key_len ) Delete the key and its associated value from KVS. Parameters : kvs KVS handle from hse_kvdb_kvs_open() flags Flags for operation specialization txn Transaction context (optional) key Key to be deleted from kvs key_len Length of key Return : Error status It is not an error if the key does not exist within the KVS. See the section on transactions for information on how deletes within transactions are handled. This function is thread safe. Flags: 0 - reserved for future use","title":"function hse_kvs_delete"},{"location":"api/Files/hse_8h/#function-hse_kvs_prefix_delete","text":"HSE_EXPORT hse_err_t hse_kvs_prefix_delete ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * pfx , size_t pfx_len ) Delete all key-value pairs matching the key prefix from a KVS storing segmented keys. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . flags Flags for operation specialization. txn Transaction context (optional). pfx Prefix of keys to delete. pfx_len Prefix length. Return : Error status This interface is used to delete an entire range of segmented keys. To do this the caller passes a filter with a length equal to the KVS's key prefix length. It is not an error if no keys exist matching the filter. If there is a filtered iteration in progress, then that iteration can fail if hse_kvs_prefix_delete() is called with a filter matching the iteration. This function is thread safe. If hse_kvs_prefix_delete() is called from a transaction context, it affects no key-value mutations that are part of the same transaction. Stated differently, for KVS commands issued within a transaction, all calls to hse_kvs_prefix_delete() are treated as though they were issued serially at the beginning of the transaction regardless of the actual order these commands appeared in. Flags: 0 - reserved for future use","title":"function hse_kvs_prefix_delete"},{"location":"api/Files/hse_8h/#function-hse_kvdb_txn_alloc","text":"HSE_EXPORT struct hse_kvdb_txn * hse_kvdb_txn_alloc ( struct hse_kvdb * kvdb ) Allocate transaction object. Parameters : kvdb KVDB handle from hse_kvdb_open() . Return : The allocated transaction structure. This object can and should be re-used many times to avoid the overhead of allocation. This function is thread safe.","title":"function hse_kvdb_txn_alloc"},{"location":"api/Files/hse_8h/#function-hse_kvdb_txn_free","text":"HSE_EXPORT void hse_kvdb_txn_free ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Free transaction object. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle. If the transaction handle refers to an ACTIVE transaction, the transaction is aborted prior to being freed. This function is thread safe with different transactions.","title":"function hse_kvdb_txn_free"},{"location":"api/Files/hse_8h/#function-hse_kvdb_txn_begin","text":"HSE_EXPORT hse_err_t hse_kvdb_txn_begin ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Initiate transaction. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle from hse_kvdb_txn_alloc() . Return : The function's error status The call fails if the transaction handle refers to an ACTIVE transaction. This function is thread safe with different transactions.","title":"function hse_kvdb_txn_begin"},{"location":"api/Files/hse_8h/#function-hse_kvdb_txn_commit","text":"HSE_EXPORT hse_err_t hse_kvdb_txn_commit ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Commit all the mutations of the referenced transaction. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle from hse_kvdb_txn_alloc() . Return : Error status The call fails if the referenced transaction is not in the ACTIVE state. This function is thread safe with different transactions.","title":"function hse_kvdb_txn_commit"},{"location":"api/Files/hse_8h/#function-hse_kvdb_txn_abort","text":"HSE_EXPORT hse_err_t hse_kvdb_txn_abort ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Abort/rollback transaction. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle from hse_kvdb_txn_alloc() . Return : Error status The call fails if the referenced transaction is not in the ACTIVE state. This function is thread safe with different transactions.","title":"function hse_kvdb_txn_abort"},{"location":"api/Files/hse_8h/#function-hse_kvdb_txn_state_get","text":"HSE_EXPORT enum hse_kvdb_txn_state hse_kvdb_txn_state_get ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Retrieve the state of the referenced transaction. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle from hse_kvdb_txn_alloc() . Return : The transaction's state This function is thread safe with different transactions.","title":"function hse_kvdb_txn_state_get"},{"location":"api/Files/hse_8h/#function-hse_kvs_cursor_create","text":"HSE_EXPORT hse_err_t hse_kvs_cursor_create ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * filter , size_t filter_len , struct hse_kvs_cursor ** cursor ) Creates a cursor used to iterate over key-value pairs in a KVS. Parameters : kvs KVS to iterate over, handle from hse_kvdb_kvs_open() . flags Flags for operation specialization. txn Transaction context (optional). filter Iteration limited to keys matching this prefix filter (optional). filter_len Length of filter (optional). cursor Cursor handle. Return : Error status Non-transaction cursors: If txn is NULL, a non-transaction cursor is created. Non-transaction cursors have an ephemeral snapshot view of the KVS at the time it the cursor is created. The snapshot view is maintained for the life of the cursor. Writes to the KVS (put, deletes, etc.) made after the cursor is created will not be visible to the cursor unless hse_kvs_cursor_update_view() is used to obtain a more recent snapshot view. Non transaction cursors can be used on transaction and non-transaction KVSs. Transaction cursors: If txn is not NULL, it must be a valid transaction handle or undefined behavior will result. If it is a valid handle to a transaction in the ACTIVE state, a transaction cursor is created. A transaction cursor's view includes the transaction's writes overlaid on the transaction's ephemeral snapshot view of the KVS. If the transaction is committed or aborted before the cursor is destroyed, the cursor's view reverts to same snaphsot view the transaction had when first became active. The cursor will no longer be able to see the transaction's writes. Calling hse_kvs_cursor_update_view() on a transaction cursor is a no-op and has no effect on the cursor's view. Transaction cursors can only be used on transaction KVSs. Prefix vs non-prefix cursors: Parameters filter and filter_len can be used to iterate over the subset of keys in the KVS whose first filter_len bytes match the filter_len bytes pointed to by filter . A prefix cursor is created when: KVS was created with pfx_len > 0 (i.e., it is a prefix KVS), and filter != NULL and filter_len >= @ pfx_len. Otherwise, a non-prefix cursor is created. Applications should arrange their key-value data to avoid the need for non-prefix cursors as they are significantly slower and more resource-intensive than prefix cursors. Note that simply using a filter doesn't create a prefix cursor \u2013 it must meet the two conditions listed above. Flags: HSE_FLAG_CURSOR_REVERSE - iterate in reverse lexicographic order This function is thread safe across disparate cursors.","title":"function hse_kvs_cursor_create"},{"location":"api/Files/hse_8h/#function-hse_kvs_cursor_update_view","text":"HSE_EXPORT hse_err_t hse_kvs_cursor_update_view ( struct hse_kvs_cursor * cursor , unsigned int flags ) Update a plain cursor or modify any cursor. Parameters : cursor Cursor handle from hse_kvs_cursor_create() . flags Flags for operation specialization. Return : The function's error status This operation updates the snapshot view of a non-transaction cursor. It is a no-op on transaction cursors. This function is thread safe across disparate cursors. Flags: 0 - reserved for future use","title":"function hse_kvs_cursor_update_view"},{"location":"api/Files/hse_8h/#function-hse_kvs_cursor_seek","text":"HSE_EXPORT hse_err_t hse_kvs_cursor_seek ( struct hse_kvs_cursor * cursor , unsigned int flags , const void * key , size_t key_len , const void ** found , size_t * found_len ) Move the cursor to point at the key-value pair at or closest to \"key\". Parameters : cursor Cursor handle from hse_kvs_cursor_create() . flags Flags for operation specialization. key Key to find. key_len Length of key. found If non-NULL, referent point to next key in sequence (optional). found_len If \"found\" is non-NULL, referent is length of \"found\" key. Return : Error status The next hse_kvs_cursor_read() will start at this point. Both \"found\" and \"found_len\" must be non-NULL for that functionality to work. This function is thread safe across disparate cursors. Flags: 0 - reserved for future use","title":"function hse_kvs_cursor_seek"},{"location":"api/Files/hse_8h/#function-hse_kvs_cursor_seek_range","text":"HSE_EXPORT hse_err_t hse_kvs_cursor_seek_range ( struct hse_kvs_cursor * cursor , unsigned int flags , const void * filt_min , size_t filt_min_len , const void * filt_max , size_t filt_max_len , const void ** found , size_t * found_len ) Move the cursor to the closest match to key, gated by the given filter. Parameters : cursor Cursor handle from hse_kvs_cursor_create() . flags Flags for operation specialization. filt_min Filter minimum. filt_min_len Length of filter minimum. filt_max Filter maximum. filt_max_len Length of filter maximum. found If non-NULL, referent points to next key in sequence (optional). found_len If non-NULL, referent is length of \"found\" key (optional). Return : Error status Keys read from this cursor will belong to the closed interval defined by the given filter: [ filt_min , filt_max ]. For KVSs storing segmented keys, performance will be enhanced when filt_min_len and filt_max_len are greater than or equal to the KVS key prefix length. Both found and found_len must be non-NULL for that functionality to work. This function is thread safe across disparate cursors. Note: this is only supported for forward cursors. Flags: 0 - reserved for future use","title":"function hse_kvs_cursor_seek_range"},{"location":"api/Files/hse_8h/#function-hse_kvs_cursor_read","text":"HSE_EXPORT hse_err_t hse_kvs_cursor_read ( struct hse_kvs_cursor * cursor , unsigned int flags , const void ** key , size_t * key_len , const void ** val , size_t * val_len , bool * eof ) Iteratively access the elements pointed to by the cursor. Parameters : cursor Cursor handle from hse_kvs_cursor_create() . flags Flags for operation specialization. key Next key in sequence. key_len Length of key. val Next value in sequence. val_len Length of value. eof If true, no more key-value pairs in sequence. Return : Error status Read a key-value pair from the cursor, advancing the cursor past its current location. If the cursor is at EOF, attempts to read from it will not change the state of the cursor. This function is thread safe across disparate cursors. Flags: 0 - reserved for future use","title":"function hse_kvs_cursor_read"},{"location":"api/Files/hse_8h/#function-hse_kvs_cursor_destroy","text":"HSE_EXPORT hse_err_t hse_kvs_cursor_destroy ( struct hse_kvs_cursor * cursor ) Destroy cursor. Parameters : cursor Cursor handle from hse_kvs_cursor_create() . Return : The function's error status This function is thread safe.","title":"function hse_kvs_cursor_destroy"},{"location":"api/Files/hse_8h/#function-hse_kvdb_sync","text":"HSE_EXPORT hse_err_t hse_kvdb_sync ( struct hse_kvdb * kvdb , unsigned int flags ) Sync data in all of the referenced KVDB's KVSs to stable media and return. Parameters : kvdb KVDB handle from hse_kvdb_open() . flags Flags for operation specialization. Return : Error status Flags: HSE_KVDB_SYNC_ASYNC - Return immediately after initiating operation instead of waiting for completion.","title":"function hse_kvdb_sync"},{"location":"api/Files/hse_8h/#function-hse_kvdb_storage_add","text":"HSE_EXPORT hse_err_t hse_kvdb_storage_add ( const char * kvdb_home , size_t paramc , const char * const * paramv ) Parameters : kvdb_home KVDB home directory, NULL means current working directory. paramc Number of configuration parameters in paramv . paramv List of KVDB create-time parameters in key=value format. Return : The function's error status Add a new media class storage to an existing offline KVDB This function is not thread safe.","title":"function hse_kvdb_storage_add"},{"location":"api/Files/hse_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"api/Files/hse_8h/#define-hse_export","text":"#define HSE_EXPORT","title":"define HSE_EXPORT"},{"location":"api/Files/hse_8h/#define-hse_export_experimental","text":"#define HSE_EXPORT_EXPERIMENTAL","title":"define HSE_EXPORT_EXPERIMENTAL"},{"location":"api/Files/hse_8h/#source-code","text":"/* SPDX-License-Identifier: Apache-2.0 */ /* * Copyright (C) 2015-2021 Micron Technology, Inc. All rights reserved. */ #ifndef HSE_KVDB_API_H #define HSE_KVDB_API_H /* MTF_MOCK_DECL(hse) */ #include <hse/flags.h> #include <hse/limits.h> #include <hse/types.h> #include <hse/version.h> #include <stdbool.h> #include <stddef.h> #include <stdint.h> #include <stdlib.h> #include <limits.h> #ifdef __cplusplus extern \"C\" { #endif #ifdef __has_attribute # if __has_attribute(visibility) # define HSE_EXPORT __attribute__((visibility(\"default\"))) # else # define HSE_EXPORT # endif #else # define HSE_EXPORT #endif #ifdef HSE_EXPORT_EXPERIMENTAL #undef HSE_EXPORT_EXPERIMENTAL #define HSE_EXPORT_EXPERIMENTAL HSE_EXPORT #else #define HSE_EXPORT_EXPERIMENTAL #endif HSE_EXPORT size_t hse_strerror ( hse_err_t err , char * buf , size_t buf_len ); HSE_EXPORT int hse_err_to_errno ( hse_err_t err ); HSE_EXPORT hse_err_t hse_init ( const char * config , size_t paramc , const char * const * paramv ); HSE_EXPORT void hse_fini ( void ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvdb_create ( const char * kvdb_home , size_t paramc , const char * const * paramv ); HSE_EXPORT hse_err_t hse_kvdb_drop ( const char * kvdb_home ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvdb_open ( const char * kvdb_home , size_t paramc , const char * const * paramv , struct hse_kvdb ** kvdb ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvdb_close ( struct hse_kvdb * kvdb ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvdb_kvs_names_get ( struct hse_kvdb * kvdb , size_t * namec , char *** namev ); HSE_EXPORT void hse_kvdb_kvs_names_free ( struct hse_kvdb * kvdb , char ** namev ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvdb_kvs_create ( struct hse_kvdb * kvdb , const char * kvs_name , size_t paramc , const char * const * paramv ); HSE_EXPORT hse_err_t hse_kvdb_kvs_drop ( struct hse_kvdb * kvdb , const char * kvs_name ); HSE_EXPORT hse_err_t hse_kvdb_kvs_open ( struct hse_kvdb * handle , const char * kvs_name , const size_t paramc , const char * const * paramv , struct hse_kvs ** kvs_out ); HSE_EXPORT hse_err_t hse_kvdb_kvs_close ( struct hse_kvs * kvs ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvs_put ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * key , size_t key_len , const void * val , size_t val_len ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvs_get ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * key , size_t key_len , bool * found , void * buf , size_t buf_len , size_t * val_len ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvs_delete ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * key , size_t key_len ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvs_prefix_delete ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * pfx , size_t pfx_len ); #ifdef HSE_EXPERIMENTAL HSE_EXPORT_EXPERIMENTAL hse_err_t hse_kvs_prefix_probe ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * pfx , size_t pfx_len , enum hse_kvs_pfx_probe_cnt * found , void * keybuf , size_t keybuf_sz , size_t * key_len , void * valbuf , size_t valbuf_sz , size_t * val_len ); #endif /* MTF_MOCK */ HSE_EXPORT struct hse_kvdb_txn * hse_kvdb_txn_alloc ( struct hse_kvdb * kvdb ); /* MTF_MOCK */ HSE_EXPORT void hse_kvdb_txn_free ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvdb_txn_begin ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvdb_txn_commit ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvdb_txn_abort ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ); /* MTF_MOCK */ HSE_EXPORT enum hse_kvdb_txn_state hse_kvdb_txn_state_get ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvs_cursor_create ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * filter , size_t filter_len , struct hse_kvs_cursor ** cursor ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvs_cursor_update_view ( struct hse_kvs_cursor * cursor , unsigned int flags ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvs_cursor_seek ( struct hse_kvs_cursor * cursor , unsigned int flags , const void * key , size_t key_len , const void ** found , size_t * found_len ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvs_cursor_seek_range ( struct hse_kvs_cursor * cursor , unsigned int flags , const void * filt_min , size_t filt_min_len , const void * filt_max , size_t filt_max_len , const void ** found , size_t * found_len ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvs_cursor_read ( struct hse_kvs_cursor * cursor , unsigned int flags , const void ** key , size_t * key_len , const void ** val , size_t * val_len , bool * eof ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvs_cursor_destroy ( struct hse_kvs_cursor * cursor ); /* MTF_MOCK */ HSE_EXPORT hse_err_t hse_kvdb_sync ( struct hse_kvdb * kvdb , unsigned int flags ); /* empty here to maintain the order in doxygen output, see include/hse/limits.h */ #ifdef HSE_EXPERIMENTAL HSE_EXPORT_EXPERIMENTAL hse_err_t hse_kvdb_compact ( struct hse_kvdb * kvdb , unsigned int flags ); HSE_EXPORT_EXPERIMENTAL hse_err_t hse_kvdb_compact_status_get ( struct hse_kvdb * kvdb , struct hse_kvdb_compact_status * status ); HSE_EXPORT_EXPERIMENTAL hse_err_t hse_kvdb_storage_info_get ( struct hse_kvdb * kvdb , struct hse_kvdb_storage_info * info ); #endif HSE_EXPORT hse_err_t hse_kvdb_storage_add ( const char * kvdb_home , size_t paramc , const char * const * paramv ); #undef HSE_EXPORT_EXPERIMENTAL #undef HSE_EXPORT #if HSE_MOCKING /* This is a complete hack because of the way mocks are generated. HSE_EXPORT * gets pulled as part of the function declaration when creating the function * pointers types for each mocked function. */ #define HSE_EXPORT #define HSE_EXPORT_EXPERIMENTAL #include \"hse_ut.h\" #undef HSE_EXPORT_EXPERIMENTAL #undef HSE_EXPORT #endif /* HSE_MOCKING */ #ifdef __cplusplus } #endif #endif Updated on 1 October 2021 at 17:03:30 CDT","title":"Source code"},{"location":"api/Files/limits_8h/","text":"hse/limits.h Defines Name HSE_KVS_COUNT_MAX Maximum number of KVS's contained within one KVDB. HSE_KVS_KEY_LEN_MAX Maximum key length. HSE_KVS_VALUE_LEN_MAX Max value length is 1MiB. HSE_KVS_PFX_LEN_MAX Max key prefix length. HSE_KVS_NAME_LEN_MAX Maximum length of a KVS name. Macros Documentation define HSE_KVS_COUNT_MAX #define HSE_KVS_COUNT_MAX (256) Maximum number of KVS's contained within one KVDB. define HSE_KVS_KEY_LEN_MAX #define HSE_KVS_KEY_LEN_MAX 1344 Maximum key length. Keys need not be NULL-terminated. define HSE_KVS_VALUE_LEN_MAX #define HSE_KVS_VALUE_LEN_MAX (1024 * 1024) Max value length is 1MiB. Values need not be NULL-terminated. define HSE_KVS_PFX_LEN_MAX #define HSE_KVS_PFX_LEN_MAX 32 Max key prefix length. define HSE_KVS_NAME_LEN_MAX #define HSE_KVS_NAME_LEN_MAX 32 Maximum length of a KVS name. KVS names are NULL-terminated strings. The string plus the NULL-terminator must fit into a HSE_KVS_NAME_LEN_MAX byte buffer. Source code /* SPDX-License-Identifier: Apache-2.0 */ /* * Copyright (C) 2015-2020 Micron Technology, Inc. All rights reserved. */ #ifndef HSE_LIMITS_H #define HSE_LIMITS_H #ifdef __cplusplus extern \"C\" { #endif #define HSE_KVS_COUNT_MAX (256) /* A common requirement clients have for key length is 1024. * Combined with a discriminant and (potentially) a chunk key, this pushes us to * 1030 bytes keys. Looking at the packing for the on-media format for data, we * can have at most 3 keys of such large size in a 4k page. Lopping off 64-bytes * for other data, and we can have 3 keys of 1344 bytes. */ #define HSE_KVS_KEY_LEN_MAX 1344 #define HSE_KVS_VALUE_LEN_MAX (1024 * 1024) #define HSE_KVS_PFX_LEN_MAX 32 #define HSE_KVS_NAME_LEN_MAX 32 #ifdef __cplusplus } #endif #endif Updated on 1 October 2021 at 17:03:30 CDT","title":"hse/limits.h"},{"location":"api/Files/limits_8h/#hselimitsh","text":"","title":"hse/limits.h"},{"location":"api/Files/limits_8h/#defines","text":"Name HSE_KVS_COUNT_MAX Maximum number of KVS's contained within one KVDB. HSE_KVS_KEY_LEN_MAX Maximum key length. HSE_KVS_VALUE_LEN_MAX Max value length is 1MiB. HSE_KVS_PFX_LEN_MAX Max key prefix length. HSE_KVS_NAME_LEN_MAX Maximum length of a KVS name.","title":"Defines"},{"location":"api/Files/limits_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"api/Files/limits_8h/#define-hse_kvs_count_max","text":"#define HSE_KVS_COUNT_MAX (256) Maximum number of KVS's contained within one KVDB.","title":"define HSE_KVS_COUNT_MAX"},{"location":"api/Files/limits_8h/#define-hse_kvs_key_len_max","text":"#define HSE_KVS_KEY_LEN_MAX 1344 Maximum key length. Keys need not be NULL-terminated.","title":"define HSE_KVS_KEY_LEN_MAX"},{"location":"api/Files/limits_8h/#define-hse_kvs_value_len_max","text":"#define HSE_KVS_VALUE_LEN_MAX (1024 * 1024) Max value length is 1MiB. Values need not be NULL-terminated.","title":"define HSE_KVS_VALUE_LEN_MAX"},{"location":"api/Files/limits_8h/#define-hse_kvs_pfx_len_max","text":"#define HSE_KVS_PFX_LEN_MAX 32 Max key prefix length.","title":"define HSE_KVS_PFX_LEN_MAX"},{"location":"api/Files/limits_8h/#define-hse_kvs_name_len_max","text":"#define HSE_KVS_NAME_LEN_MAX 32 Maximum length of a KVS name. KVS names are NULL-terminated strings. The string plus the NULL-terminator must fit into a HSE_KVS_NAME_LEN_MAX byte buffer.","title":"define HSE_KVS_NAME_LEN_MAX"},{"location":"api/Files/limits_8h/#source-code","text":"/* SPDX-License-Identifier: Apache-2.0 */ /* * Copyright (C) 2015-2020 Micron Technology, Inc. All rights reserved. */ #ifndef HSE_LIMITS_H #define HSE_LIMITS_H #ifdef __cplusplus extern \"C\" { #endif #define HSE_KVS_COUNT_MAX (256) /* A common requirement clients have for key length is 1024. * Combined with a discriminant and (potentially) a chunk key, this pushes us to * 1030 bytes keys. Looking at the packing for the on-media format for data, we * can have at most 3 keys of such large size in a 4k page. Lopping off 64-bytes * for other data, and we can have 3 keys of 1344 bytes. */ #define HSE_KVS_KEY_LEN_MAX 1344 #define HSE_KVS_VALUE_LEN_MAX (1024 * 1024) #define HSE_KVS_PFX_LEN_MAX 32 #define HSE_KVS_NAME_LEN_MAX 32 #ifdef __cplusplus } #endif #endif Updated on 1 October 2021 at 17:03:30 CDT","title":"Source code"},{"location":"api/Files/types_8h/","text":"hse/types.h Types Name enum hse_kvdb_txn_state { HSE_KVDB_TXN_INVALID = 0, HSE_KVDB_TXN_ACTIVE = 1, HSE_KVDB_TXN_COMMITTED = 2, HSE_KVDB_TXN_ABORTED = 3} Transaction state. typedef uint64_t hse_err_t Generic return type for the HSE library. Types Documentation enum hse_kvdb_txn_state Enumerator Value Description HSE_KVDB_TXN_INVALID 0 HSE_KVDB_TXN_ACTIVE 1 HSE_KVDB_TXN_COMMITTED 2 HSE_KVDB_TXN_ABORTED 3 Transaction state. typedef hse_err_t hse_err_t ; Generic return type for the HSE library. If this scalar quantity is 0 then the call succeeded. If it is non-zero then the 64-bit quantity can be used by the client in two ways: (1) call hse_err_to_errno() to get a mapping to a POSIX errno value, and (2) call hse_err_to_string() to get a textual reference about what error occurred and where. The following special errno error codes are worth mentioning here. errno Caller action EAGAIN The caller is expected to retry the operation. ECANCELED The caller is expected to retry the operation in a new transaction. See [write conflicts]. e.g., the code snippet below shows a typical non-transactional usage: int retries = 0 ; hse_err_t ret = 0 ; while ( retries < MAX_RETRIES ) { ret = hse_kvs_put ( kvs_handle , flags , txn , key , k_len , val , v_len ) if ( EAGAIN != hse_err_to_errno ( ret )) break ; retries ++ ; } Filename: .c Source code /* SPDX-License-Identifier: Apache-2.0 */ /* * Copyright (C) 2021 Micron Technology, Inc. All rights reserved. */ #ifndef HSE_TYPES_H #define HSE_TYPES_H #ifdef __cplusplus extern \"C\" { #endif #include <inttypes.h> typedef uint64_t hse_err_t ; struct hse_kvdb ; struct hse_kvs ; struct hse_kvs_cursor ; struct hse_kvdb_txn ; enum hse_kvdb_txn_state { HSE_KVDB_TXN_INVALID = 0 , HSE_KVDB_TXN_ACTIVE = 1 , HSE_KVDB_TXN_COMMITTED = 2 , HSE_KVDB_TXN_ABORTED = 3 , }; #ifdef HSE_EXPERIMENTAL struct hse_kvdb_compact_status { unsigned int kvcs_samp_lwm ; unsigned int kvcs_samp_hwm ; unsigned int kvcs_samp_curr ; unsigned int kvcs_active ; unsigned int kvcs_canceled ; }; struct hse_kvdb_storage_info { uint64_t total_bytes ; uint64_t available_bytes ; uint64_t allocated_bytes ; uint64_t used_bytes ; }; enum hse_kvs_pfx_probe_cnt { HSE_KVS_PFX_FOUND_ZERO = 0 , HSE_KVS_PFX_FOUND_ONE , HSE_KVS_PFX_FOUND_MUL , }; #endif #ifdef __cplusplus } #endif #endif Updated on 1 October 2021 at 17:03:30 CDT","title":"hse/types.h"},{"location":"api/Files/types_8h/#hsetypesh","text":"","title":"hse/types.h"},{"location":"api/Files/types_8h/#types","text":"Name enum hse_kvdb_txn_state { HSE_KVDB_TXN_INVALID = 0, HSE_KVDB_TXN_ACTIVE = 1, HSE_KVDB_TXN_COMMITTED = 2, HSE_KVDB_TXN_ABORTED = 3} Transaction state. typedef uint64_t hse_err_t Generic return type for the HSE library.","title":"Types"},{"location":"api/Files/types_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"api/Files/types_8h/#enum-hse_kvdb_txn_state","text":"Enumerator Value Description HSE_KVDB_TXN_INVALID 0 HSE_KVDB_TXN_ACTIVE 1 HSE_KVDB_TXN_COMMITTED 2 HSE_KVDB_TXN_ABORTED 3 Transaction state.","title":"enum hse_kvdb_txn_state"},{"location":"api/Files/types_8h/#typedef-hse_err_t","text":"hse_err_t ; Generic return type for the HSE library. If this scalar quantity is 0 then the call succeeded. If it is non-zero then the 64-bit quantity can be used by the client in two ways: (1) call hse_err_to_errno() to get a mapping to a POSIX errno value, and (2) call hse_err_to_string() to get a textual reference about what error occurred and where. The following special errno error codes are worth mentioning here. errno Caller action EAGAIN The caller is expected to retry the operation. ECANCELED The caller is expected to retry the operation in a new transaction. See [write conflicts]. e.g., the code snippet below shows a typical non-transactional usage: int retries = 0 ; hse_err_t ret = 0 ; while ( retries < MAX_RETRIES ) { ret = hse_kvs_put ( kvs_handle , flags , txn , key , k_len , val , v_len ) if ( EAGAIN != hse_err_to_errno ( ret )) break ; retries ++ ; } Filename: .c","title":"typedef hse_err_t"},{"location":"api/Files/types_8h/#source-code","text":"/* SPDX-License-Identifier: Apache-2.0 */ /* * Copyright (C) 2021 Micron Technology, Inc. All rights reserved. */ #ifndef HSE_TYPES_H #define HSE_TYPES_H #ifdef __cplusplus extern \"C\" { #endif #include <inttypes.h> typedef uint64_t hse_err_t ; struct hse_kvdb ; struct hse_kvs ; struct hse_kvs_cursor ; struct hse_kvdb_txn ; enum hse_kvdb_txn_state { HSE_KVDB_TXN_INVALID = 0 , HSE_KVDB_TXN_ACTIVE = 1 , HSE_KVDB_TXN_COMMITTED = 2 , HSE_KVDB_TXN_ABORTED = 3 , }; #ifdef HSE_EXPERIMENTAL struct hse_kvdb_compact_status { unsigned int kvcs_samp_lwm ; unsigned int kvcs_samp_hwm ; unsigned int kvcs_samp_curr ; unsigned int kvcs_active ; unsigned int kvcs_canceled ; }; struct hse_kvdb_storage_info { uint64_t total_bytes ; uint64_t available_bytes ; uint64_t allocated_bytes ; uint64_t used_bytes ; }; enum hse_kvs_pfx_probe_cnt { HSE_KVS_PFX_FOUND_ZERO = 0 , HSE_KVS_PFX_FOUND_ONE , HSE_KVS_PFX_FOUND_MUL , }; #endif #ifdef __cplusplus } #endif #endif Updated on 1 October 2021 at 17:03:30 CDT","title":"Source code"},{"location":"api/Files/version_8h/","text":"hse/version.h Defines Name HSE_VERSION_STRING A string representing the HSE KVDB libary version. HSE_VERSION_MAJOR HSE_VERSION_MINOR HSE_VERSION_PATCH Macros Documentation define HSE_VERSION_STRING #define HSE_VERSION_STRING \"r2.0.0-rc4-0-g391ccaab\" A string representing the HSE KVDB libary version. define HSE_VERSION_MAJOR #define HSE_VERSION_MAJOR 2 define HSE_VERSION_MINOR #define HSE_VERSION_MINOR 0 define HSE_VERSION_PATCH #define HSE_VERSION_PATCH 0 Source code /* SPDX-License-Identifier: Apache-2.0 */ /* * Copyright (C) 2015-2021 Micron Technology, Inc. All rights reserved. */ #ifndef HSE_VERSION_H #define HSE_VERSION_H #ifdef __cplusplus extern \"C\" { #endif #define HSE_VERSION_STRING \"r2.0.0-rc4-0-g391ccaab\" /* clang-format off */ /* * Below are three numeric constants that are suitable for use in macros for * conditionally compiling parts of your code based on the version of HSE you * are compiling against. */ #define HSE_VERSION_MAJOR 2 #define HSE_VERSION_MINOR 0 #define HSE_VERSION_PATCH 0 /* clang-format on */ #ifdef __cplusplus } #endif #endif Updated on 1 October 2021 at 17:03:30 CDT","title":"hse/version.h"},{"location":"api/Files/version_8h/#hseversionh","text":"","title":"hse/version.h"},{"location":"api/Files/version_8h/#defines","text":"Name HSE_VERSION_STRING A string representing the HSE KVDB libary version. HSE_VERSION_MAJOR HSE_VERSION_MINOR HSE_VERSION_PATCH","title":"Defines"},{"location":"api/Files/version_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"api/Files/version_8h/#define-hse_version_string","text":"#define HSE_VERSION_STRING \"r2.0.0-rc4-0-g391ccaab\" A string representing the HSE KVDB libary version.","title":"define HSE_VERSION_STRING"},{"location":"api/Files/version_8h/#define-hse_version_major","text":"#define HSE_VERSION_MAJOR 2","title":"define HSE_VERSION_MAJOR"},{"location":"api/Files/version_8h/#define-hse_version_minor","text":"#define HSE_VERSION_MINOR 0","title":"define HSE_VERSION_MINOR"},{"location":"api/Files/version_8h/#define-hse_version_patch","text":"#define HSE_VERSION_PATCH 0","title":"define HSE_VERSION_PATCH"},{"location":"api/Files/version_8h/#source-code","text":"/* SPDX-License-Identifier: Apache-2.0 */ /* * Copyright (C) 2015-2021 Micron Technology, Inc. All rights reserved. */ #ifndef HSE_VERSION_H #define HSE_VERSION_H #ifdef __cplusplus extern \"C\" { #endif #define HSE_VERSION_STRING \"r2.0.0-rc4-0-g391ccaab\" /* clang-format off */ /* * Below are three numeric constants that are suitable for use in macros for * conditionally compiling parts of your code based on the version of HSE you * are compiling against. */ #define HSE_VERSION_MAJOR 2 #define HSE_VERSION_MINOR 0 #define HSE_VERSION_PATCH 0 /* clang-format on */ #ifdef __cplusplus } #endif #endif Updated on 1 October 2021 at 17:03:30 CDT","title":"Source code"},{"location":"api/Modules/","text":"Modules group Create, Read, Update and Delete (CRUD) Functions group Cursor Functions group Data State Management Functions group HSE Return Codes group Initialization Routines group Primary Lifecycle Functions group Limits group Transaction Functions group Type Declarations, Shared Structures and Macros Updated on 1 October 2021 at 17:03:30 CDT","title":"Modules"},{"location":"api/Modules/#modules","text":"group Create, Read, Update and Delete (CRUD) Functions group Cursor Functions group Data State Management Functions group HSE Return Codes group Initialization Routines group Primary Lifecycle Functions group Limits group Transaction Functions group Type Declarations, Shared Structures and Macros Updated on 1 October 2021 at 17:03:30 CDT","title":"Modules"},{"location":"api/Modules/group__CRUD/","text":"Create, Read, Update and Delete (CRUD) Functions Functions Name HSE_EXPORT hse_err_t hse_kvs_put (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * key, size_t key_len, const void * val, size_t val_len) Put a key-value pair into KVS. HSE_EXPORT hse_err_t hse_kvs_get (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * key, size_t key_len, bool * found, void * buf, size_t buf_len, size_t * val_len) Retrieve the value for a given key from KVS. HSE_EXPORT hse_err_t hse_kvs_delete (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * key, size_t key_len) Delete the key and its associated value from KVS. HSE_EXPORT hse_err_t hse_kvs_prefix_delete (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * pfx, size_t pfx_len) Delete all key-value pairs matching the key prefix from a KVS storing segmented keys. Functions Documentation function hse_kvs_put HSE_EXPORT hse_err_t hse_kvs_put ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * key , size_t key_len , const void * val , size_t val_len ) Put a key-value pair into KVS. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . flags Flags for operation specialization. txn Transaction context. key Key to put into kvs. key_len Length of key. val Value associated with key. val_len Length of value. Return : Error status If the key already exists in the KVS then the value is effectively overwritten. The key length must be in the range [1, HSE_KVS_KEY_LEN_MAX] while the value length must be in the range [0, HSE_KVS_VALUE_LEN_MAX]. See the section on transactions for information on how puts within transactions are handled. This function is thread safe. The HSE KVDB attempts to maintain reasonable QoS and for high-throughput clients this results in very short sleep's being inserted into the put path. For some kinds of data (e.g., control metadata) the client may wish to not experience that delay. For relatively low data rate uses, the caller can set the HSE_FLAG_PUT_PRIORITY flag for an hse_kvs_put() . Care should be taken when doing so to ensure that the system does not become overrun. As a rough approximation, doing 1M priority puts per second marked as PRIORITY is likely an issue. On the other hand, doing 1K small puts per second marked as PRIORITY is almost certainly fine. If compression is enabled for the given kvs, then hse_kvs_put() will attempt to compress the value unless the HSE_FLAG_PUT_VCOMP_OFF flag is given. Otherwise, the HSE_FLAG_PUT_VCOMP_OFF flag is ignored. Flags: HSE_FLAG_PUT_PRIORITY - Operation will not be throttled HSE_FLAG_PUT_VCOMP_OFF - Value will not be compressed function hse_kvs_get HSE_EXPORT hse_err_t hse_kvs_get ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * key , size_t key_len , bool * found , void * buf , size_t buf_len , size_t * val_len ) Retrieve the value for a given key from KVS. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . flags Flags for operation specialization. txn Transaction context. key Key to get from kvs. key_len Length of key. found Whether or not key was found. buf Buffer into which the value associated with key will be copied. buf_len Length of buffer. val_len Actual length of value if key was found. Return : Error status If the key exists in the KVS then the referent of \"found\" is set to true. If the caller's value buffer is large enough then the data will be returned. Regardless, the actual length of the value is placed in \"val_len\". See the section on transactions for information on how gets within transactions are handled. This function is thread safe. Flags: 0 - reserved for future use function hse_kvs_delete HSE_EXPORT hse_err_t hse_kvs_delete ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * key , size_t key_len ) Delete the key and its associated value from KVS. Parameters : kvs KVS handle from hse_kvdb_kvs_open() flags Flags for operation specialization txn Transaction context (optional) key Key to be deleted from kvs key_len Length of key Return : Error status It is not an error if the key does not exist within the KVS. See the section on transactions for information on how deletes within transactions are handled. This function is thread safe. Flags: 0 - reserved for future use function hse_kvs_prefix_delete HSE_EXPORT hse_err_t hse_kvs_prefix_delete ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * pfx , size_t pfx_len ) Delete all key-value pairs matching the key prefix from a KVS storing segmented keys. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . flags Flags for operation specialization. txn Transaction context (optional). pfx Prefix of keys to delete. pfx_len Prefix length. Return : Error status This interface is used to delete an entire range of segmented keys. To do this the caller passes a filter with a length equal to the KVS's key prefix length. It is not an error if no keys exist matching the filter. If there is a filtered iteration in progress, then that iteration can fail if hse_kvs_prefix_delete() is called with a filter matching the iteration. This function is thread safe. If hse_kvs_prefix_delete() is called from a transaction context, it affects no key-value mutations that are part of the same transaction. Stated differently, for KVS commands issued within a transaction, all calls to hse_kvs_prefix_delete() are treated as though they were issued serially at the beginning of the transaction regardless of the actual order these commands appeared in. Flags: 0 - reserved for future use Updated on 1 October 2021 at 17:03:30 CDT","title":"Create, Read, Update and Delete (CRUD) Functions"},{"location":"api/Modules/group__CRUD/#create-read-update-and-delete-crud-functions","text":"","title":"Create, Read, Update and Delete (CRUD) Functions"},{"location":"api/Modules/group__CRUD/#functions","text":"Name HSE_EXPORT hse_err_t hse_kvs_put (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * key, size_t key_len, const void * val, size_t val_len) Put a key-value pair into KVS. HSE_EXPORT hse_err_t hse_kvs_get (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * key, size_t key_len, bool * found, void * buf, size_t buf_len, size_t * val_len) Retrieve the value for a given key from KVS. HSE_EXPORT hse_err_t hse_kvs_delete (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * key, size_t key_len) Delete the key and its associated value from KVS. HSE_EXPORT hse_err_t hse_kvs_prefix_delete (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * pfx, size_t pfx_len) Delete all key-value pairs matching the key prefix from a KVS storing segmented keys.","title":"Functions"},{"location":"api/Modules/group__CRUD/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/Modules/group__CRUD/#function-hse_kvs_put","text":"HSE_EXPORT hse_err_t hse_kvs_put ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * key , size_t key_len , const void * val , size_t val_len ) Put a key-value pair into KVS. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . flags Flags for operation specialization. txn Transaction context. key Key to put into kvs. key_len Length of key. val Value associated with key. val_len Length of value. Return : Error status If the key already exists in the KVS then the value is effectively overwritten. The key length must be in the range [1, HSE_KVS_KEY_LEN_MAX] while the value length must be in the range [0, HSE_KVS_VALUE_LEN_MAX]. See the section on transactions for information on how puts within transactions are handled. This function is thread safe. The HSE KVDB attempts to maintain reasonable QoS and for high-throughput clients this results in very short sleep's being inserted into the put path. For some kinds of data (e.g., control metadata) the client may wish to not experience that delay. For relatively low data rate uses, the caller can set the HSE_FLAG_PUT_PRIORITY flag for an hse_kvs_put() . Care should be taken when doing so to ensure that the system does not become overrun. As a rough approximation, doing 1M priority puts per second marked as PRIORITY is likely an issue. On the other hand, doing 1K small puts per second marked as PRIORITY is almost certainly fine. If compression is enabled for the given kvs, then hse_kvs_put() will attempt to compress the value unless the HSE_FLAG_PUT_VCOMP_OFF flag is given. Otherwise, the HSE_FLAG_PUT_VCOMP_OFF flag is ignored. Flags: HSE_FLAG_PUT_PRIORITY - Operation will not be throttled HSE_FLAG_PUT_VCOMP_OFF - Value will not be compressed","title":"function hse_kvs_put"},{"location":"api/Modules/group__CRUD/#function-hse_kvs_get","text":"HSE_EXPORT hse_err_t hse_kvs_get ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * key , size_t key_len , bool * found , void * buf , size_t buf_len , size_t * val_len ) Retrieve the value for a given key from KVS. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . flags Flags for operation specialization. txn Transaction context. key Key to get from kvs. key_len Length of key. found Whether or not key was found. buf Buffer into which the value associated with key will be copied. buf_len Length of buffer. val_len Actual length of value if key was found. Return : Error status If the key exists in the KVS then the referent of \"found\" is set to true. If the caller's value buffer is large enough then the data will be returned. Regardless, the actual length of the value is placed in \"val_len\". See the section on transactions for information on how gets within transactions are handled. This function is thread safe. Flags: 0 - reserved for future use","title":"function hse_kvs_get"},{"location":"api/Modules/group__CRUD/#function-hse_kvs_delete","text":"HSE_EXPORT hse_err_t hse_kvs_delete ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * key , size_t key_len ) Delete the key and its associated value from KVS. Parameters : kvs KVS handle from hse_kvdb_kvs_open() flags Flags for operation specialization txn Transaction context (optional) key Key to be deleted from kvs key_len Length of key Return : Error status It is not an error if the key does not exist within the KVS. See the section on transactions for information on how deletes within transactions are handled. This function is thread safe. Flags: 0 - reserved for future use","title":"function hse_kvs_delete"},{"location":"api/Modules/group__CRUD/#function-hse_kvs_prefix_delete","text":"HSE_EXPORT hse_err_t hse_kvs_prefix_delete ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * pfx , size_t pfx_len ) Delete all key-value pairs matching the key prefix from a KVS storing segmented keys. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . flags Flags for operation specialization. txn Transaction context (optional). pfx Prefix of keys to delete. pfx_len Prefix length. Return : Error status This interface is used to delete an entire range of segmented keys. To do this the caller passes a filter with a length equal to the KVS's key prefix length. It is not an error if no keys exist matching the filter. If there is a filtered iteration in progress, then that iteration can fail if hse_kvs_prefix_delete() is called with a filter matching the iteration. This function is thread safe. If hse_kvs_prefix_delete() is called from a transaction context, it affects no key-value mutations that are part of the same transaction. Stated differently, for KVS commands issued within a transaction, all calls to hse_kvs_prefix_delete() are treated as though they were issued serially at the beginning of the transaction regardless of the actual order these commands appeared in. Flags: 0 - reserved for future use Updated on 1 October 2021 at 17:03:30 CDT","title":"function hse_kvs_prefix_delete"},{"location":"api/Modules/group__CURSOR/","text":"Cursor Functions More... Functions Name HSE_EXPORT hse_err_t hse_kvs_cursor_create (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * filter, size_t filter_len, struct hse_kvs_cursor ** cursor) Creates a cursor used to iterate over key-value pairs in a KVS. HSE_EXPORT hse_err_t hse_kvs_cursor_update_view (struct hse_kvs_cursor * cursor, unsigned int flags) Update a plain cursor or modify any cursor. HSE_EXPORT hse_err_t hse_kvs_cursor_seek (struct hse_kvs_cursor * cursor, unsigned int flags, const void * key, size_t key_len, const void ** found, size_t * found_len) Move the cursor to point at the key-value pair at or closest to \"key\". HSE_EXPORT hse_err_t hse_kvs_cursor_seek_range (struct hse_kvs_cursor * cursor, unsigned int flags, const void * filt_min, size_t filt_min_len, const void * filt_max, size_t filt_max_len, const void ** found, size_t * found_len) Move the cursor to the closest match to key, gated by the given filter. HSE_EXPORT hse_err_t hse_kvs_cursor_read (struct hse_kvs_cursor * cursor, unsigned int flags, const void key, size_t * key_len, const void val, size_t * val_len, bool * eof) Iteratively access the elements pointed to by the cursor. HSE_EXPORT hse_err_t hse_kvs_cursor_destroy (struct hse_kvs_cursor * cursor) Destroy cursor. Detailed Description See the concept and best practices sections on the HSE project site at https://hse-project.github.io/2.x/dev/concepts/ Functions Documentation function hse_kvs_cursor_create HSE_EXPORT hse_err_t hse_kvs_cursor_create ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * filter , size_t filter_len , struct hse_kvs_cursor ** cursor ) Creates a cursor used to iterate over key-value pairs in a KVS. Parameters : kvs KVS to iterate over, handle from hse_kvdb_kvs_open() . flags Flags for operation specialization. txn Transaction context (optional). filter Iteration limited to keys matching this prefix filter (optional). filter_len Length of filter (optional). cursor Cursor handle. Return : Error status Non-transaction cursors: If txn is NULL, a non-transaction cursor is created. Non-transaction cursors have an ephemeral snapshot view of the KVS at the time it the cursor is created. The snapshot view is maintained for the life of the cursor. Writes to the KVS (put, deletes, etc.) made after the cursor is created will not be visible to the cursor unless hse_kvs_cursor_update_view() is used to obtain a more recent snapshot view. Non transaction cursors can be used on transaction and non-transaction KVSs. Transaction cursors: If txn is not NULL, it must be a valid transaction handle or undefined behavior will result. If it is a valid handle to a transaction in the ACTIVE state, a transaction cursor is created. A transaction cursor's view includes the transaction's writes overlaid on the transaction's ephemeral snapshot view of the KVS. If the transaction is committed or aborted before the cursor is destroyed, the cursor's view reverts to same snaphsot view the transaction had when first became active. The cursor will no longer be able to see the transaction's writes. Calling hse_kvs_cursor_update_view() on a transaction cursor is a no-op and has no effect on the cursor's view. Transaction cursors can only be used on transaction KVSs. Prefix vs non-prefix cursors: Parameters filter and filter_len can be used to iterate over the subset of keys in the KVS whose first filter_len bytes match the filter_len bytes pointed to by filter . A prefix cursor is created when: KVS was created with pfx_len > 0 (i.e., it is a prefix KVS), and filter != NULL and filter_len >= @ pfx_len. Otherwise, a non-prefix cursor is created. Applications should arrange their key-value data to avoid the need for non-prefix cursors as they are significantly slower and more resource-intensive than prefix cursors. Note that simply using a filter doesn't create a prefix cursor \u2013 it must meet the two conditions listed above. Flags: HSE_FLAG_CURSOR_REVERSE - iterate in reverse lexicographic order This function is thread safe across disparate cursors. function hse_kvs_cursor_update_view HSE_EXPORT hse_err_t hse_kvs_cursor_update_view ( struct hse_kvs_cursor * cursor , unsigned int flags ) Update a plain cursor or modify any cursor. Parameters : cursor Cursor handle from hse_kvs_cursor_create() . flags Flags for operation specialization. Return : The function's error status This operation updates the snapshot view of a non-transaction cursor. It is a no-op on transaction cursors. This function is thread safe across disparate cursors. Flags: 0 - reserved for future use function hse_kvs_cursor_seek HSE_EXPORT hse_err_t hse_kvs_cursor_seek ( struct hse_kvs_cursor * cursor , unsigned int flags , const void * key , size_t key_len , const void ** found , size_t * found_len ) Move the cursor to point at the key-value pair at or closest to \"key\". Parameters : cursor Cursor handle from hse_kvs_cursor_create() . flags Flags for operation specialization. key Key to find. key_len Length of key. found If non-NULL, referent point to next key in sequence (optional). found_len If \"found\" is non-NULL, referent is length of \"found\" key. Return : Error status The next hse_kvs_cursor_read() will start at this point. Both \"found\" and \"found_len\" must be non-NULL for that functionality to work. This function is thread safe across disparate cursors. Flags: 0 - reserved for future use function hse_kvs_cursor_seek_range HSE_EXPORT hse_err_t hse_kvs_cursor_seek_range ( struct hse_kvs_cursor * cursor , unsigned int flags , const void * filt_min , size_t filt_min_len , const void * filt_max , size_t filt_max_len , const void ** found , size_t * found_len ) Move the cursor to the closest match to key, gated by the given filter. Parameters : cursor Cursor handle from hse_kvs_cursor_create() . flags Flags for operation specialization. filt_min Filter minimum. filt_min_len Length of filter minimum. filt_max Filter maximum. filt_max_len Length of filter maximum. found If non-NULL, referent points to next key in sequence (optional). found_len If non-NULL, referent is length of \"found\" key (optional). Return : Error status Keys read from this cursor will belong to the closed interval defined by the given filter: [ filt_min , filt_max ]. For KVSs storing segmented keys, performance will be enhanced when filt_min_len and filt_max_len are greater than or equal to the KVS key prefix length. Both found and found_len must be non-NULL for that functionality to work. This function is thread safe across disparate cursors. Note: this is only supported for forward cursors. Flags: 0 - reserved for future use function hse_kvs_cursor_read HSE_EXPORT hse_err_t hse_kvs_cursor_read ( struct hse_kvs_cursor * cursor , unsigned int flags , const void ** key , size_t * key_len , const void ** val , size_t * val_len , bool * eof ) Iteratively access the elements pointed to by the cursor. Parameters : cursor Cursor handle from hse_kvs_cursor_create() . flags Flags for operation specialization. key Next key in sequence. key_len Length of key. val Next value in sequence. val_len Length of value. eof If true, no more key-value pairs in sequence. Return : Error status Read a key-value pair from the cursor, advancing the cursor past its current location. If the cursor is at EOF, attempts to read from it will not change the state of the cursor. This function is thread safe across disparate cursors. Flags: 0 - reserved for future use function hse_kvs_cursor_destroy HSE_EXPORT hse_err_t hse_kvs_cursor_destroy ( struct hse_kvs_cursor * cursor ) Destroy cursor. Parameters : cursor Cursor handle from hse_kvs_cursor_create() . Return : The function's error status This function is thread safe. Updated on 1 October 2021 at 17:03:30 CDT","title":"Cursor Functions"},{"location":"api/Modules/group__CURSOR/#cursor-functions","text":"More...","title":"Cursor Functions"},{"location":"api/Modules/group__CURSOR/#functions","text":"Name HSE_EXPORT hse_err_t hse_kvs_cursor_create (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * filter, size_t filter_len, struct hse_kvs_cursor ** cursor) Creates a cursor used to iterate over key-value pairs in a KVS. HSE_EXPORT hse_err_t hse_kvs_cursor_update_view (struct hse_kvs_cursor * cursor, unsigned int flags) Update a plain cursor or modify any cursor. HSE_EXPORT hse_err_t hse_kvs_cursor_seek (struct hse_kvs_cursor * cursor, unsigned int flags, const void * key, size_t key_len, const void ** found, size_t * found_len) Move the cursor to point at the key-value pair at or closest to \"key\". HSE_EXPORT hse_err_t hse_kvs_cursor_seek_range (struct hse_kvs_cursor * cursor, unsigned int flags, const void * filt_min, size_t filt_min_len, const void * filt_max, size_t filt_max_len, const void ** found, size_t * found_len) Move the cursor to the closest match to key, gated by the given filter. HSE_EXPORT hse_err_t hse_kvs_cursor_read (struct hse_kvs_cursor * cursor, unsigned int flags, const void key, size_t * key_len, const void val, size_t * val_len, bool * eof) Iteratively access the elements pointed to by the cursor. HSE_EXPORT hse_err_t hse_kvs_cursor_destroy (struct hse_kvs_cursor * cursor) Destroy cursor.","title":"Functions"},{"location":"api/Modules/group__CURSOR/#detailed-description","text":"See the concept and best practices sections on the HSE project site at https://hse-project.github.io/2.x/dev/concepts/","title":"Detailed Description"},{"location":"api/Modules/group__CURSOR/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/Modules/group__CURSOR/#function-hse_kvs_cursor_create","text":"HSE_EXPORT hse_err_t hse_kvs_cursor_create ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * filter , size_t filter_len , struct hse_kvs_cursor ** cursor ) Creates a cursor used to iterate over key-value pairs in a KVS. Parameters : kvs KVS to iterate over, handle from hse_kvdb_kvs_open() . flags Flags for operation specialization. txn Transaction context (optional). filter Iteration limited to keys matching this prefix filter (optional). filter_len Length of filter (optional). cursor Cursor handle. Return : Error status Non-transaction cursors: If txn is NULL, a non-transaction cursor is created. Non-transaction cursors have an ephemeral snapshot view of the KVS at the time it the cursor is created. The snapshot view is maintained for the life of the cursor. Writes to the KVS (put, deletes, etc.) made after the cursor is created will not be visible to the cursor unless hse_kvs_cursor_update_view() is used to obtain a more recent snapshot view. Non transaction cursors can be used on transaction and non-transaction KVSs. Transaction cursors: If txn is not NULL, it must be a valid transaction handle or undefined behavior will result. If it is a valid handle to a transaction in the ACTIVE state, a transaction cursor is created. A transaction cursor's view includes the transaction's writes overlaid on the transaction's ephemeral snapshot view of the KVS. If the transaction is committed or aborted before the cursor is destroyed, the cursor's view reverts to same snaphsot view the transaction had when first became active. The cursor will no longer be able to see the transaction's writes. Calling hse_kvs_cursor_update_view() on a transaction cursor is a no-op and has no effect on the cursor's view. Transaction cursors can only be used on transaction KVSs. Prefix vs non-prefix cursors: Parameters filter and filter_len can be used to iterate over the subset of keys in the KVS whose first filter_len bytes match the filter_len bytes pointed to by filter . A prefix cursor is created when: KVS was created with pfx_len > 0 (i.e., it is a prefix KVS), and filter != NULL and filter_len >= @ pfx_len. Otherwise, a non-prefix cursor is created. Applications should arrange their key-value data to avoid the need for non-prefix cursors as they are significantly slower and more resource-intensive than prefix cursors. Note that simply using a filter doesn't create a prefix cursor \u2013 it must meet the two conditions listed above. Flags: HSE_FLAG_CURSOR_REVERSE - iterate in reverse lexicographic order This function is thread safe across disparate cursors.","title":"function hse_kvs_cursor_create"},{"location":"api/Modules/group__CURSOR/#function-hse_kvs_cursor_update_view","text":"HSE_EXPORT hse_err_t hse_kvs_cursor_update_view ( struct hse_kvs_cursor * cursor , unsigned int flags ) Update a plain cursor or modify any cursor. Parameters : cursor Cursor handle from hse_kvs_cursor_create() . flags Flags for operation specialization. Return : The function's error status This operation updates the snapshot view of a non-transaction cursor. It is a no-op on transaction cursors. This function is thread safe across disparate cursors. Flags: 0 - reserved for future use","title":"function hse_kvs_cursor_update_view"},{"location":"api/Modules/group__CURSOR/#function-hse_kvs_cursor_seek","text":"HSE_EXPORT hse_err_t hse_kvs_cursor_seek ( struct hse_kvs_cursor * cursor , unsigned int flags , const void * key , size_t key_len , const void ** found , size_t * found_len ) Move the cursor to point at the key-value pair at or closest to \"key\". Parameters : cursor Cursor handle from hse_kvs_cursor_create() . flags Flags for operation specialization. key Key to find. key_len Length of key. found If non-NULL, referent point to next key in sequence (optional). found_len If \"found\" is non-NULL, referent is length of \"found\" key. Return : Error status The next hse_kvs_cursor_read() will start at this point. Both \"found\" and \"found_len\" must be non-NULL for that functionality to work. This function is thread safe across disparate cursors. Flags: 0 - reserved for future use","title":"function hse_kvs_cursor_seek"},{"location":"api/Modules/group__CURSOR/#function-hse_kvs_cursor_seek_range","text":"HSE_EXPORT hse_err_t hse_kvs_cursor_seek_range ( struct hse_kvs_cursor * cursor , unsigned int flags , const void * filt_min , size_t filt_min_len , const void * filt_max , size_t filt_max_len , const void ** found , size_t * found_len ) Move the cursor to the closest match to key, gated by the given filter. Parameters : cursor Cursor handle from hse_kvs_cursor_create() . flags Flags for operation specialization. filt_min Filter minimum. filt_min_len Length of filter minimum. filt_max Filter maximum. filt_max_len Length of filter maximum. found If non-NULL, referent points to next key in sequence (optional). found_len If non-NULL, referent is length of \"found\" key (optional). Return : Error status Keys read from this cursor will belong to the closed interval defined by the given filter: [ filt_min , filt_max ]. For KVSs storing segmented keys, performance will be enhanced when filt_min_len and filt_max_len are greater than or equal to the KVS key prefix length. Both found and found_len must be non-NULL for that functionality to work. This function is thread safe across disparate cursors. Note: this is only supported for forward cursors. Flags: 0 - reserved for future use","title":"function hse_kvs_cursor_seek_range"},{"location":"api/Modules/group__CURSOR/#function-hse_kvs_cursor_read","text":"HSE_EXPORT hse_err_t hse_kvs_cursor_read ( struct hse_kvs_cursor * cursor , unsigned int flags , const void ** key , size_t * key_len , const void ** val , size_t * val_len , bool * eof ) Iteratively access the elements pointed to by the cursor. Parameters : cursor Cursor handle from hse_kvs_cursor_create() . flags Flags for operation specialization. key Next key in sequence. key_len Length of key. val Next value in sequence. val_len Length of value. eof If true, no more key-value pairs in sequence. Return : Error status Read a key-value pair from the cursor, advancing the cursor past its current location. If the cursor is at EOF, attempts to read from it will not change the state of the cursor. This function is thread safe across disparate cursors. Flags: 0 - reserved for future use","title":"function hse_kvs_cursor_read"},{"location":"api/Modules/group__CURSOR/#function-hse_kvs_cursor_destroy","text":"HSE_EXPORT hse_err_t hse_kvs_cursor_destroy ( struct hse_kvs_cursor * cursor ) Destroy cursor. Parameters : cursor Cursor handle from hse_kvs_cursor_create() . Return : The function's error status This function is thread safe. Updated on 1 October 2021 at 17:03:30 CDT","title":"function hse_kvs_cursor_destroy"},{"location":"api/Modules/group__DSTATE/","text":"Data State Management Functions Functions Name HSE_EXPORT hse_err_t hse_kvdb_sync (struct hse_kvdb * kvdb, unsigned int flags) Sync data in all of the referenced KVDB's KVSs to stable media and return. Functions Documentation function hse_kvdb_sync HSE_EXPORT hse_err_t hse_kvdb_sync ( struct hse_kvdb * kvdb , unsigned int flags ) Sync data in all of the referenced KVDB's KVSs to stable media and return. Parameters : kvdb KVDB handle from hse_kvdb_open() . flags Flags for operation specialization. Return : Error status Flags: HSE_KVDB_SYNC_ASYNC - Return immediately after initiating operation instead of waiting for completion. Updated on 1 October 2021 at 17:03:30 CDT","title":"Data State Management Functions"},{"location":"api/Modules/group__DSTATE/#data-state-management-functions","text":"","title":"Data State Management Functions"},{"location":"api/Modules/group__DSTATE/#functions","text":"Name HSE_EXPORT hse_err_t hse_kvdb_sync (struct hse_kvdb * kvdb, unsigned int flags) Sync data in all of the referenced KVDB's KVSs to stable media and return.","title":"Functions"},{"location":"api/Modules/group__DSTATE/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/Modules/group__DSTATE/#function-hse_kvdb_sync","text":"HSE_EXPORT hse_err_t hse_kvdb_sync ( struct hse_kvdb * kvdb , unsigned int flags ) Sync data in all of the referenced KVDB's KVSs to stable media and return. Parameters : kvdb KVDB handle from hse_kvdb_open() . flags Flags for operation specialization. Return : Error status Flags: HSE_KVDB_SYNC_ASYNC - Return immediately after initiating operation instead of waiting for completion. Updated on 1 October 2021 at 17:03:30 CDT","title":"function hse_kvdb_sync"},{"location":"api/Modules/group__ERROR__HANDLING/","text":"HSE Return Codes More... Types Name typedef uint64_t hse_err_t Generic return type for the HSE library. Functions Name HSE_EXPORT size_t hse_strerror ( hse_err_t err, char * buf, size_t buf_len) Return an hse_err_t value's string representation. HSE_EXPORT int hse_err_to_errno ( hse_err_t err) Return an hse_err_t value's errno representation. Detailed Description Describes the HSE API return code type and associated utilities. Types Documentation typedef hse_err_t hse_err_t ; Generic return type for the HSE library. If this scalar quantity is 0 then the call succeeded. If it is non-zero then the 64-bit quantity can be used by the client in two ways: (1) call hse_err_to_errno() to get a mapping to a POSIX errno value, and (2) call hse_err_to_string() to get a textual reference about what error occurred and where. The following special errno error codes are worth mentioning here. errno Caller action EAGAIN The caller is expected to retry the operation. ECANCELED The caller is expected to retry the operation in a new transaction. See [write conflicts]. e.g., the code snippet below shows a typical non-transactional usage: int retries = 0 ; hse_err_t ret = 0 ; while ( retries < MAX_RETRIES ) { ret = hse_kvs_put ( kvs_handle , flags , txn , key , k_len , val , v_len ) if ( EAGAIN != hse_err_to_errno ( ret )) break ; retries ++ ; } Filename: .c Functions Documentation function hse_strerror HSE_EXPORT size_t hse_strerror ( hse_err_t err , char * buf , size_t buf_len ) Return an hse_err_t value's string representation. Parameters : err Error value returned from an HSE API function. buf Buffer to hold the formatted string. buf_len Length of buffer. Return : The number of characters (excluding the terminating null byte) which would have been written to the final string if enough space had been available. The hse_err_t scalar value err is decoded into a NULL-terminated string representation giving more information about the error and where it occurred. The string will be truncated if buf_len is too small (a buf_len value of 128 is sufficient to avoid truncation of most error strings). This function is thread safe. function hse_err_to_errno HSE_EXPORT int hse_err_to_errno ( hse_err_t err ) Return an hse_err_t value's errno representation. Parameters : err Error value returned from an HSE API function. Return : The error's errno equivalent. The hse_err_t scalar value err is translated into its errno equivalent. This function is thread safe. Updated on 1 October 2021 at 17:03:30 CDT","title":"HSE Return Codes"},{"location":"api/Modules/group__ERROR__HANDLING/#hse-return-codes","text":"More...","title":"HSE Return Codes"},{"location":"api/Modules/group__ERROR__HANDLING/#types","text":"Name typedef uint64_t hse_err_t Generic return type for the HSE library.","title":"Types"},{"location":"api/Modules/group__ERROR__HANDLING/#functions","text":"Name HSE_EXPORT size_t hse_strerror ( hse_err_t err, char * buf, size_t buf_len) Return an hse_err_t value's string representation. HSE_EXPORT int hse_err_to_errno ( hse_err_t err) Return an hse_err_t value's errno representation.","title":"Functions"},{"location":"api/Modules/group__ERROR__HANDLING/#detailed-description","text":"Describes the HSE API return code type and associated utilities.","title":"Detailed Description"},{"location":"api/Modules/group__ERROR__HANDLING/#types-documentation","text":"","title":"Types Documentation"},{"location":"api/Modules/group__ERROR__HANDLING/#typedef-hse_err_t","text":"hse_err_t ; Generic return type for the HSE library. If this scalar quantity is 0 then the call succeeded. If it is non-zero then the 64-bit quantity can be used by the client in two ways: (1) call hse_err_to_errno() to get a mapping to a POSIX errno value, and (2) call hse_err_to_string() to get a textual reference about what error occurred and where. The following special errno error codes are worth mentioning here. errno Caller action EAGAIN The caller is expected to retry the operation. ECANCELED The caller is expected to retry the operation in a new transaction. See [write conflicts]. e.g., the code snippet below shows a typical non-transactional usage: int retries = 0 ; hse_err_t ret = 0 ; while ( retries < MAX_RETRIES ) { ret = hse_kvs_put ( kvs_handle , flags , txn , key , k_len , val , v_len ) if ( EAGAIN != hse_err_to_errno ( ret )) break ; retries ++ ; } Filename: .c","title":"typedef hse_err_t"},{"location":"api/Modules/group__ERROR__HANDLING/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/Modules/group__ERROR__HANDLING/#function-hse_strerror","text":"HSE_EXPORT size_t hse_strerror ( hse_err_t err , char * buf , size_t buf_len ) Return an hse_err_t value's string representation. Parameters : err Error value returned from an HSE API function. buf Buffer to hold the formatted string. buf_len Length of buffer. Return : The number of characters (excluding the terminating null byte) which would have been written to the final string if enough space had been available. The hse_err_t scalar value err is decoded into a NULL-terminated string representation giving more information about the error and where it occurred. The string will be truncated if buf_len is too small (a buf_len value of 128 is sufficient to avoid truncation of most error strings). This function is thread safe.","title":"function hse_strerror"},{"location":"api/Modules/group__ERROR__HANDLING/#function-hse_err_to_errno","text":"HSE_EXPORT int hse_err_to_errno ( hse_err_t err ) Return an hse_err_t value's errno representation. Parameters : err Error value returned from an HSE API function. Return : The error's errno equivalent. The hse_err_t scalar value err is translated into its errno equivalent. This function is thread safe. Updated on 1 October 2021 at 17:03:30 CDT","title":"function hse_err_to_errno"},{"location":"api/Modules/group__INIT/","text":"Initialization Routines Functions Name HSE_EXPORT hse_err_t hse_init (const char * config, size_t paramc, const char *const * paramv) Initialize the HSE subsystem. HSE_EXPORT void hse_fini (void ) Shutdown the HSE subsystem. Functions Documentation function hse_init HSE_EXPORT hse_err_t hse_init ( const char * config , size_t paramc , const char * const * paramv ) Initialize the HSE subsystem. Parameters : config Path to a global configuration file. paramc Number of initialization parameters in paramv . paramv List of parameters in key=value format. Return : Error status This function initializes a range of different internal HSE structures. It must be called before any other HSE functions are used. It is not thread safe and is idempotent. function hse_fini HSE_EXPORT void hse_fini ( void ) Shutdown the HSE subsystem. This function cleanly finalizes a range of different internal HSE structures. It should be called prior to application exit and is not thread safe. After it is invoked (and even before it returns), calling any other HSE functions will result in undefined behavior. This function is not thread safe. Updated on 1 October 2021 at 17:03:30 CDT","title":"Initialization Routines"},{"location":"api/Modules/group__INIT/#initialization-routines","text":"","title":"Initialization Routines"},{"location":"api/Modules/group__INIT/#functions","text":"Name HSE_EXPORT hse_err_t hse_init (const char * config, size_t paramc, const char *const * paramv) Initialize the HSE subsystem. HSE_EXPORT void hse_fini (void ) Shutdown the HSE subsystem.","title":"Functions"},{"location":"api/Modules/group__INIT/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/Modules/group__INIT/#function-hse_init","text":"HSE_EXPORT hse_err_t hse_init ( const char * config , size_t paramc , const char * const * paramv ) Initialize the HSE subsystem. Parameters : config Path to a global configuration file. paramc Number of initialization parameters in paramv . paramv List of parameters in key=value format. Return : Error status This function initializes a range of different internal HSE structures. It must be called before any other HSE functions are used. It is not thread safe and is idempotent.","title":"function hse_init"},{"location":"api/Modules/group__INIT/#function-hse_fini","text":"HSE_EXPORT void hse_fini ( void ) Shutdown the HSE subsystem. This function cleanly finalizes a range of different internal HSE structures. It should be called prior to application exit and is not thread safe. After it is invoked (and even before it returns), calling any other HSE functions will result in undefined behavior. This function is not thread safe. Updated on 1 October 2021 at 17:03:30 CDT","title":"function hse_fini"},{"location":"api/Modules/group__LIFECYCLE/","text":"Primary Lifecycle Functions More... Functions Name HSE_EXPORT hse_err_t hse_kvdb_create (const char * kvdb_home, size_t paramc, const char *const * paramv) Create a KVDB. HSE_EXPORT hse_err_t hse_kvdb_drop (const char * kvdb_home) Drop a KVDB. HSE_EXPORT hse_err_t hse_kvdb_open (const char * kvdb_home, size_t paramc, const char const * paramv, struct hse_kvdb * kvdb) Open a KVDB. HSE_EXPORT hse_err_t hse_kvdb_close (struct hse_kvdb * kvdb) Close a KVDB. HSE_EXPORT hse_err_t hse_kvdb_kvs_names_get (struct hse_kvdb * kvdb, size_t * namec, char *** namev) Get the names of the KVSs within the given KVDB. HSE_EXPORT void hse_kvdb_kvs_names_free (struct hse_kvdb * kvdb, char ** namev) Free the names collection obtained through hse_kvdb_kvs_names_get() . HSE_EXPORT hse_err_t hse_kvdb_kvs_create (struct hse_kvdb * kvdb, const char * kvs_name, size_t paramc, const char *const * paramv) Create a KVS within the referenced KVDB. HSE_EXPORT hse_err_t hse_kvdb_kvs_drop (struct hse_kvdb * kvdb, const char * kvs_name) Drop a KVS from the referenced KVDB. HSE_EXPORT hse_err_t hse_kvdb_kvs_open (struct hse_kvdb * handle, const char * kvs_name, const size_t paramc, const char const * paramv, struct hse_kvs * kvs_out) Open a KVS in a KVDB. HSE_EXPORT hse_err_t hse_kvdb_kvs_close (struct hse_kvs * kvs) Close an open KVS. Detailed Description Functions that manage HSE objects. Functions Documentation function hse_kvdb_create HSE_EXPORT hse_err_t hse_kvdb_create ( const char * kvdb_home , size_t paramc , const char * const * paramv ) Create a KVDB. Parameters : kvdb_home KVDB home directory, NULL means current working directory. paramc Number of configuration parameters in paramv . paramv List of parameters in key=value format. Return : The function's error status This function is not thread safe. function hse_kvdb_drop HSE_EXPORT hse_err_t hse_kvdb_drop ( const char * kvdb_home ) Drop a KVDB. Parameters : kvdb_home KVDB home directory, NULL means current working directory. Return : Error status It is an error to call this function on a KVDB that is open. This function is not thread safe. function hse_kvdb_open HSE_EXPORT hse_err_t hse_kvdb_open ( const char * kvdb_home , size_t paramc , const char * const * paramv , struct hse_kvdb ** kvdb ) Open a KVDB. Parameters : kvdb_home KVDB home directory, NULL means current working directory paramc Number of configuration parameters in paramv . paramv List of parameters in key=value format. kvdb Handle to access the opened KVDB. Return : Error status The KVDB must already exist and the client must have permission to use it. This function is not thread safe. function hse_kvdb_close HSE_EXPORT hse_err_t hse_kvdb_close ( struct hse_kvdb * kvdb ) Close a KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() . Return : Error status No client thread may enter the HSE KVDB API with the referenced KVDB after this function starts. This function is not thread safe. function hse_kvdb_kvs_names_get HSE_EXPORT hse_err_t hse_kvdb_kvs_names_get ( struct hse_kvdb * kvdb , size_t * namec , char *** namev ) Get the names of the KVSs within the given KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() . namec Number of KVSs in the KVDB. namev Vector of KVSs. Allocated by the function. Return : Error status Key-value stores (KVSs) are opened by name. This function allocates a vector of allocated strings, each containing the NULL-terminated name of a KVS. The memory must be freed via hse_kvdb_kvs_names_free() . This function is thread safe. Example Usage: int namec , i , rc ; char ** namev ; rc = hse_kvdb_kvs_names_get ( kvdb , & namec , & namev ); if ( ! rc ) { for ( i = 0 ; i < namec ; i ++ ) printf ( \"%s \\n \" , namev [ i ]); } hse_kvdb_kvs_names_free ( namev ); Filename: .c function hse_kvdb_kvs_names_free HSE_EXPORT void hse_kvdb_kvs_names_free ( struct hse_kvdb * kvdb , char ** namev ) Free the names collection obtained through hse_kvdb_kvs_names_get() . Parameters : kvdb KVDB handle from hse_kvdb_open() . namev Vector of KVS names that hse_kvdb_kvs_names_get() output. This function is thread safe. function hse_kvdb_kvs_create HSE_EXPORT hse_err_t hse_kvdb_kvs_create ( struct hse_kvdb * kvdb , const char * kvs_name , size_t paramc , const char * const * paramv ) Create a KVS within the referenced KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() . kvs_name KVS name (NULL terminated, strlen() < HSE_KVS_NAME_LEN_MAX) paramc Number of configuration parameters in paramv . paramv List of parameters in key=value format. Return : Error status If the KVS will store segmented keys then the parameter \"pfx_len\" should be set to the desired key prefix length. An error will result if there is already a KVS with the given name. This function is not thread safe. function hse_kvdb_kvs_drop HSE_EXPORT hse_err_t hse_kvdb_kvs_drop ( struct hse_kvdb * kvdb , const char * kvs_name ) Drop a KVS from the referenced KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() kvs_name KVS name (NULL-terminated string) Return : The function's error status It is an error to call this function on a KVS that is open. This function is not thread safe. function hse_kvdb_kvs_open HSE_EXPORT hse_err_t hse_kvdb_kvs_open ( struct hse_kvdb * handle , const char * kvs_name , const size_t paramc , const char * const * paramv , struct hse_kvs ** kvs_out ) Open a KVS in a KVDB. Parameters : handle KVDB handle from hse_kvdb_open() . kvs_name KVS name (NULL terminated string). paramc Number of configuration parameters in paramv . paramv List of parameters in key=value format. kvs_out Handle to access the opened KVS. Return : The function's error status This function is not thread safe. function hse_kvdb_kvs_close HSE_EXPORT hse_err_t hse_kvdb_kvs_close ( struct hse_kvs * kvs ) Close an open KVS. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . Return : The function's error status No client thread may enter the HSE KVDB API with the referenced KVS after this function starts. This function is not thread safe. Updated on 1 October 2021 at 17:03:30 CDT","title":"Primary Lifecycle Functions"},{"location":"api/Modules/group__LIFECYCLE/#primary-lifecycle-functions","text":"More...","title":"Primary Lifecycle Functions"},{"location":"api/Modules/group__LIFECYCLE/#functions","text":"Name HSE_EXPORT hse_err_t hse_kvdb_create (const char * kvdb_home, size_t paramc, const char *const * paramv) Create a KVDB. HSE_EXPORT hse_err_t hse_kvdb_drop (const char * kvdb_home) Drop a KVDB. HSE_EXPORT hse_err_t hse_kvdb_open (const char * kvdb_home, size_t paramc, const char const * paramv, struct hse_kvdb * kvdb) Open a KVDB. HSE_EXPORT hse_err_t hse_kvdb_close (struct hse_kvdb * kvdb) Close a KVDB. HSE_EXPORT hse_err_t hse_kvdb_kvs_names_get (struct hse_kvdb * kvdb, size_t * namec, char *** namev) Get the names of the KVSs within the given KVDB. HSE_EXPORT void hse_kvdb_kvs_names_free (struct hse_kvdb * kvdb, char ** namev) Free the names collection obtained through hse_kvdb_kvs_names_get() . HSE_EXPORT hse_err_t hse_kvdb_kvs_create (struct hse_kvdb * kvdb, const char * kvs_name, size_t paramc, const char *const * paramv) Create a KVS within the referenced KVDB. HSE_EXPORT hse_err_t hse_kvdb_kvs_drop (struct hse_kvdb * kvdb, const char * kvs_name) Drop a KVS from the referenced KVDB. HSE_EXPORT hse_err_t hse_kvdb_kvs_open (struct hse_kvdb * handle, const char * kvs_name, const size_t paramc, const char const * paramv, struct hse_kvs * kvs_out) Open a KVS in a KVDB. HSE_EXPORT hse_err_t hse_kvdb_kvs_close (struct hse_kvs * kvs) Close an open KVS.","title":"Functions"},{"location":"api/Modules/group__LIFECYCLE/#detailed-description","text":"Functions that manage HSE objects.","title":"Detailed Description"},{"location":"api/Modules/group__LIFECYCLE/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/Modules/group__LIFECYCLE/#function-hse_kvdb_create","text":"HSE_EXPORT hse_err_t hse_kvdb_create ( const char * kvdb_home , size_t paramc , const char * const * paramv ) Create a KVDB. Parameters : kvdb_home KVDB home directory, NULL means current working directory. paramc Number of configuration parameters in paramv . paramv List of parameters in key=value format. Return : The function's error status This function is not thread safe.","title":"function hse_kvdb_create"},{"location":"api/Modules/group__LIFECYCLE/#function-hse_kvdb_drop","text":"HSE_EXPORT hse_err_t hse_kvdb_drop ( const char * kvdb_home ) Drop a KVDB. Parameters : kvdb_home KVDB home directory, NULL means current working directory. Return : Error status It is an error to call this function on a KVDB that is open. This function is not thread safe.","title":"function hse_kvdb_drop"},{"location":"api/Modules/group__LIFECYCLE/#function-hse_kvdb_open","text":"HSE_EXPORT hse_err_t hse_kvdb_open ( const char * kvdb_home , size_t paramc , const char * const * paramv , struct hse_kvdb ** kvdb ) Open a KVDB. Parameters : kvdb_home KVDB home directory, NULL means current working directory paramc Number of configuration parameters in paramv . paramv List of parameters in key=value format. kvdb Handle to access the opened KVDB. Return : Error status The KVDB must already exist and the client must have permission to use it. This function is not thread safe.","title":"function hse_kvdb_open"},{"location":"api/Modules/group__LIFECYCLE/#function-hse_kvdb_close","text":"HSE_EXPORT hse_err_t hse_kvdb_close ( struct hse_kvdb * kvdb ) Close a KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() . Return : Error status No client thread may enter the HSE KVDB API with the referenced KVDB after this function starts. This function is not thread safe.","title":"function hse_kvdb_close"},{"location":"api/Modules/group__LIFECYCLE/#function-hse_kvdb_kvs_names_get","text":"HSE_EXPORT hse_err_t hse_kvdb_kvs_names_get ( struct hse_kvdb * kvdb , size_t * namec , char *** namev ) Get the names of the KVSs within the given KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() . namec Number of KVSs in the KVDB. namev Vector of KVSs. Allocated by the function. Return : Error status Key-value stores (KVSs) are opened by name. This function allocates a vector of allocated strings, each containing the NULL-terminated name of a KVS. The memory must be freed via hse_kvdb_kvs_names_free() . This function is thread safe. Example Usage: int namec , i , rc ; char ** namev ; rc = hse_kvdb_kvs_names_get ( kvdb , & namec , & namev ); if ( ! rc ) { for ( i = 0 ; i < namec ; i ++ ) printf ( \"%s \\n \" , namev [ i ]); } hse_kvdb_kvs_names_free ( namev ); Filename: .c","title":"function hse_kvdb_kvs_names_get"},{"location":"api/Modules/group__LIFECYCLE/#function-hse_kvdb_kvs_names_free","text":"HSE_EXPORT void hse_kvdb_kvs_names_free ( struct hse_kvdb * kvdb , char ** namev ) Free the names collection obtained through hse_kvdb_kvs_names_get() . Parameters : kvdb KVDB handle from hse_kvdb_open() . namev Vector of KVS names that hse_kvdb_kvs_names_get() output. This function is thread safe.","title":"function hse_kvdb_kvs_names_free"},{"location":"api/Modules/group__LIFECYCLE/#function-hse_kvdb_kvs_create","text":"HSE_EXPORT hse_err_t hse_kvdb_kvs_create ( struct hse_kvdb * kvdb , const char * kvs_name , size_t paramc , const char * const * paramv ) Create a KVS within the referenced KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() . kvs_name KVS name (NULL terminated, strlen() < HSE_KVS_NAME_LEN_MAX) paramc Number of configuration parameters in paramv . paramv List of parameters in key=value format. Return : Error status If the KVS will store segmented keys then the parameter \"pfx_len\" should be set to the desired key prefix length. An error will result if there is already a KVS with the given name. This function is not thread safe.","title":"function hse_kvdb_kvs_create"},{"location":"api/Modules/group__LIFECYCLE/#function-hse_kvdb_kvs_drop","text":"HSE_EXPORT hse_err_t hse_kvdb_kvs_drop ( struct hse_kvdb * kvdb , const char * kvs_name ) Drop a KVS from the referenced KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() kvs_name KVS name (NULL-terminated string) Return : The function's error status It is an error to call this function on a KVS that is open. This function is not thread safe.","title":"function hse_kvdb_kvs_drop"},{"location":"api/Modules/group__LIFECYCLE/#function-hse_kvdb_kvs_open","text":"HSE_EXPORT hse_err_t hse_kvdb_kvs_open ( struct hse_kvdb * handle , const char * kvs_name , const size_t paramc , const char * const * paramv , struct hse_kvs ** kvs_out ) Open a KVS in a KVDB. Parameters : handle KVDB handle from hse_kvdb_open() . kvs_name KVS name (NULL terminated string). paramc Number of configuration parameters in paramv . paramv List of parameters in key=value format. kvs_out Handle to access the opened KVS. Return : The function's error status This function is not thread safe.","title":"function hse_kvdb_kvs_open"},{"location":"api/Modules/group__LIFECYCLE/#function-hse_kvdb_kvs_close","text":"HSE_EXPORT hse_err_t hse_kvdb_kvs_close ( struct hse_kvs * kvs ) Close an open KVS. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . Return : The function's error status No client thread may enter the HSE KVDB API with the referenced KVS after this function starts. This function is not thread safe. Updated on 1 October 2021 at 17:03:30 CDT","title":"function hse_kvdb_kvs_close"},{"location":"api/Modules/group__LIMITS/","text":"Limits Defines Name HSE_KVS_COUNT_MAX Maximum number of KVS's contained within one KVDB. HSE_KVS_KEY_LEN_MAX Maximum key length. HSE_KVS_VALUE_LEN_MAX Max value length is 1MiB. HSE_KVS_PFX_LEN_MAX Max key prefix length. HSE_KVS_NAME_LEN_MAX Maximum length of a KVS name. Macros Documentation define HSE_KVS_COUNT_MAX #define HSE_KVS_COUNT_MAX (256) Maximum number of KVS's contained within one KVDB. define HSE_KVS_KEY_LEN_MAX #define HSE_KVS_KEY_LEN_MAX 1344 Maximum key length. Keys need not be NULL-terminated. define HSE_KVS_VALUE_LEN_MAX #define HSE_KVS_VALUE_LEN_MAX (1024 * 1024) Max value length is 1MiB. Values need not be NULL-terminated. define HSE_KVS_PFX_LEN_MAX #define HSE_KVS_PFX_LEN_MAX 32 Max key prefix length. define HSE_KVS_NAME_LEN_MAX #define HSE_KVS_NAME_LEN_MAX 32 Maximum length of a KVS name. KVS names are NULL-terminated strings. The string plus the NULL-terminator must fit into a HSE_KVS_NAME_LEN_MAX byte buffer. Updated on 1 October 2021 at 17:03:30 CDT","title":"Limits"},{"location":"api/Modules/group__LIMITS/#limits","text":"","title":"Limits"},{"location":"api/Modules/group__LIMITS/#defines","text":"Name HSE_KVS_COUNT_MAX Maximum number of KVS's contained within one KVDB. HSE_KVS_KEY_LEN_MAX Maximum key length. HSE_KVS_VALUE_LEN_MAX Max value length is 1MiB. HSE_KVS_PFX_LEN_MAX Max key prefix length. HSE_KVS_NAME_LEN_MAX Maximum length of a KVS name.","title":"Defines"},{"location":"api/Modules/group__LIMITS/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"api/Modules/group__LIMITS/#define-hse_kvs_count_max","text":"#define HSE_KVS_COUNT_MAX (256) Maximum number of KVS's contained within one KVDB.","title":"define HSE_KVS_COUNT_MAX"},{"location":"api/Modules/group__LIMITS/#define-hse_kvs_key_len_max","text":"#define HSE_KVS_KEY_LEN_MAX 1344 Maximum key length. Keys need not be NULL-terminated.","title":"define HSE_KVS_KEY_LEN_MAX"},{"location":"api/Modules/group__LIMITS/#define-hse_kvs_value_len_max","text":"#define HSE_KVS_VALUE_LEN_MAX (1024 * 1024) Max value length is 1MiB. Values need not be NULL-terminated.","title":"define HSE_KVS_VALUE_LEN_MAX"},{"location":"api/Modules/group__LIMITS/#define-hse_kvs_pfx_len_max","text":"#define HSE_KVS_PFX_LEN_MAX 32 Max key prefix length.","title":"define HSE_KVS_PFX_LEN_MAX"},{"location":"api/Modules/group__LIMITS/#define-hse_kvs_name_len_max","text":"#define HSE_KVS_NAME_LEN_MAX 32 Maximum length of a KVS name. KVS names are NULL-terminated strings. The string plus the NULL-terminator must fit into a HSE_KVS_NAME_LEN_MAX byte buffer. Updated on 1 October 2021 at 17:03:30 CDT","title":"define HSE_KVS_NAME_LEN_MAX"},{"location":"api/Modules/group__TXN/","text":"Transaction Functions More... Types Name enum hse_kvdb_txn_state { HSE_KVDB_TXN_INVALID = 0, HSE_KVDB_TXN_ACTIVE = 1, HSE_KVDB_TXN_COMMITTED = 2, HSE_KVDB_TXN_ABORTED = 3} Transaction state. Functions Name HSE_EXPORT struct hse_kvdb_txn * hse_kvdb_txn_alloc (struct hse_kvdb * kvdb) Allocate transaction object. HSE_EXPORT void hse_kvdb_txn_free (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Free transaction object. HSE_EXPORT hse_err_t hse_kvdb_txn_begin (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Initiate transaction. HSE_EXPORT hse_err_t hse_kvdb_txn_commit (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Commit all the mutations of the referenced transaction. HSE_EXPORT hse_err_t hse_kvdb_txn_abort (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Abort/rollback transaction. HSE_EXPORT enum hse_kvdb_txn_state hse_kvdb_txn_state_get (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Retrieve the state of the referenced transaction. Detailed Description The HSE KVDB provides transactions with operations spanning KVSs within a single KVDB. These transactions have snapshot isolation (a specific form of MVCC) with the normal semantics (see \"Concurrency Control and Recovery in Database Systems\" by PA Bernstein). One unusual aspect of the API as it relates to transactions is that the data object that is used to hold client-level transaction state is allocated separately from the transaction being initiated. As a result, the same object handle should be reused again and again. In addition, there is very limited coupling between threading and transactions. A single thread may have many transactions in flight simultaneously. Also operations within a transaction can be performed by multiple threads. The latter mode of operation must currently restrict calls so that only one thread is actively performing an operation in the context of a particular transaction at any particular time. The general lifecycle of a transaction is as follows: +----------+ | INVALID | +----------+ | v +----------+ +---------------->| ACTIVE |<----------------+ | +----------+ | | +-----------+ | | +----------+ | +--| COMMITTED |<---+ +---->| ABORTED |--+ +-----------+ +----------+ When a transaction is initially allocated, it starts in the INVALID state. When hse_kvdb_txn_begin() is called with transaction in the INVALID, COMMITTED, or ABORTED states, it moves to the ACTIVE state. It is an error to call the hse_kvdb_txn_begin() function on a transaction in the ACTIVE state. For a transaction in the ACTIVE state, only the functions hse_kvdb_txn_commit() , hse_kvdb_txn_abort() , or hse_kvdb_txn_free() may be called (with the last doing an abort prior to the free). When a transaction becomes ACTIVE, it establishes an ephemeral snapshot view of the state of the KVDB. Any data mutations outside of the transaction's context after that point are not visible to the transaction. Similarly, any mutations performed within the context of the transaction are not visible outside of the transaction unless and until it is committed. All such mutations become visible atomically when the transaction commits. Within a transaction whenever a write operation e.g., put, delete, etc., encounters a write conflict, that operation returns an error code of ECANCELED. The caller is then expected to re-try the operation in a new transaction, see HSE Return Codes . Types Documentation enum hse_kvdb_txn_state Enumerator Value Description HSE_KVDB_TXN_INVALID 0 HSE_KVDB_TXN_ACTIVE 1 HSE_KVDB_TXN_COMMITTED 2 HSE_KVDB_TXN_ABORTED 3 Transaction state. Functions Documentation function hse_kvdb_txn_alloc HSE_EXPORT struct hse_kvdb_txn * hse_kvdb_txn_alloc ( struct hse_kvdb * kvdb ) Allocate transaction object. Parameters : kvdb KVDB handle from hse_kvdb_open() . Return : The allocated transaction structure. This object can and should be re-used many times to avoid the overhead of allocation. This function is thread safe. function hse_kvdb_txn_free HSE_EXPORT void hse_kvdb_txn_free ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Free transaction object. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle. If the transaction handle refers to an ACTIVE transaction, the transaction is aborted prior to being freed. This function is thread safe with different transactions. function hse_kvdb_txn_begin HSE_EXPORT hse_err_t hse_kvdb_txn_begin ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Initiate transaction. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle from hse_kvdb_txn_alloc() . Return : The function's error status The call fails if the transaction handle refers to an ACTIVE transaction. This function is thread safe with different transactions. function hse_kvdb_txn_commit HSE_EXPORT hse_err_t hse_kvdb_txn_commit ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Commit all the mutations of the referenced transaction. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle from hse_kvdb_txn_alloc() . Return : Error status The call fails if the referenced transaction is not in the ACTIVE state. This function is thread safe with different transactions. function hse_kvdb_txn_abort HSE_EXPORT hse_err_t hse_kvdb_txn_abort ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Abort/rollback transaction. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle from hse_kvdb_txn_alloc() . Return : Error status The call fails if the referenced transaction is not in the ACTIVE state. This function is thread safe with different transactions. function hse_kvdb_txn_state_get HSE_EXPORT enum hse_kvdb_txn_state hse_kvdb_txn_state_get ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Retrieve the state of the referenced transaction. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle from hse_kvdb_txn_alloc() . Return : The transaction's state This function is thread safe with different transactions. Updated on 1 October 2021 at 17:03:30 CDT","title":"Transaction Functions"},{"location":"api/Modules/group__TXN/#transaction-functions","text":"More...","title":"Transaction Functions"},{"location":"api/Modules/group__TXN/#types","text":"Name enum hse_kvdb_txn_state { HSE_KVDB_TXN_INVALID = 0, HSE_KVDB_TXN_ACTIVE = 1, HSE_KVDB_TXN_COMMITTED = 2, HSE_KVDB_TXN_ABORTED = 3} Transaction state.","title":"Types"},{"location":"api/Modules/group__TXN/#functions","text":"Name HSE_EXPORT struct hse_kvdb_txn * hse_kvdb_txn_alloc (struct hse_kvdb * kvdb) Allocate transaction object. HSE_EXPORT void hse_kvdb_txn_free (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Free transaction object. HSE_EXPORT hse_err_t hse_kvdb_txn_begin (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Initiate transaction. HSE_EXPORT hse_err_t hse_kvdb_txn_commit (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Commit all the mutations of the referenced transaction. HSE_EXPORT hse_err_t hse_kvdb_txn_abort (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Abort/rollback transaction. HSE_EXPORT enum hse_kvdb_txn_state hse_kvdb_txn_state_get (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Retrieve the state of the referenced transaction.","title":"Functions"},{"location":"api/Modules/group__TXN/#detailed-description","text":"The HSE KVDB provides transactions with operations spanning KVSs within a single KVDB. These transactions have snapshot isolation (a specific form of MVCC) with the normal semantics (see \"Concurrency Control and Recovery in Database Systems\" by PA Bernstein). One unusual aspect of the API as it relates to transactions is that the data object that is used to hold client-level transaction state is allocated separately from the transaction being initiated. As a result, the same object handle should be reused again and again. In addition, there is very limited coupling between threading and transactions. A single thread may have many transactions in flight simultaneously. Also operations within a transaction can be performed by multiple threads. The latter mode of operation must currently restrict calls so that only one thread is actively performing an operation in the context of a particular transaction at any particular time. The general lifecycle of a transaction is as follows: +----------+ | INVALID | +----------+ | v +----------+ +---------------->| ACTIVE |<----------------+ | +----------+ | | +-----------+ | | +----------+ | +--| COMMITTED |<---+ +---->| ABORTED |--+ +-----------+ +----------+ When a transaction is initially allocated, it starts in the INVALID state. When hse_kvdb_txn_begin() is called with transaction in the INVALID, COMMITTED, or ABORTED states, it moves to the ACTIVE state. It is an error to call the hse_kvdb_txn_begin() function on a transaction in the ACTIVE state. For a transaction in the ACTIVE state, only the functions hse_kvdb_txn_commit() , hse_kvdb_txn_abort() , or hse_kvdb_txn_free() may be called (with the last doing an abort prior to the free). When a transaction becomes ACTIVE, it establishes an ephemeral snapshot view of the state of the KVDB. Any data mutations outside of the transaction's context after that point are not visible to the transaction. Similarly, any mutations performed within the context of the transaction are not visible outside of the transaction unless and until it is committed. All such mutations become visible atomically when the transaction commits. Within a transaction whenever a write operation e.g., put, delete, etc., encounters a write conflict, that operation returns an error code of ECANCELED. The caller is then expected to re-try the operation in a new transaction, see HSE Return Codes .","title":"Detailed Description"},{"location":"api/Modules/group__TXN/#types-documentation","text":"","title":"Types Documentation"},{"location":"api/Modules/group__TXN/#enum-hse_kvdb_txn_state","text":"Enumerator Value Description HSE_KVDB_TXN_INVALID 0 HSE_KVDB_TXN_ACTIVE 1 HSE_KVDB_TXN_COMMITTED 2 HSE_KVDB_TXN_ABORTED 3 Transaction state.","title":"enum hse_kvdb_txn_state"},{"location":"api/Modules/group__TXN/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/Modules/group__TXN/#function-hse_kvdb_txn_alloc","text":"HSE_EXPORT struct hse_kvdb_txn * hse_kvdb_txn_alloc ( struct hse_kvdb * kvdb ) Allocate transaction object. Parameters : kvdb KVDB handle from hse_kvdb_open() . Return : The allocated transaction structure. This object can and should be re-used many times to avoid the overhead of allocation. This function is thread safe.","title":"function hse_kvdb_txn_alloc"},{"location":"api/Modules/group__TXN/#function-hse_kvdb_txn_free","text":"HSE_EXPORT void hse_kvdb_txn_free ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Free transaction object. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle. If the transaction handle refers to an ACTIVE transaction, the transaction is aborted prior to being freed. This function is thread safe with different transactions.","title":"function hse_kvdb_txn_free"},{"location":"api/Modules/group__TXN/#function-hse_kvdb_txn_begin","text":"HSE_EXPORT hse_err_t hse_kvdb_txn_begin ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Initiate transaction. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle from hse_kvdb_txn_alloc() . Return : The function's error status The call fails if the transaction handle refers to an ACTIVE transaction. This function is thread safe with different transactions.","title":"function hse_kvdb_txn_begin"},{"location":"api/Modules/group__TXN/#function-hse_kvdb_txn_commit","text":"HSE_EXPORT hse_err_t hse_kvdb_txn_commit ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Commit all the mutations of the referenced transaction. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle from hse_kvdb_txn_alloc() . Return : Error status The call fails if the referenced transaction is not in the ACTIVE state. This function is thread safe with different transactions.","title":"function hse_kvdb_txn_commit"},{"location":"api/Modules/group__TXN/#function-hse_kvdb_txn_abort","text":"HSE_EXPORT hse_err_t hse_kvdb_txn_abort ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Abort/rollback transaction. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle from hse_kvdb_txn_alloc() . Return : Error status The call fails if the referenced transaction is not in the ACTIVE state. This function is thread safe with different transactions.","title":"function hse_kvdb_txn_abort"},{"location":"api/Modules/group__TXN/#function-hse_kvdb_txn_state_get","text":"HSE_EXPORT enum hse_kvdb_txn_state hse_kvdb_txn_state_get ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Retrieve the state of the referenced transaction. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle from hse_kvdb_txn_alloc() . Return : The transaction's state This function is thread safe with different transactions. Updated on 1 October 2021 at 17:03:30 CDT","title":"function hse_kvdb_txn_state_get"},{"location":"api/Modules/group__TYPES/","text":"Type Declarations, Shared Structures and Macros More... Data Structures Name struct hse_kvdb Opaque structure, a pointer to which is a handle to an HSE key-value database (KVDB). struct hse_kvs Opaque structure, a pointer to which is a handle to an HSE key-value store within a KVDB (KVS). struct hse_kvs_cursor Opaque structure, a pointer to which is a handle to a cursor within a KVS. struct hse_kvdb_txn Opaque structure, a pointer to which is a handle to a transaction within a KVDB. Defines Name HSE_VERSION_STRING A string representing the HSE KVDB libary version. HSE_VERSION_MAJOR HSE_VERSION_MINOR HSE_VERSION_PATCH Detailed Description These types are generally opaque handles that a client obtains by using library functions. A client uses these handles to exercise more fine-grained functionality. For example a \"struct hse_kvdb\" is the handle for a key-value database that one obtains by calling hse_kvdb_open() . Macros Documentation define HSE_VERSION_STRING #define HSE_VERSION_STRING \"r2.0.0-rc4-0-g391ccaab\" A string representing the HSE KVDB libary version. define HSE_VERSION_MAJOR #define HSE_VERSION_MAJOR 2 define HSE_VERSION_MINOR #define HSE_VERSION_MINOR 0 define HSE_VERSION_PATCH #define HSE_VERSION_PATCH 0 Updated on 1 October 2021 at 17:03:30 CDT","title":"Type Declarations, Shared Structures and Macros"},{"location":"api/Modules/group__TYPES/#type-declarations-shared-structures-and-macros","text":"More...","title":"Type Declarations, Shared Structures and Macros"},{"location":"api/Modules/group__TYPES/#data-structures","text":"Name struct hse_kvdb Opaque structure, a pointer to which is a handle to an HSE key-value database (KVDB). struct hse_kvs Opaque structure, a pointer to which is a handle to an HSE key-value store within a KVDB (KVS). struct hse_kvs_cursor Opaque structure, a pointer to which is a handle to a cursor within a KVS. struct hse_kvdb_txn Opaque structure, a pointer to which is a handle to a transaction within a KVDB.","title":"Data Structures"},{"location":"api/Modules/group__TYPES/#defines","text":"Name HSE_VERSION_STRING A string representing the HSE KVDB libary version. HSE_VERSION_MAJOR HSE_VERSION_MINOR HSE_VERSION_PATCH","title":"Defines"},{"location":"api/Modules/group__TYPES/#detailed-description","text":"These types are generally opaque handles that a client obtains by using library functions. A client uses these handles to exercise more fine-grained functionality. For example a \"struct hse_kvdb\" is the handle for a key-value database that one obtains by calling hse_kvdb_open() .","title":"Detailed Description"},{"location":"api/Modules/group__TYPES/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"api/Modules/group__TYPES/#define-hse_version_string","text":"#define HSE_VERSION_STRING \"r2.0.0-rc4-0-g391ccaab\" A string representing the HSE KVDB libary version.","title":"define HSE_VERSION_STRING"},{"location":"api/Modules/group__TYPES/#define-hse_version_major","text":"#define HSE_VERSION_MAJOR 2","title":"define HSE_VERSION_MAJOR"},{"location":"api/Modules/group__TYPES/#define-hse_version_minor","text":"#define HSE_VERSION_MINOR 0","title":"define HSE_VERSION_MINOR"},{"location":"api/Modules/group__TYPES/#define-hse_version_patch","text":"#define HSE_VERSION_PATCH 0 Updated on 1 October 2021 at 17:03:30 CDT","title":"define HSE_VERSION_PATCH"},{"location":"api/Pages/","text":"Examples page Examples page Overview Updated on 1 October 2021 at 17:03:30 CDT","title":"Examples"},{"location":"api/Pages/#examples","text":"page Examples page Overview Updated on 1 October 2021 at 17:03:30 CDT","title":"Examples"},{"location":"api/Pages/examples/","text":"Examples See the samples directory in the source tree for examples. Here is a simple one. /* SPDX-License-Identifier: Apache-2.0 */ /* * Copyright (C) 2015-2021 Micron Technology, Inc. All rights reserved. */ #include <stdio.h> #include <string.h> #include <hse/hse.h> #include \"helper.h\" /* * This is a simple example application that performs basic key-value operations * on a KVS. * * This program * 1. puts few keys into a KVS * 2. verifies that hse_kvs_get() can find them. * 3. delete one of the keys * 4. verify that the deleted key cannot be found. */ int usage ( char * prog ) { printf ( \"usage: %s <kvdb_home> <kvs> \\n \" , prog ); return 1 ; } int main ( int argc , char ** argv ) { char * kvdb_home , * kvs_name ; struct hse_kvdb * kvdb ; struct hse_kvs * kvs ; const char * paramv [] = { \"logging.destination=stdout\" , \"logging.level=3\" , \"socket.enabled=false\" }; const size_t paramc = sizeof ( paramv ) / sizeof ( paramv [ 0 ]); size_t vlen ; char vbuf [ 32 ]; bool found ; hse_err_t rc , rc2 ; if ( argc != 3 ) return usage ( argv [ 0 ]); kvdb_home = argv [ 1 ]; kvs_name = argv [ 2 ]; rc = hse_init ( NULL , paramc , paramv ); if ( rc ) { error ( rc , \"Failed to initialize KVDB (%s)\" , kvdb_home ); goto out ; } rc = hse_kvdb_open ( kvdb_home , 0 , NULL , & kvdb ); if ( rc ) { error ( rc , \"Cannot open KVDB (%s)\" , kvdb_home ); goto hse_cleanup ; } rc = hse_kvdb_kvs_open ( kvdb , kvs_name , 0 , NULL , & kvs ); if ( rc ) { error ( rc , \"Cannot open KVS (%s)\" , kvs_name ); goto kvdb_cleanup ; } /* Error handling is elided for clarity */ /* 1. Put a few keys and verify that hse_kvs_get() can find them */ rc = hse_kvs_put ( kvs , 0 , NULL , \"k1\" , 2 , \"val1\" , 4 ); rc = rc ?: hse_kvs_put ( kvs , 0 , NULL , \"k2\" , 2 , \"val2\" , 4 ); rc = rc ?: hse_kvs_put ( kvs , 0 , NULL , \"k3\" , 2 , \"val3\" , 4 ); rc = rc ?: hse_kvs_put ( kvs , 0 , NULL , \"k4\" , 2 , NULL , 0 ); if ( rc ) { error ( rc , \"Failed to put data into KVS (%s)\" , kvs_name ); goto kvs_cleanup ; } rc = hse_kvs_get ( kvs , 0 , NULL , \"k1\" , 2 , & found , vbuf , sizeof ( vbuf ), & vlen ); if ( rc ) { error ( rc , \"Failed to get k1 data\" ); goto kvs_cleanup ; } printf ( \"k1 found = %s \\n \" , found ? \"true\" : \"false\" ); rc = hse_kvs_get ( kvs , 0 , NULL , \"k2\" , 2 , & found , vbuf , sizeof ( vbuf ), & vlen ); if ( rc ) { error ( rc , \"Failed to get k2 data\" ); goto kvs_cleanup ; } printf ( \"k2 found = %s \\n \" , found ? \"true\" : \"false\" ); rc = hse_kvs_get ( kvs , 0 , NULL , \"k3\" , 2 , & found , vbuf , sizeof ( vbuf ), & vlen ); if ( rc ) { error ( rc , \"Failed to get k3 data\" ); goto kvs_cleanup ; } printf ( \"k3 found = %s \\n \" , found ? \"true\" : \"false\" ); rc = hse_kvs_get ( kvs , 0 , NULL , \"k4\" , 2 , & found , vbuf , sizeof ( vbuf ), & vlen ); if ( rc ) { error ( rc , \"Failed to get k4 data\" ); goto kvs_cleanup ; } printf ( \"k4 found = %s, length was %lu bytes \\n \" , found ? \"true\" : \"false\" , vlen ); /* 2. Delete a key and ensure that it cannot be found by hse_kvs_get() */ rc = hse_kvs_delete ( kvs , 0 , NULL , \"k1\" , 2 ); if ( rc ) { error ( rc , \"Failed to delete k1 data\" ); goto kvs_cleanup ; } printf ( \"k1 deleted \\n \" ); rc = hse_kvs_get ( kvs , 0 , NULL , \"k1\" , 2 , & found , vbuf , sizeof ( vbuf ), & vlen ); if ( rc ) { error ( rc , \"Failed to get k1 data\" ); goto kvs_cleanup ; } printf ( \"k1 found = %s \\n \" , found ? \"true\" : \"false\" ); kvs_cleanup : rc2 = hse_kvdb_kvs_close ( kvs ); if ( rc2 ) error ( rc2 , \"Failed to close KVS (%s)\" , kvs_name ); rc = rc ?: rc2 ; kvdb_cleanup : rc2 = hse_kvdb_close ( kvdb ); if ( rc2 ) error ( rc2 , \"Failed to close KVDB (%s)\" , kvdb_home ); rc = rc ?: rc2 ; hse_cleanup : hse_fini (); out : return hse_err_to_errno ( rc ); } Filename: ex2_simple_ops.c Updated on 1 October 2021 at 17:03:30 CDT","title":"Examples"},{"location":"api/Pages/examples/#examples","text":"See the samples directory in the source tree for examples. Here is a simple one. /* SPDX-License-Identifier: Apache-2.0 */ /* * Copyright (C) 2015-2021 Micron Technology, Inc. All rights reserved. */ #include <stdio.h> #include <string.h> #include <hse/hse.h> #include \"helper.h\" /* * This is a simple example application that performs basic key-value operations * on a KVS. * * This program * 1. puts few keys into a KVS * 2. verifies that hse_kvs_get() can find them. * 3. delete one of the keys * 4. verify that the deleted key cannot be found. */ int usage ( char * prog ) { printf ( \"usage: %s <kvdb_home> <kvs> \\n \" , prog ); return 1 ; } int main ( int argc , char ** argv ) { char * kvdb_home , * kvs_name ; struct hse_kvdb * kvdb ; struct hse_kvs * kvs ; const char * paramv [] = { \"logging.destination=stdout\" , \"logging.level=3\" , \"socket.enabled=false\" }; const size_t paramc = sizeof ( paramv ) / sizeof ( paramv [ 0 ]); size_t vlen ; char vbuf [ 32 ]; bool found ; hse_err_t rc , rc2 ; if ( argc != 3 ) return usage ( argv [ 0 ]); kvdb_home = argv [ 1 ]; kvs_name = argv [ 2 ]; rc = hse_init ( NULL , paramc , paramv ); if ( rc ) { error ( rc , \"Failed to initialize KVDB (%s)\" , kvdb_home ); goto out ; } rc = hse_kvdb_open ( kvdb_home , 0 , NULL , & kvdb ); if ( rc ) { error ( rc , \"Cannot open KVDB (%s)\" , kvdb_home ); goto hse_cleanup ; } rc = hse_kvdb_kvs_open ( kvdb , kvs_name , 0 , NULL , & kvs ); if ( rc ) { error ( rc , \"Cannot open KVS (%s)\" , kvs_name ); goto kvdb_cleanup ; } /* Error handling is elided for clarity */ /* 1. Put a few keys and verify that hse_kvs_get() can find them */ rc = hse_kvs_put ( kvs , 0 , NULL , \"k1\" , 2 , \"val1\" , 4 ); rc = rc ?: hse_kvs_put ( kvs , 0 , NULL , \"k2\" , 2 , \"val2\" , 4 ); rc = rc ?: hse_kvs_put ( kvs , 0 , NULL , \"k3\" , 2 , \"val3\" , 4 ); rc = rc ?: hse_kvs_put ( kvs , 0 , NULL , \"k4\" , 2 , NULL , 0 ); if ( rc ) { error ( rc , \"Failed to put data into KVS (%s)\" , kvs_name ); goto kvs_cleanup ; } rc = hse_kvs_get ( kvs , 0 , NULL , \"k1\" , 2 , & found , vbuf , sizeof ( vbuf ), & vlen ); if ( rc ) { error ( rc , \"Failed to get k1 data\" ); goto kvs_cleanup ; } printf ( \"k1 found = %s \\n \" , found ? \"true\" : \"false\" ); rc = hse_kvs_get ( kvs , 0 , NULL , \"k2\" , 2 , & found , vbuf , sizeof ( vbuf ), & vlen ); if ( rc ) { error ( rc , \"Failed to get k2 data\" ); goto kvs_cleanup ; } printf ( \"k2 found = %s \\n \" , found ? \"true\" : \"false\" ); rc = hse_kvs_get ( kvs , 0 , NULL , \"k3\" , 2 , & found , vbuf , sizeof ( vbuf ), & vlen ); if ( rc ) { error ( rc , \"Failed to get k3 data\" ); goto kvs_cleanup ; } printf ( \"k3 found = %s \\n \" , found ? \"true\" : \"false\" ); rc = hse_kvs_get ( kvs , 0 , NULL , \"k4\" , 2 , & found , vbuf , sizeof ( vbuf ), & vlen ); if ( rc ) { error ( rc , \"Failed to get k4 data\" ); goto kvs_cleanup ; } printf ( \"k4 found = %s, length was %lu bytes \\n \" , found ? \"true\" : \"false\" , vlen ); /* 2. Delete a key and ensure that it cannot be found by hse_kvs_get() */ rc = hse_kvs_delete ( kvs , 0 , NULL , \"k1\" , 2 ); if ( rc ) { error ( rc , \"Failed to delete k1 data\" ); goto kvs_cleanup ; } printf ( \"k1 deleted \\n \" ); rc = hse_kvs_get ( kvs , 0 , NULL , \"k1\" , 2 , & found , vbuf , sizeof ( vbuf ), & vlen ); if ( rc ) { error ( rc , \"Failed to get k1 data\" ); goto kvs_cleanup ; } printf ( \"k1 found = %s \\n \" , found ? \"true\" : \"false\" ); kvs_cleanup : rc2 = hse_kvdb_kvs_close ( kvs ); if ( rc2 ) error ( rc2 , \"Failed to close KVS (%s)\" , kvs_name ); rc = rc ?: rc2 ; kvdb_cleanup : rc2 = hse_kvdb_close ( kvdb ); if ( rc2 ) error ( rc2 , \"Failed to close KVDB (%s)\" , kvdb_home ); rc = rc ?: rc2 ; hse_cleanup : hse_fini (); out : return hse_err_to_errno ( rc ); } Filename: ex2_simple_ops.c Updated on 1 October 2021 at 17:03:30 CDT","title":"Examples"},{"location":"api/Structs/","text":"Data Structures struct hse_kvdb Opaque structure, a pointer to which is a handle to an HSE key-value database (KVDB). struct hse_kvdb_txn Opaque structure, a pointer to which is a handle to a transaction within a KVDB. struct hse_kvs Opaque structure, a pointer to which is a handle to an HSE key-value store within a KVDB (KVS). struct hse_kvs_cursor Opaque structure, a pointer to which is a handle to a cursor within a KVS. Updated on 1 October 2021 at 17:03:30 CDT","title":"Data Structures"},{"location":"api/Structs/#data-structures","text":"struct hse_kvdb Opaque structure, a pointer to which is a handle to an HSE key-value database (KVDB). struct hse_kvdb_txn Opaque structure, a pointer to which is a handle to a transaction within a KVDB. struct hse_kvs Opaque structure, a pointer to which is a handle to an HSE key-value store within a KVDB (KVS). struct hse_kvs_cursor Opaque structure, a pointer to which is a handle to a cursor within a KVS. Updated on 1 October 2021 at 17:03:30 CDT","title":"Data Structures"},{"location":"api/Structs/structhse__kvdb/","text":"hse_kvdb Module: Type Declarations, Shared Structures and Macros Opaque structure, a pointer to which is a handle to an HSE key-value database (KVDB). #include <types.h> Updated on 1 October 2021 at 17:03:30 CDT","title":"hse_kvdb"},{"location":"api/Structs/structhse__kvdb/#hse_kvdb","text":"Module: Type Declarations, Shared Structures and Macros Opaque structure, a pointer to which is a handle to an HSE key-value database (KVDB). #include <types.h> Updated on 1 October 2021 at 17:03:30 CDT","title":"hse_kvdb"},{"location":"api/Structs/structhse__kvdb__txn/","text":"hse_kvdb_txn Module: Type Declarations, Shared Structures and Macros Opaque structure, a pointer to which is a handle to a transaction within a KVDB. #include <types.h> Updated on 1 October 2021 at 17:03:30 CDT","title":"hse_kvdb_txn"},{"location":"api/Structs/structhse__kvdb__txn/#hse_kvdb_txn","text":"Module: Type Declarations, Shared Structures and Macros Opaque structure, a pointer to which is a handle to a transaction within a KVDB. #include <types.h> Updated on 1 October 2021 at 17:03:30 CDT","title":"hse_kvdb_txn"},{"location":"api/Structs/structhse__kvs/","text":"hse_kvs Module: Type Declarations, Shared Structures and Macros Opaque structure, a pointer to which is a handle to an HSE key-value store within a KVDB (KVS). #include <types.h> Updated on 1 October 2021 at 17:03:30 CDT","title":"hse_kvs"},{"location":"api/Structs/structhse__kvs/#hse_kvs","text":"Module: Type Declarations, Shared Structures and Macros Opaque structure, a pointer to which is a handle to an HSE key-value store within a KVDB (KVS). #include <types.h> Updated on 1 October 2021 at 17:03:30 CDT","title":"hse_kvs"},{"location":"api/Structs/structhse__kvs__cursor/","text":"hse_kvs_cursor Module: Type Declarations, Shared Structures and Macros Opaque structure, a pointer to which is a handle to a cursor within a KVS. #include <types.h> Updated on 1 October 2021 at 17:03:30 CDT","title":"hse_kvs_cursor"},{"location":"api/Structs/structhse__kvs__cursor/#hse_kvs_cursor","text":"Module: Type Declarations, Shared Structures and Macros Opaque structure, a pointer to which is a handle to a cursor within a KVS. #include <types.h> Updated on 1 October 2021 at 17:03:30 CDT","title":"hse_kvs_cursor"},{"location":"dev/bp/","text":"Best Practices The following are best practices for developing HSE applications. Many of these are covered in greater detail in the discussion of HSE concepts . Keys and KVSs Use a segmented key in the common case where related sets of KV pairs in a KVS are accessed together. Choose a key prefix that groups related KV pairs when keys are sorted lexicographically, and always create the KVS storing these KV pairs with a prefix.length equal to the key prefix length. Choose a key prefix for segmented keys that will take on a modest number of different values over a consecutive sequence of puts. For example, in a sequence of one million put operations, ideally no more than 5% of the keys will have the same key prefix value. Use a different KVS for each collection of KV pairs requiring its own segmented key structure. Create index KVSs to efficiently implement query patterns that cannot be supported with a single segmented key prefix. Use an unsegmented key in the case where there is no relationship between KV pairs in a KVS, and always create the KVS storing these KV pairs with a prefix.length of zero (0). Cursors and Gets Always use get operations when iteration is not required. Gets are significantly faster than cursor seeks. Where iteration is required, use cursors with a KVS storing segmented keys, and with a filter whose length is equal to or greater than the key prefix length for that KVS. Otherwise, cursor performance can be greatly reduced. Use non-transaction cursors for most applications. Transaction cursors exist to support some specialized use cases. Transactions Use transactions when required for application correctness. Otherwise, for best performance open a KVS with transactions disabled ( transactions.enabled=false ) and use non-transaction operations. Application Lifecycle At application startup, call hse_init() to initialize the HSE subsystem within your application. This function should be called only once. From there you can create or open a KVDB and its associated KVSs and perform KV operations. At application shutdown, close all KVSs for a KVDB before closing that KVDB. After all KVDBs are closed, call hse_fini() to completely shutdown the HSE subsystem within your application. Using a signal handler to close resources can also be helpful when trying to handle unexpected application shutdown.","title":"Best Practices"},{"location":"dev/bp/#best-practices","text":"The following are best practices for developing HSE applications. Many of these are covered in greater detail in the discussion of HSE concepts .","title":"Best Practices"},{"location":"dev/bp/#keys-and-kvss","text":"Use a segmented key in the common case where related sets of KV pairs in a KVS are accessed together. Choose a key prefix that groups related KV pairs when keys are sorted lexicographically, and always create the KVS storing these KV pairs with a prefix.length equal to the key prefix length. Choose a key prefix for segmented keys that will take on a modest number of different values over a consecutive sequence of puts. For example, in a sequence of one million put operations, ideally no more than 5% of the keys will have the same key prefix value. Use a different KVS for each collection of KV pairs requiring its own segmented key structure. Create index KVSs to efficiently implement query patterns that cannot be supported with a single segmented key prefix. Use an unsegmented key in the case where there is no relationship between KV pairs in a KVS, and always create the KVS storing these KV pairs with a prefix.length of zero (0).","title":"Keys and KVSs"},{"location":"dev/bp/#cursors-and-gets","text":"Always use get operations when iteration is not required. Gets are significantly faster than cursor seeks. Where iteration is required, use cursors with a KVS storing segmented keys, and with a filter whose length is equal to or greater than the key prefix length for that KVS. Otherwise, cursor performance can be greatly reduced. Use non-transaction cursors for most applications. Transaction cursors exist to support some specialized use cases.","title":"Cursors and Gets"},{"location":"dev/bp/#transactions","text":"Use transactions when required for application correctness. Otherwise, for best performance open a KVS with transactions disabled ( transactions.enabled=false ) and use non-transaction operations.","title":"Transactions"},{"location":"dev/bp/#application-lifecycle","text":"At application startup, call hse_init() to initialize the HSE subsystem within your application. This function should be called only once. From there you can create or open a KVDB and its associated KVSs and perform KV operations. At application shutdown, close all KVSs for a KVDB before closing that KVDB. After all KVDBs are closed, call hse_fini() to completely shutdown the HSE subsystem within your application. Using a signal handler to close resources can also be helpful when trying to handle unexpected application shutdown.","title":"Application Lifecycle"},{"location":"dev/concepts/","text":"Concepts The following describes HSE concepts that are important to understand for developing HSE applications and making effective use of the HSE API. KVDB and KVS HSE provides functions to create and access a key-value database (KVDB). A KVDB comprises one or more named key-value stores (KVS), each of which is an independent collection of key-value (KV) pairs. A KVS is analogous to a table in a relational database. HSE provides the standard KV operators for managing KV pairs stored in a KVS: put, get, and delete. HSE also provides transactions, cursors, prefix deletes, and other advanced features. The HSE data model enables each KVS in a KVDB to be optimized for how the KV pairs it stores will be accessed. Data Model Understanding the HSE data model is fundamental to achieving maximum application performance. Adhering to the best practices of this data model can result in significantly greater performance than might be achieved otherwise. While this data model is simple, it has proven very effective. Key Structure To describe the HSE data model, we define the following terms. key \u2014 a byte string used to uniquely identify a value for storage, retrieval, and deletion in a KVS segmented key \u2014 a key that is logically divided into N segments, N >= 2 , arranged to group related KV pairs when keys are sorted lexicographically unsegmented key \u2014 a key not logically divided into segments For segmented keys, we further define the following. key prefix \u2014 the first K segments, 1 <= K < N , that group related KV pairs when keys are sorted lexicographically key prefix length \u2014 the length of a key prefix in bytes KVS Configuration In the common case where related sets of KV pairs are accessed together, best performance is generally achieved by: defining a segmented key with a key prefix such that KV pairs to be accessed together are grouped (contiguous) when keys are sorted lexicographically, and creating a KVS to store these KV pairs with a key prefix length parameter ( prefix.length ) equal to the key prefix length of the segmented key. In the case where there is no relationship between KV pairs, best performance is generally achieved by: defining an unsegmented key, and creating a KVS to store these KV pairs with a key prefix length parameter ( prefix.length ) of zero (0). Keep in mind that a KVDB may contain multiple KVSs. So in the case where there are multiple collections of KV pairs, each collection can be stored in a different KVS with a key structure, and corresponding KVS prefix.length parameter, that is appropriate for that collection. This is a powerful capability that enables HSE to optimize storage and access for all KV pairs in a KVDB without compromise. Operation Support HSE provides several advanced operations with features that directly support the HSE data model. These operations are described in detail later, but we briefly discuss how they support the data model here. Cursors are used to iterate over keys in a KVS in forward or reverse lexicographic order. Cursors support an optional filter , which is a byte string limiting a cursor's view to only those keys whose initial bytes match the filter. The primary use for cursors is with a KVS storing segmented keys, where the length of the specified filter is equal to or greater than the key prefix length for that KVS. Used this way, cursors provide efficient iteration over sets of related KV pairs. Prefix deletes are used to atomically remove all KV pairs in a KVS with keys whose initial bytes match a specified filter. The length of the filter must be equal to the prefix.length parameter of the KVS. The primary use for prefix deletes is with a KVS storing segmented keys. This is a powerful capability that enables sets of related KV pairs to be deleted from a KVS in a single operation without cursor iteration. Transactions are used to execute a sequence of KV operations atomically. Transactions support operating on KV pairs in one or more KVSs in a KVDB. This allows storing multiple collections of KV pairs in different KVSs to optimize access, without giving up the ability to operate on any of those KV pairs within the context of a single transaction. Modeling Examples Below we present examples of applying the HSE data model to the real-world problem of storing and analyzing machine-generated data. Specifically, log data captured from datacenter servers. System logs are commonly retrieved from datacenter servers on a periodic basis and stored for both real-time and historical analysis. We examine several ways this data might be modeled, depending on how it will be accessed and managed. Simple Log Storage We start with a simple data model for storing log data in a KVDB. This model uses a single KVS with segmented keys as defined below, and values which are individual log records. Key offset Segment Length (bytes) Segment Name Description 0 8 sysID System identifier 8 8 ts Timestamp 16 2 typeID Log type identifier In this and later examples, segment names are for convenience of presentation (they do not exist in the HSE API), and segment lengths are representative. Also, partial or complete keys may be represented as tuples using segment names. For example, (sysId) , (sysID, ts) , or (sysID, ts, typeID) . We define the key prefix to be (sysID) , yielding a key prefix length of 8 bytes. Hence, we would create a KVS for storing these KV pairs with a key prefix length parameter ( prefix.length ) of 8 bytes. With this data model and KVS configuration, a cursor with the filter (sysID) can be used to efficiently iterate over the log records associated with the system sysID . Furthermore, the cursor can be used to efficiently seek to the first key (in the cursor's view) that is lexicographically equal to or greater than a (sysID, ts) , and then iterate from there. This data model makes it easy and efficient to search the log records associated with system sysID over an arbitrary time span. However, pruning those log records, for example to retain only those from the past 30 days, requires iterating over all older records and deleting them individually. Next we will look at enhancing this data model to make log record maintenance more efficient. Per-System Epoch-based Log Storage We extend the simple data model from above to include an epoch identifier representing a well-defined time interval. For example, an epoch might be four hours in length, with 6 epochs per day, 42 epochs per week, and so forth. We assume that a log record's timestamp can be mapped to a specific epoch through simple computation. We again use a single KVS but with segmented keys as defined below, and values which are individual log records. Key offset Segment Length (bytes) Segment Name Description 0 8 sysID System identifier 8 8 epochID Epoch identifier 16 8 ts Timestamp 24 2 typeID Log type identifier We define the key prefix to be (sysID, epochID) , yielding a key prefix length of 16 bytes. Hence, we would create a KVS for storing these KV pairs with a key prefix length parameter ( prefix.length ) of 16 bytes. With this data model and KVS configuration, a cursor with the filter (sysID, epochID) can be used to efficiently iterate over the log records associated with the system sysID within the epoch epochID . Furthermore, the cursor can be used to efficiently seek to the first key (in the cursor's view) that is lexicographically equal to or greater than (sysID, epochID, ts) , and then iterate from there within the epoch. With this revised data model, it is still easy and efficient to search the log records associated with system sysID over an arbitrary time span, though it is necessary to configure a cursor to iterate over each epoch of interest (e.g., to cross epoch boundaries). However, we can now prune log records very efficiently by using a single prefix delete to remove all KV pairs with a specified key prefix of (sysID, epochID) . Next we examine a variation on this per-system epoch-based data model. All-Systems Epoch-based Log Storage The previous data model makes it easy and efficient to iterate over the log records associated with a given sysID for a specified epochID . However, to view records from multiple systems for a specified epochID requires a cursor iteration per sysID of interest. We can instead group the log records for all systems within an epoch by using a KVS with segmented keys as defined below, and values which are individual log records. Key offset Segment Length (bytes) Segment Name Description 0 8 epochID Epoch identifier 8 8 ts Timestamp 16 8 sysID System identifier 24 2 typeID Log type identifier We define the key prefix to be (epochID) , yielding a key prefix length of 8 bytes. Hence we would create a KVS for storing these KV pairs with a key prefix length parameter ( prefix.length ) of 8 bytes. With this data model and KVS configuration, a cursor with the filter (epochID) can be used to efficiently iterate over the log records for all systems within the epoch epochID in timestamp order. Furthermore, the cursor can be used to efficiently seek to the first key (in the cursor's view) that is lexicographically equal to or greater than (epochID, ts) , and then iterate from there within the epoch. It should be clear that there is some loss of efficiency, versus the prior data model, to obtain all the log records associated with a specified sysID over an arbitrary time span, because records associated with systems other than sysID will be in the cursor's view and must be skipped. However, this is still a reasonably efficient query because it meets the criteria that the length of the cursor filter be equal to or greater than the key prefix length to achieve maximum performance. With this revised data model, pruning log records remains efficient because we can still use a single prefix delete to remove all KV pairs with a specified key prefix of (epochID) . In this case, the records for all systems in the epoch are pruned together. Tip This particular data model provides the opportunity to point out another best practice that can result in significantly greater performance. For a KVS storing segmented keys, it is important that the key prefix specified in put operations takes on a modest number of different values over a consecutive sequence of puts. For this example, that means choosing an epoch that is relatively short versus what one might select with the prior data model. Finally, we will examine an index-based data model for log storage. Index-based Log Storage The prior data models for log storage have the benefit of simplicity in that the KVDB has only a single KVS. However, they may provide less flexibility than required by the application. In this next example, we demonstrate how to use multiple KVSs to effectively index log records. For brevity, we define the key structure for each KVS using the tuple syntax, segment names, and segment lengths adopted in prior examples. KVS Name Key Type Key Key Prefix KVS prefix.length Value logRec segmented (epochID, ts, sysID, typeID) (epochID) 8 Log record content sysIdx segmented (sysID, epochID, ts, typeID) (sysID, epochID) 16 The KVS logRec stores the content of all log records, with each log record uniquely identified by the segmented key (epochID, ts, sysID, typeID) with key prefix (epochID) . Hence we would create KVS logRec with a key prefix length parameter ( prefix.length ) of 8 bytes. The KVS sysIdx is an index for the log records stored in KVS logRec , with a key pefix of (sysID, epochID) . Hence we would create KVS sysIdx with a key prefix length parameter ( prefix.length ) of 16 bytes. Using KVS logRec , a cursor with the filter (epochID) can be used to efficiently iterate over the log records for all systems within the epoch epochID in timestamp order. Furthermore, the cursor can be used to efficiently seek to the first key (in the cursor's view) that is lexicographically equal to or greater than (epochID, ts) , and then iterate from there within the epoch. Using KVS sysIdx , a cursor with the filter (sysID, epochID) can be used to efficiently iterate over the log records associated with the system sysID within the epoch epochID . Furthermore, the cursor can be used to efficiently seek to the first key (in the cursor's view) that is lexicographically equal to or greater than (sysID, epochID, ts) , and then iterate from there within the epoch. Note that KVS sysIdx does not contain any log record contents, and in fact stores no values at all (i.e., all value lengths are zero). To obtain the contents of a specific log record, there is the added step of a get operation in KVS logRec with key (epochID, ts, sysID, typeID) . The above schema accomplishes the following. Efficient iteration over the log records from all systems in a specified epoch using a cursor with KVS logRec . Efficient iteration over the log records from a specific system in a specified epoch using a cursor with KVS sysIdx . No duplication of log record content. A transaction can be used to atomically put (insert) KV pairs for a given log record in KVS logRec and KVS sysIdx . This guarantees integrity of the sysIdx index. Pruning log records is a bit more complex than the prior data models, bit still relatively straight-forward. To delete all log records for a given epochID , where the epoch is assumed to have passed, you would use a cursor with filter (epochID) to iterate over KVS logRec to build a list of all sysID in the epoch, and then in a single transaction, prefix delete each key prefix (sysID, epochID) from KVS sysIdx , and prefix delete the key prefix (epochID) from KVS logRec . Snapshots HSE uses multiversion concurrency control ( MVCC ) techniques to implement industry-standard snapshot isolation semantics for transactions and cursors. In this model, transactions and cursors operate on KVS snapshots in a KVDB. Conceptually, a KVS snapshot contains KV pairs from all transactions committed, or non-transaction operations completed, at the time the KVS snapshot is taken. A KVS snapshot is ephemeral and ceases to exist when all associated transaction and cursor operations complete. Transactions Transactions are used to execute a sequence of KV operations as a unit of work that is atomic, consistent, isolated, and durable ( ACID ). A transaction may operate on KV pairs in one or more KVSs in a KVDB. When a KVS is opened, the transactions.enabled parameter specifies whether or not that KVS supports transactions. This is not a persistent setting in that the KVS may be closed and later reopened in a different mode. The following table specifies the operations that may be performed on a KVS opened with transactions enabled or disabled, where: Read is a query operation, such as get or cursor iteration Update is a mutation operation, such as put, delete, or prefix delete KVS Transactions Enabled KVS Transactions Disabled Transaction Read Transaction Update Non-transaction Read Non-transaction Update Conceptually, when a transaction is initiated an instantaneous snapshot is taken of all KVSs in the specified KVDB for which transactions are enabled. The transaction may then be used to read or update KV pairs in these KVS snapshots. Snapshot isolation is enforced by failing update operations in a transaction that collide with updates in concurrent transactions, after which the transaction may be aborted and retried. In rare cases, the collision detection mechanism may produce false positives. HSE implements asynchronous (non-durable) transaction commits. Committed transactions are made durable via one of several durability controls . Cursors Cursors are used to iterate over keys in a KVS snapshot. A cursor can iterate over keys in forward or reverse lexicographic order. Cursors support an optional filter , which is a byte string limiting a cursor's view to only those keys in a KVS snapshot whose initial bytes match the filter. Tip Cursors deliver significantly greater performance when used with a KVS storing segmented keys, and where a filter is specified with a length equal to or greater than the key prefix length for that KVS. To the degree practical, you should structure applications to avoid using cursors outside of this use case. Furthermore, you should always use get operations instead of cursor seeks when iteration is not required. A cursor can be used to seek to the first key in the cursor's view that is lexicographically equal to or greater than a specified key. The interaction of cursor filters and seek is best described by example. Consider a KVS storing the following keys, which are listed in lexicographic order: \"ab001\", \"af001\", \"af002\", \"ap001\". If a cursor is created for the KVS with a filter of \"af\", then the cursor's view is limited to the keys: \"af001\", \"af002\". If that cursor is then used to seek to the key \"ab\", it will be positioned at the first key in its view equal to or greater than \"ab\", which is \"af001\". Iterating (reading) with the cursor will return the key \"af001\", then \"af002\", and then the EOF condition indicating there are no more keys in view. If instead the cursor is used to seek to the key \"ap\", it will be positioned past the last key in its view, such that an attempt to iterate (read) with the cursor will indicate an EOF condition. There are two types of cursors: non-transaction and transaction. A non-transaction cursor iterates over a KVS snapshot that is taken at the time the cursor is created. However, the cursor's view may be explicitly updated to the latest snapshot of the KVS at any time. A non-transaction cursor can be created for a KVS independent of whether the KVS was opened with transactions enabled or disabled. A transaction cursor iterates over a KVS snapshot associated with an active transaction, including any updates made in that transaction. If the transaction commits or aborts before the cursor is destroyed, the cursor's view reverts to the KVS snapshot taken at the time the transaction first became active. I.e., updates made in the transaction are no longer in the cursor's view. By definition a transaction cursor can only be created for a KVS opened with transactions enabled. A transaction cursor's view cannot be explicitly updated. Durability Controls HSE provides the hse_kvdb_sync() API call to flush cached KVDB updates to stable storage, either synchronously or asynchronously. All cached updates are flushed, whether from non-transaction operations or committed transactions. In the normal case where journaling is enabled ( durability.enabled ), cached updates are written to the journal on stable storage. Otherwise, cached updates are written directly to a KVDB media class on stable storage. HSE also supports automatically flushing cached KVDB updates to the journal on stable storage. The frequency for automatically flushing cached updates is controlled by the durability interval ( durability.interval_ms ) configured for a KVDB. Multithreading HSE supports highly-concurrent multithreaded applications, and most functions in the HSE API are thread-safe. However, there are a few exceptions, as documented in the API reference . Delete Semantics Delete operations logically remove KV pairs from a KVS. However, HSE implements physical removal as a background operation, and hence capacity is not freed immediately.","title":"Concepts"},{"location":"dev/concepts/#concepts","text":"The following describes HSE concepts that are important to understand for developing HSE applications and making effective use of the HSE API.","title":"Concepts"},{"location":"dev/concepts/#kvdb-and-kvs","text":"HSE provides functions to create and access a key-value database (KVDB). A KVDB comprises one or more named key-value stores (KVS), each of which is an independent collection of key-value (KV) pairs. A KVS is analogous to a table in a relational database. HSE provides the standard KV operators for managing KV pairs stored in a KVS: put, get, and delete. HSE also provides transactions, cursors, prefix deletes, and other advanced features. The HSE data model enables each KVS in a KVDB to be optimized for how the KV pairs it stores will be accessed.","title":"KVDB and KVS"},{"location":"dev/concepts/#data-model","text":"Understanding the HSE data model is fundamental to achieving maximum application performance. Adhering to the best practices of this data model can result in significantly greater performance than might be achieved otherwise. While this data model is simple, it has proven very effective.","title":"Data Model"},{"location":"dev/concepts/#key-structure","text":"To describe the HSE data model, we define the following terms. key \u2014 a byte string used to uniquely identify a value for storage, retrieval, and deletion in a KVS segmented key \u2014 a key that is logically divided into N segments, N >= 2 , arranged to group related KV pairs when keys are sorted lexicographically unsegmented key \u2014 a key not logically divided into segments For segmented keys, we further define the following. key prefix \u2014 the first K segments, 1 <= K < N , that group related KV pairs when keys are sorted lexicographically key prefix length \u2014 the length of a key prefix in bytes","title":"Key Structure"},{"location":"dev/concepts/#kvs-configuration","text":"In the common case where related sets of KV pairs are accessed together, best performance is generally achieved by: defining a segmented key with a key prefix such that KV pairs to be accessed together are grouped (contiguous) when keys are sorted lexicographically, and creating a KVS to store these KV pairs with a key prefix length parameter ( prefix.length ) equal to the key prefix length of the segmented key. In the case where there is no relationship between KV pairs, best performance is generally achieved by: defining an unsegmented key, and creating a KVS to store these KV pairs with a key prefix length parameter ( prefix.length ) of zero (0). Keep in mind that a KVDB may contain multiple KVSs. So in the case where there are multiple collections of KV pairs, each collection can be stored in a different KVS with a key structure, and corresponding KVS prefix.length parameter, that is appropriate for that collection. This is a powerful capability that enables HSE to optimize storage and access for all KV pairs in a KVDB without compromise.","title":"KVS Configuration"},{"location":"dev/concepts/#operation-support","text":"HSE provides several advanced operations with features that directly support the HSE data model. These operations are described in detail later, but we briefly discuss how they support the data model here. Cursors are used to iterate over keys in a KVS in forward or reverse lexicographic order. Cursors support an optional filter , which is a byte string limiting a cursor's view to only those keys whose initial bytes match the filter. The primary use for cursors is with a KVS storing segmented keys, where the length of the specified filter is equal to or greater than the key prefix length for that KVS. Used this way, cursors provide efficient iteration over sets of related KV pairs. Prefix deletes are used to atomically remove all KV pairs in a KVS with keys whose initial bytes match a specified filter. The length of the filter must be equal to the prefix.length parameter of the KVS. The primary use for prefix deletes is with a KVS storing segmented keys. This is a powerful capability that enables sets of related KV pairs to be deleted from a KVS in a single operation without cursor iteration. Transactions are used to execute a sequence of KV operations atomically. Transactions support operating on KV pairs in one or more KVSs in a KVDB. This allows storing multiple collections of KV pairs in different KVSs to optimize access, without giving up the ability to operate on any of those KV pairs within the context of a single transaction.","title":"Operation Support"},{"location":"dev/concepts/#modeling-examples","text":"Below we present examples of applying the HSE data model to the real-world problem of storing and analyzing machine-generated data. Specifically, log data captured from datacenter servers. System logs are commonly retrieved from datacenter servers on a periodic basis and stored for both real-time and historical analysis. We examine several ways this data might be modeled, depending on how it will be accessed and managed.","title":"Modeling Examples"},{"location":"dev/concepts/#simple-log-storage","text":"We start with a simple data model for storing log data in a KVDB. This model uses a single KVS with segmented keys as defined below, and values which are individual log records. Key offset Segment Length (bytes) Segment Name Description 0 8 sysID System identifier 8 8 ts Timestamp 16 2 typeID Log type identifier In this and later examples, segment names are for convenience of presentation (they do not exist in the HSE API), and segment lengths are representative. Also, partial or complete keys may be represented as tuples using segment names. For example, (sysId) , (sysID, ts) , or (sysID, ts, typeID) . We define the key prefix to be (sysID) , yielding a key prefix length of 8 bytes. Hence, we would create a KVS for storing these KV pairs with a key prefix length parameter ( prefix.length ) of 8 bytes. With this data model and KVS configuration, a cursor with the filter (sysID) can be used to efficiently iterate over the log records associated with the system sysID . Furthermore, the cursor can be used to efficiently seek to the first key (in the cursor's view) that is lexicographically equal to or greater than a (sysID, ts) , and then iterate from there. This data model makes it easy and efficient to search the log records associated with system sysID over an arbitrary time span. However, pruning those log records, for example to retain only those from the past 30 days, requires iterating over all older records and deleting them individually. Next we will look at enhancing this data model to make log record maintenance more efficient.","title":"Simple Log Storage"},{"location":"dev/concepts/#per-system-epoch-based-log-storage","text":"We extend the simple data model from above to include an epoch identifier representing a well-defined time interval. For example, an epoch might be four hours in length, with 6 epochs per day, 42 epochs per week, and so forth. We assume that a log record's timestamp can be mapped to a specific epoch through simple computation. We again use a single KVS but with segmented keys as defined below, and values which are individual log records. Key offset Segment Length (bytes) Segment Name Description 0 8 sysID System identifier 8 8 epochID Epoch identifier 16 8 ts Timestamp 24 2 typeID Log type identifier We define the key prefix to be (sysID, epochID) , yielding a key prefix length of 16 bytes. Hence, we would create a KVS for storing these KV pairs with a key prefix length parameter ( prefix.length ) of 16 bytes. With this data model and KVS configuration, a cursor with the filter (sysID, epochID) can be used to efficiently iterate over the log records associated with the system sysID within the epoch epochID . Furthermore, the cursor can be used to efficiently seek to the first key (in the cursor's view) that is lexicographically equal to or greater than (sysID, epochID, ts) , and then iterate from there within the epoch. With this revised data model, it is still easy and efficient to search the log records associated with system sysID over an arbitrary time span, though it is necessary to configure a cursor to iterate over each epoch of interest (e.g., to cross epoch boundaries). However, we can now prune log records very efficiently by using a single prefix delete to remove all KV pairs with a specified key prefix of (sysID, epochID) . Next we examine a variation on this per-system epoch-based data model.","title":"Per-System Epoch-based Log Storage"},{"location":"dev/concepts/#all-systems-epoch-based-log-storage","text":"The previous data model makes it easy and efficient to iterate over the log records associated with a given sysID for a specified epochID . However, to view records from multiple systems for a specified epochID requires a cursor iteration per sysID of interest. We can instead group the log records for all systems within an epoch by using a KVS with segmented keys as defined below, and values which are individual log records. Key offset Segment Length (bytes) Segment Name Description 0 8 epochID Epoch identifier 8 8 ts Timestamp 16 8 sysID System identifier 24 2 typeID Log type identifier We define the key prefix to be (epochID) , yielding a key prefix length of 8 bytes. Hence we would create a KVS for storing these KV pairs with a key prefix length parameter ( prefix.length ) of 8 bytes. With this data model and KVS configuration, a cursor with the filter (epochID) can be used to efficiently iterate over the log records for all systems within the epoch epochID in timestamp order. Furthermore, the cursor can be used to efficiently seek to the first key (in the cursor's view) that is lexicographically equal to or greater than (epochID, ts) , and then iterate from there within the epoch. It should be clear that there is some loss of efficiency, versus the prior data model, to obtain all the log records associated with a specified sysID over an arbitrary time span, because records associated with systems other than sysID will be in the cursor's view and must be skipped. However, this is still a reasonably efficient query because it meets the criteria that the length of the cursor filter be equal to or greater than the key prefix length to achieve maximum performance. With this revised data model, pruning log records remains efficient because we can still use a single prefix delete to remove all KV pairs with a specified key prefix of (epochID) . In this case, the records for all systems in the epoch are pruned together. Tip This particular data model provides the opportunity to point out another best practice that can result in significantly greater performance. For a KVS storing segmented keys, it is important that the key prefix specified in put operations takes on a modest number of different values over a consecutive sequence of puts. For this example, that means choosing an epoch that is relatively short versus what one might select with the prior data model. Finally, we will examine an index-based data model for log storage.","title":"All-Systems Epoch-based Log Storage"},{"location":"dev/concepts/#index-based-log-storage","text":"The prior data models for log storage have the benefit of simplicity in that the KVDB has only a single KVS. However, they may provide less flexibility than required by the application. In this next example, we demonstrate how to use multiple KVSs to effectively index log records. For brevity, we define the key structure for each KVS using the tuple syntax, segment names, and segment lengths adopted in prior examples. KVS Name Key Type Key Key Prefix KVS prefix.length Value logRec segmented (epochID, ts, sysID, typeID) (epochID) 8 Log record content sysIdx segmented (sysID, epochID, ts, typeID) (sysID, epochID) 16 The KVS logRec stores the content of all log records, with each log record uniquely identified by the segmented key (epochID, ts, sysID, typeID) with key prefix (epochID) . Hence we would create KVS logRec with a key prefix length parameter ( prefix.length ) of 8 bytes. The KVS sysIdx is an index for the log records stored in KVS logRec , with a key pefix of (sysID, epochID) . Hence we would create KVS sysIdx with a key prefix length parameter ( prefix.length ) of 16 bytes. Using KVS logRec , a cursor with the filter (epochID) can be used to efficiently iterate over the log records for all systems within the epoch epochID in timestamp order. Furthermore, the cursor can be used to efficiently seek to the first key (in the cursor's view) that is lexicographically equal to or greater than (epochID, ts) , and then iterate from there within the epoch. Using KVS sysIdx , a cursor with the filter (sysID, epochID) can be used to efficiently iterate over the log records associated with the system sysID within the epoch epochID . Furthermore, the cursor can be used to efficiently seek to the first key (in the cursor's view) that is lexicographically equal to or greater than (sysID, epochID, ts) , and then iterate from there within the epoch. Note that KVS sysIdx does not contain any log record contents, and in fact stores no values at all (i.e., all value lengths are zero). To obtain the contents of a specific log record, there is the added step of a get operation in KVS logRec with key (epochID, ts, sysID, typeID) . The above schema accomplishes the following. Efficient iteration over the log records from all systems in a specified epoch using a cursor with KVS logRec . Efficient iteration over the log records from a specific system in a specified epoch using a cursor with KVS sysIdx . No duplication of log record content. A transaction can be used to atomically put (insert) KV pairs for a given log record in KVS logRec and KVS sysIdx . This guarantees integrity of the sysIdx index. Pruning log records is a bit more complex than the prior data models, bit still relatively straight-forward. To delete all log records for a given epochID , where the epoch is assumed to have passed, you would use a cursor with filter (epochID) to iterate over KVS logRec to build a list of all sysID in the epoch, and then in a single transaction, prefix delete each key prefix (sysID, epochID) from KVS sysIdx , and prefix delete the key prefix (epochID) from KVS logRec .","title":"Index-based Log Storage"},{"location":"dev/concepts/#snapshots","text":"HSE uses multiversion concurrency control ( MVCC ) techniques to implement industry-standard snapshot isolation semantics for transactions and cursors. In this model, transactions and cursors operate on KVS snapshots in a KVDB. Conceptually, a KVS snapshot contains KV pairs from all transactions committed, or non-transaction operations completed, at the time the KVS snapshot is taken. A KVS snapshot is ephemeral and ceases to exist when all associated transaction and cursor operations complete.","title":"Snapshots"},{"location":"dev/concepts/#transactions","text":"Transactions are used to execute a sequence of KV operations as a unit of work that is atomic, consistent, isolated, and durable ( ACID ). A transaction may operate on KV pairs in one or more KVSs in a KVDB. When a KVS is opened, the transactions.enabled parameter specifies whether or not that KVS supports transactions. This is not a persistent setting in that the KVS may be closed and later reopened in a different mode. The following table specifies the operations that may be performed on a KVS opened with transactions enabled or disabled, where: Read is a query operation, such as get or cursor iteration Update is a mutation operation, such as put, delete, or prefix delete KVS Transactions Enabled KVS Transactions Disabled Transaction Read Transaction Update Non-transaction Read Non-transaction Update Conceptually, when a transaction is initiated an instantaneous snapshot is taken of all KVSs in the specified KVDB for which transactions are enabled. The transaction may then be used to read or update KV pairs in these KVS snapshots. Snapshot isolation is enforced by failing update operations in a transaction that collide with updates in concurrent transactions, after which the transaction may be aborted and retried. In rare cases, the collision detection mechanism may produce false positives. HSE implements asynchronous (non-durable) transaction commits. Committed transactions are made durable via one of several durability controls .","title":"Transactions"},{"location":"dev/concepts/#cursors","text":"Cursors are used to iterate over keys in a KVS snapshot. A cursor can iterate over keys in forward or reverse lexicographic order. Cursors support an optional filter , which is a byte string limiting a cursor's view to only those keys in a KVS snapshot whose initial bytes match the filter. Tip Cursors deliver significantly greater performance when used with a KVS storing segmented keys, and where a filter is specified with a length equal to or greater than the key prefix length for that KVS. To the degree practical, you should structure applications to avoid using cursors outside of this use case. Furthermore, you should always use get operations instead of cursor seeks when iteration is not required. A cursor can be used to seek to the first key in the cursor's view that is lexicographically equal to or greater than a specified key. The interaction of cursor filters and seek is best described by example. Consider a KVS storing the following keys, which are listed in lexicographic order: \"ab001\", \"af001\", \"af002\", \"ap001\". If a cursor is created for the KVS with a filter of \"af\", then the cursor's view is limited to the keys: \"af001\", \"af002\". If that cursor is then used to seek to the key \"ab\", it will be positioned at the first key in its view equal to or greater than \"ab\", which is \"af001\". Iterating (reading) with the cursor will return the key \"af001\", then \"af002\", and then the EOF condition indicating there are no more keys in view. If instead the cursor is used to seek to the key \"ap\", it will be positioned past the last key in its view, such that an attempt to iterate (read) with the cursor will indicate an EOF condition. There are two types of cursors: non-transaction and transaction. A non-transaction cursor iterates over a KVS snapshot that is taken at the time the cursor is created. However, the cursor's view may be explicitly updated to the latest snapshot of the KVS at any time. A non-transaction cursor can be created for a KVS independent of whether the KVS was opened with transactions enabled or disabled. A transaction cursor iterates over a KVS snapshot associated with an active transaction, including any updates made in that transaction. If the transaction commits or aborts before the cursor is destroyed, the cursor's view reverts to the KVS snapshot taken at the time the transaction first became active. I.e., updates made in the transaction are no longer in the cursor's view. By definition a transaction cursor can only be created for a KVS opened with transactions enabled. A transaction cursor's view cannot be explicitly updated.","title":"Cursors"},{"location":"dev/concepts/#durability-controls","text":"HSE provides the hse_kvdb_sync() API call to flush cached KVDB updates to stable storage, either synchronously or asynchronously. All cached updates are flushed, whether from non-transaction operations or committed transactions. In the normal case where journaling is enabled ( durability.enabled ), cached updates are written to the journal on stable storage. Otherwise, cached updates are written directly to a KVDB media class on stable storage. HSE also supports automatically flushing cached KVDB updates to the journal on stable storage. The frequency for automatically flushing cached updates is controlled by the durability interval ( durability.interval_ms ) configured for a KVDB.","title":"Durability Controls"},{"location":"dev/concepts/#multithreading","text":"HSE supports highly-concurrent multithreaded applications, and most functions in the HSE API are thread-safe. However, there are a few exceptions, as documented in the API reference .","title":"Multithreading"},{"location":"dev/concepts/#delete-semantics","text":"Delete operations logically remove KV pairs from a KVS. However, HSE implements physical removal as a background operation, and hence capacity is not freed immediately.","title":"Delete Semantics"},{"location":"dev/limits/","text":"Limits The tables below provide guidance on HSE operating limits. A few are enforced, but most are based on testing and experience. The limits appropriate for a specific HSE application are largely dependent on the performance requirements of that application, and the hardware it runs on. Feel free to push these limits in testing and let us know how far you get and what you observe. KVDB Limits Entity Description Limit Enforced KVDB count Active KVDB per system 8 No KVS count KVSs in a KVDB 16 No Key count Total keys in a KVDB (billions) 200 No Capacity Total storage capacity of a KVDB (TB) 12 No Transaction count Concurrent transactions in a KVDB 1,000 per CPU Yes Cursor count Concurrent cursors in a KVDB 10,000 No Info An application can only have a single KVDB open at a time. We expect to remove this limitation in a later release. KVS Limits Entity Description Limit Enforced Key size Range of valid key sizes (bytes) 1 \u2013 1,334 Yes Value size Range of valid value sizes (bytes) 0 \u2013 1MiB Yes Key count Total keys in a KVS (billions) 50 No Capacity Total storage capacity of a KVS (TB) 4 No Cursor count Concurrent cursors in a KVS 8,000 No","title":"Limits"},{"location":"dev/limits/#limits","text":"The tables below provide guidance on HSE operating limits. A few are enforced, but most are based on testing and experience. The limits appropriate for a specific HSE application are largely dependent on the performance requirements of that application, and the hardware it runs on. Feel free to push these limits in testing and let us know how far you get and what you observe.","title":"Limits"},{"location":"dev/limits/#kvdb-limits","text":"Entity Description Limit Enforced KVDB count Active KVDB per system 8 No KVS count KVSs in a KVDB 16 No Key count Total keys in a KVDB (billions) 200 No Capacity Total storage capacity of a KVDB (TB) 12 No Transaction count Concurrent transactions in a KVDB 1,000 per CPU Yes Cursor count Concurrent cursors in a KVDB 10,000 No Info An application can only have a single KVDB open at a time. We expect to remove this limitation in a later release.","title":"KVDB Limits"},{"location":"dev/limits/#kvs-limits","text":"Entity Description Limit Enforced Key size Range of valid key sizes (bytes) 1 \u2013 1,334 Yes Value size Range of valid value sizes (bytes) 0 \u2013 1MiB Yes Key count Total keys in a KVS (billions) 50 No Capacity Total storage capacity of a KVS (TB) 4 No Cursor count Concurrent cursors in a KVS 8,000 No","title":"KVS Limits"},{"location":"gs/about/","text":"About HSE is a fast embeddable key-value store designed for SSDs and persistent memory. It is implemented as a C library that links with your application, directly or via alternate language bindings. Overview HSE provides functions to create and access a key-value database (KVDB). A KVDB comprises one or more named key-value stores (KVS), each of which is an independent collection of key-value pairs. A KVS is analogous to a table in a relational database. The HSE data model enables each KVS in a KVDB to be optimized for how the key-value pairs it stores will be accessed. HSE provides the standard operators for managing key-value pairs in a KVS: put, get, and delete. HSE also provides transactions, cursors, prefix deletes, and other advanced features. Details on the HSE programming and data models can be found here . Details on how KVDB data is stored in file systems can be found here . Project Repos The HSE project includes the following repos: hse contains the HSE library source hse-python contains HSE Python bindings hse-mongo is a fork that integrates HSE with MongoDB hse-ycsb is a fork that integrates HSE with the YCSB benchmark rfcs contains RFCs for major enhancements to the HSE library or other project components hse-project.github.io contains the source for this documentation Instructions for building, installing, and contributing to repo contents are in their local README.md and CONTRIBUTING.md files. Forked repos, such as hse-mongo and hse-ycsb , contain this information in README.md and CONTRIBUTING.md files in the hse directory within those repos. To make these easy to locate, there are symlinks to them named README_HSE.md and CONTRIBUTING_HSE.md in the repo root directory. Using HSE After building and installing the hse repo, you can develop HSE applications in C/C++ by including the hse.h header file and linking with libhse-2 . Information on using an alternate HSE language binding is included in its associated repo. Releases See the release section of each HSE project repo for specific releases and associated release notes. For example, hse releases can be found here . Releases of the HSE library and associated language bindings use semantic versioning . Releases of forked repos use a versioning scheme that is documented in their associated README.md .","title":"About"},{"location":"gs/about/#about","text":"HSE is a fast embeddable key-value store designed for SSDs and persistent memory. It is implemented as a C library that links with your application, directly or via alternate language bindings.","title":"About"},{"location":"gs/about/#overview","text":"HSE provides functions to create and access a key-value database (KVDB). A KVDB comprises one or more named key-value stores (KVS), each of which is an independent collection of key-value pairs. A KVS is analogous to a table in a relational database. The HSE data model enables each KVS in a KVDB to be optimized for how the key-value pairs it stores will be accessed. HSE provides the standard operators for managing key-value pairs in a KVS: put, get, and delete. HSE also provides transactions, cursors, prefix deletes, and other advanced features. Details on the HSE programming and data models can be found here . Details on how KVDB data is stored in file systems can be found here .","title":"Overview"},{"location":"gs/about/#project-repos","text":"The HSE project includes the following repos: hse contains the HSE library source hse-python contains HSE Python bindings hse-mongo is a fork that integrates HSE with MongoDB hse-ycsb is a fork that integrates HSE with the YCSB benchmark rfcs contains RFCs for major enhancements to the HSE library or other project components hse-project.github.io contains the source for this documentation Instructions for building, installing, and contributing to repo contents are in their local README.md and CONTRIBUTING.md files. Forked repos, such as hse-mongo and hse-ycsb , contain this information in README.md and CONTRIBUTING.md files in the hse directory within those repos. To make these easy to locate, there are symlinks to them named README_HSE.md and CONTRIBUTING_HSE.md in the repo root directory.","title":"Project Repos"},{"location":"gs/about/#using-hse","text":"After building and installing the hse repo, you can develop HSE applications in C/C++ by including the hse.h header file and linking with libhse-2 . Information on using an alternate HSE language binding is included in its associated repo.","title":"Using HSE"},{"location":"gs/about/#releases","text":"See the release section of each HSE project repo for specific releases and associated release notes. For example, hse releases can be found here . Releases of the HSE library and associated language bindings use semantic versioning . Releases of forked repos use a versioning scheme that is documented in their associated README.md .","title":"Releases"},{"location":"gs/cli/","text":"Command Line Interface Applications will normally use the HSE API to create and manage a KVDB. However, the HSE command line interface (CLI) can also be used for these tasks. The CLI is itself an HSE application. Below are several usage examples which assume the following. /var/bulk is a file system on storage suitable for a capacity media class /var/fast is a file system on storage suitable for a staging media class See the discussion on KVDB storage for more details on media classes. Create a KVDB Create a KVDB taking all the defaults. mkdir /var/bulk/kvdb1 hse kvdb create /var/bulk/kvdb1 The KVDB home directory is /var/bulk/kvdb1 , and the required capacity media class directory defaults to /var/bulk/kvdb1/capacity . Next, create a KVDB specifying parameters for both the required capacity and optional staging media class directories. mkdir /var/bulk/kvdb2 mkdir /var/bulk/capacity2 mkdir /var/fast/staging2 hse kvdb create /var/bulk/kvdb2 storage.capacity.path = ../capacity2 storage.staging.path = /var/fast/staging2 The KVDB home directory is /var/bulk/kvdb2 , the capacity media class directory is /var/bulk/capacity2 , and the staging media class directory is /var/fast/staging2 . Media class directory paths can be relative to the KVDB home directory or absolute, as in this example for the capacity and staging media class directories, respectively. Create a KVS Create a KVS in a KVDB taking all the defaults. hse kvs create /var/bulk/kvdb1 kvs1 The KVS named kvs1 is created in KVDB home directory /var/bulk/kvdb1 . KVS kvs1 is created with the default key prefix length ( prefix.length ) of zero (0). Next, create a KVS specifying the key prefix length. hse kvs create /var/bulk/kvdb2 kvs1 prefix.length = 8 The KVS named kvs1 is created in KVDB home directory /var/bulk/kvdb2 . KVS kvs1 is created with the specified key prefix length of 8 bytes. Get KVDB Info Get general information about a KVDB. hse kvdb info /var/bulk/kvdb1 This command displays general information for the KVDB home directory /var/bulk/kvdb1 , including its KVS list. Get KVDB Storage Info Get information about the media classes configured for a KVDB. hse storage info /var/bulk/kvdb1 This command displays media class information for the KVDB home directory /var/bulk/kvdb1 , including storage space metrics. These storage space metrics include: Total space in the file systems hosting the KVDB media classes Available space in the file systems hosting the KVDB media classes Space allocated for the KVDB Space used by the KVDB, which is always less than or equal to the allocated space Profile KVDB Storage Profile the capacity media class storage for a KVDB to determine the appropriate throttling.init_policy parameter value for that KVDB. hse storage profile /var/bulk Here we specify /var/bulk as the storage path to profile because it is the file system storing the capacity media class for all KVDBs in these examples. Add a KVDB Media Class Add a staging media class to an existing KVDB. mkdir /var/fast/staging1 hse storage add /var/bulk/kvdb1 storage.staging.path = /var/fast/staging1 The staging media class directory /var/fast/staging1 is configured for the KVDB home directory /var/bulk/kvdb1 . This command can only be used to add a staging media class to a KVDB. The command will fail if either the KVDB already has a staging media class or if an application has the KVDB open. The next time an application opens the KVDB, the newly added staging media class will be used for KVS storage as determined by the mclass.policy parameter for each KVS. Compact a KVDB HSE implements the physical removal of logically deleted data via a background operation called compaction. Though generally not required, compaction can be initiated manually. Be aware that compaction can take several minutes or longer depending on the amount of data stored in the KVDB, among many other factors, so a timeout can be specified in seconds. hse kvdb compact --timeout 120 /var/bulk/kvdb1 The KVDB home directory is /var/bulk/kvdb1 , and compaction is started with a timeout of 120 seconds. If an application has the KVDB open, the compaction may continue past the timeout value. In this case, the status of the compaction can be queried. hse kvdb compact --status /var/bulk/kvdb1 A compaction operation can also be canceled. hse kvdb compact --cancel /var/bulk/kvdb1 Drop a KVS Drop (delete) a KVS in a KVDB. hse kvs drop /var/bulk/kvdb2 kvs1 The KVS named kvs1 is dropped from the KVDB home directory /var/bulk/kvdb2 . Drop a KVDB Drop (delete) a KVDB and all of its KVSs. hse kvdb drop /var/bulk/kvdb1 hse kvdb drop /var/bulk/kvdb2 The KVDBs with home directories /var/bulk/kvdb1 and /var/bulk/kvdb2 are dropped.","title":"Command Line Interface"},{"location":"gs/cli/#command-line-interface","text":"Applications will normally use the HSE API to create and manage a KVDB. However, the HSE command line interface (CLI) can also be used for these tasks. The CLI is itself an HSE application. Below are several usage examples which assume the following. /var/bulk is a file system on storage suitable for a capacity media class /var/fast is a file system on storage suitable for a staging media class See the discussion on KVDB storage for more details on media classes.","title":"Command Line Interface"},{"location":"gs/cli/#create-a-kvdb","text":"Create a KVDB taking all the defaults. mkdir /var/bulk/kvdb1 hse kvdb create /var/bulk/kvdb1 The KVDB home directory is /var/bulk/kvdb1 , and the required capacity media class directory defaults to /var/bulk/kvdb1/capacity . Next, create a KVDB specifying parameters for both the required capacity and optional staging media class directories. mkdir /var/bulk/kvdb2 mkdir /var/bulk/capacity2 mkdir /var/fast/staging2 hse kvdb create /var/bulk/kvdb2 storage.capacity.path = ../capacity2 storage.staging.path = /var/fast/staging2 The KVDB home directory is /var/bulk/kvdb2 , the capacity media class directory is /var/bulk/capacity2 , and the staging media class directory is /var/fast/staging2 . Media class directory paths can be relative to the KVDB home directory or absolute, as in this example for the capacity and staging media class directories, respectively.","title":"Create a KVDB"},{"location":"gs/cli/#create-a-kvs","text":"Create a KVS in a KVDB taking all the defaults. hse kvs create /var/bulk/kvdb1 kvs1 The KVS named kvs1 is created in KVDB home directory /var/bulk/kvdb1 . KVS kvs1 is created with the default key prefix length ( prefix.length ) of zero (0). Next, create a KVS specifying the key prefix length. hse kvs create /var/bulk/kvdb2 kvs1 prefix.length = 8 The KVS named kvs1 is created in KVDB home directory /var/bulk/kvdb2 . KVS kvs1 is created with the specified key prefix length of 8 bytes.","title":"Create a KVS"},{"location":"gs/cli/#get-kvdb-info","text":"Get general information about a KVDB. hse kvdb info /var/bulk/kvdb1 This command displays general information for the KVDB home directory /var/bulk/kvdb1 , including its KVS list.","title":"Get KVDB Info"},{"location":"gs/cli/#get-kvdb-storage-info","text":"Get information about the media classes configured for a KVDB. hse storage info /var/bulk/kvdb1 This command displays media class information for the KVDB home directory /var/bulk/kvdb1 , including storage space metrics. These storage space metrics include: Total space in the file systems hosting the KVDB media classes Available space in the file systems hosting the KVDB media classes Space allocated for the KVDB Space used by the KVDB, which is always less than or equal to the allocated space","title":"Get KVDB Storage Info"},{"location":"gs/cli/#profile-kvdb-storage","text":"Profile the capacity media class storage for a KVDB to determine the appropriate throttling.init_policy parameter value for that KVDB. hse storage profile /var/bulk Here we specify /var/bulk as the storage path to profile because it is the file system storing the capacity media class for all KVDBs in these examples.","title":"Profile KVDB Storage"},{"location":"gs/cli/#add-a-kvdb-media-class","text":"Add a staging media class to an existing KVDB. mkdir /var/fast/staging1 hse storage add /var/bulk/kvdb1 storage.staging.path = /var/fast/staging1 The staging media class directory /var/fast/staging1 is configured for the KVDB home directory /var/bulk/kvdb1 . This command can only be used to add a staging media class to a KVDB. The command will fail if either the KVDB already has a staging media class or if an application has the KVDB open. The next time an application opens the KVDB, the newly added staging media class will be used for KVS storage as determined by the mclass.policy parameter for each KVS.","title":"Add a KVDB Media Class"},{"location":"gs/cli/#compact-a-kvdb","text":"HSE implements the physical removal of logically deleted data via a background operation called compaction. Though generally not required, compaction can be initiated manually. Be aware that compaction can take several minutes or longer depending on the amount of data stored in the KVDB, among many other factors, so a timeout can be specified in seconds. hse kvdb compact --timeout 120 /var/bulk/kvdb1 The KVDB home directory is /var/bulk/kvdb1 , and compaction is started with a timeout of 120 seconds. If an application has the KVDB open, the compaction may continue past the timeout value. In this case, the status of the compaction can be queried. hse kvdb compact --status /var/bulk/kvdb1 A compaction operation can also be canceled. hse kvdb compact --cancel /var/bulk/kvdb1","title":"Compact a KVDB"},{"location":"gs/cli/#drop-a-kvs","text":"Drop (delete) a KVS in a KVDB. hse kvs drop /var/bulk/kvdb2 kvs1 The KVS named kvs1 is dropped from the KVDB home directory /var/bulk/kvdb2 .","title":"Drop a KVS"},{"location":"gs/cli/#drop-a-kvdb","text":"Drop (delete) a KVDB and all of its KVSs. hse kvdb drop /var/bulk/kvdb1 hse kvdb drop /var/bulk/kvdb2 The KVDBs with home directories /var/bulk/kvdb1 and /var/bulk/kvdb2 are dropped.","title":"Drop a KVDB"},{"location":"gs/params/","text":"Configuration Parameters HSE defines global, KVDB, and KVS configuration parameters as described below. These are classified as either create-time parameters, which apply when an application creates a KVDB or KVS, or runtime parameters, which apply each time an application initializes the HSE library or opens a KVDB or KVS. In addition to the detailed descriptions below, you can find parameter usage examples in the API reference , CLI reference , and HSE sample programs . Global Parameters Global parameters are runtime parameters that apply at the application level. These parameters may be specified in the hse_init() API call or in the optional hse.conf JSON file, which is also specified in hse_init() . For hse_init() API calls, specify global parameters in the form <param>=<value> . For example, socket.enabled=false . The following global parameters are part of the stable API. Parameter Default Description logging.enabled true Logging mode (false==disabled, true==enabled) logging.structured false Logging style (false==basic, true==structured) logging.destination syslog Log destination (stdout, stderr, file, syslog) logging.path $PWD/hse.log Log file when logging.destination==file logging.level 7 Logging severity level (0==emergency; 7==debug) socket.enabled true REST interface mode (false==disabled, true==enabled) socket.path /tmp/hse-<pid>.sock UNIX domain socket file when socket.enabled==true KVDB Parameters KVDB parameters apply when a KVDB is created or opened. KVDB Create-time Parameters KVDB create-time parameters may be specified in the hse_kvdb_create() API call or when using the CLI to create a KVDB. In either case, specify KVDB create-time parameters in the form <param>=<value> . For example, storage.capacity.path=/path/to/capacity/dir . The following KVDB create-time parameters are part of the stable API. Parameter Default Description storage.capacity.path <KVDB home>/capacity Capacity media class directory storage.staging.path null Staging media class directory KVDB Runtime Parameters KVDB runtime parameters may be specified in the hse_kvdb_open() API call or in the optional kvdb.conf JSON file in the KVDB home directory, which is also specified in hse_kvdb_open() . For hse_kvdb_open() API calls, specify KVDB runtime parameters in the form <param>=<value> . For example, durability.interval_ms=1000 . The following KVDB runtime parameters are part of the stable API. Parameter Default Description read_only false Access mode (false==read/write, true==read-only) durability.enabled true Journaling mode (false==disabled, true==enabled) durability.interval_ms 100 Max time data is cached (in milliseconds) when durability.enabled==true durability.mclass capacity Media class for journal (capacity, staging) throttling.init_policy default Ingest throttle at startup (light, medium, default) Durability Settings The KVDB durability parameters control how HSE journals updates for that KVDB to provide for recovery in the event of a failure. The parameter durability.enabled determines whether or not journaling is enabled. In general, you should always set this to true . As a rare exception, applications that implement their own form of durability may want to disable HSE journaling to increase performance. The parameter durability.interval_ms specifies the frequency (in milliseconds) for automatically flushing cached updates to the journal on stable storage. Increasing this value may improve performance but also increases the amount of data that may be lost in the event of a failure. The parameter durability.mclass specifies the media class for storing journal files. In general, best performance is achieved by storing the journal files on the fastest media class configured for a KVDB. See the discussion on HSE durability controls for additional details. Initial Throttle Setting On startup, HSE throttles the rate at which it processes updates in a KVDB, referred to as the ingest rate . HSE increases the ingest rate for the KVDB until it reaches the maximum sustainable value for the underlying storage. This ramp-up process can take up to 200 seconds . For benchmarks, this initial throttling can greatly distort results. In general operation, this initial throttling may impact the time before a service is fully operational. The throttling.init_policy parameter can be used to achieve the maximum ingest rate in far less time. It specifies a relative initial throttling value of light (minimum), medium , or default (maximum) throttling. Setting the throttling.init_policy parameter improperly for the underlying storage can cause the durability interval ( durability.interval_ms ) to be violated or internal indexing structures to become unbalanced for a period of time. For example, this may occur if throttling.init_policy is set to light with relatively slow KVDB storage. The CLI provides a command to determine the appropriate throttling.init_policy setting for your KVDB storage. You can run it as follows. hse storage profile /path/to/capacity/storage/for/the/kvdb The path specified in hse storage profile should be a directory in the file system hosting the capacity media class for the KVDB of interest. Use the output of hse storage profile to specify the throttling.init_policy value for that KVDB. KVS Parameters KVS parameters apply when a KVS is created or opened. KVS Create-time Parameters KVS create-time parameters may be specified in the hse_kvdb_kvs_create() API call or when using the CLI to create a KVS. In either case, specify KVS create-time parameters in the form <param>=<value> . For example, prefix.length=8 . The following KVS create-time parameters are part of the stable API. Parameter Default Description prefix.length 0 Key prefix length (bytes) Tip The KVS name default is reserved and may not be used in hse_kvdb_kvs_create() API calls or with the CLI. KVS Runtime Parameters KVS runtime parameters may be specified in the hse_kvdb_kvs_open() API call or in the optional kvdb.conf configuration file in the KVDB home directory, which is also specified in hse_kvdb_open() . For hse_kvdb_kvs_open() API calls, specify KVS runtime parameters in the form <param>=<value> . For example, compression.value.algorithm=lz4 . The following KVS runtime parameters are part of the stable API. Parameter Default Description transactions.enabled false Transaction mode (false==disabled, true==enabled) mclass.policy capacity_only See discussion below for values compression.value.algorithm none Value compression method (none, lz4) compression.value.min_length 12 Value length above which compression is attempted (bytes) Transaction Mode When a KVS is opened, the transactions.enabled value determines whether or not transactions are enabled for the KVS. This mode may be changed by closing and reopening the KVS. See the discussion on HSE transactions for additional details. Media Class Usage The media class usage policy for a KVS defines how the key-value data in that KVS is stored and managed in a KVDB configured with a staging media class. Key-value data in a KVS can either be pinned to a particular media class, or tiered from the staging media class to the capacity media class as it ages, as determined by the mclass.policy value for the KVS: capacity_only pins all key-value data to the capacity media class staging_only pins all key-value data to the staging media class staging_min_capacity tiers all key-value data staging_max_capacity pins all key data to the staging media class and tiers all value data Of the two tiering options, staging_max_capacity will generally yield the highest throughput, lowest latency, and least write-amplification in the capacity media class. The trade-off is more storage required in the staging media class. Info If no staging media class is present, and an mclass.policy value other than capacity_only is specified, a warning is logged and capacity_only is applied. Configuration Files The following are the JSON file formats for the optional HSE configuration files. hse.conf JSON File See the discussion on global parameters for definitions, legal values, and defaults. { \"logging\": { \"enabled\": boolean, \"structured\": boolean, \"destination\": \"stdout | stderr | file | syslog\", \"path\": \"/log/file/path\", \"level\": integer }, \"socket\": { \"enabled\": boolean, \"path\": \"/UNIX/socket/file/path\" } } kvdb.conf JSON File See the discussions on KVDB runtime parameters and KVS runtime parameters for definitions, legal values, and defaults. { \"read_only\": boolean, \"durability\": { \"enabled\": boolean, \"interval\": integer, \"mclass\": \"capacity | staging\" }, \"throttling\": { \"init_policy\": \"light | medium | default\" }, \"kvs\": { \"<kvs name>\": { \"transactions\": { \"enabled\": boolean }, \"mclass\": { \"policy\": \"see KVS runtime parameter discussion for value strings\" }, \"compression\": { \"value\": { \"algorithm\": \"lz4 | none\", \"min_length\": integer } } } } } The KVS name default is reserved and its parameters apply to all the KVS in a KVDB. Parameters specified for a named KVS override those specified via default . Precedence of Parameters The final value for a specific configuration parameter is determined of follows: The built-in default value is applied first The value is then overridden by an API (or CLI) setting, if any The value is then overridden by an hse.conf or kvdb.conf setting, if any This ordering allows the effective value of a configuration parameter to be modified without recompiling an HSE application.","title":"Configuration Parameters"},{"location":"gs/params/#configuration-parameters","text":"HSE defines global, KVDB, and KVS configuration parameters as described below. These are classified as either create-time parameters, which apply when an application creates a KVDB or KVS, or runtime parameters, which apply each time an application initializes the HSE library or opens a KVDB or KVS. In addition to the detailed descriptions below, you can find parameter usage examples in the API reference , CLI reference , and HSE sample programs .","title":"Configuration Parameters"},{"location":"gs/params/#global-parameters","text":"Global parameters are runtime parameters that apply at the application level. These parameters may be specified in the hse_init() API call or in the optional hse.conf JSON file, which is also specified in hse_init() . For hse_init() API calls, specify global parameters in the form <param>=<value> . For example, socket.enabled=false . The following global parameters are part of the stable API. Parameter Default Description logging.enabled true Logging mode (false==disabled, true==enabled) logging.structured false Logging style (false==basic, true==structured) logging.destination syslog Log destination (stdout, stderr, file, syslog) logging.path $PWD/hse.log Log file when logging.destination==file logging.level 7 Logging severity level (0==emergency; 7==debug) socket.enabled true REST interface mode (false==disabled, true==enabled) socket.path /tmp/hse-<pid>.sock UNIX domain socket file when socket.enabled==true","title":"Global Parameters"},{"location":"gs/params/#kvdb-parameters","text":"KVDB parameters apply when a KVDB is created or opened.","title":"KVDB Parameters"},{"location":"gs/params/#kvdb-create-time-parameters","text":"KVDB create-time parameters may be specified in the hse_kvdb_create() API call or when using the CLI to create a KVDB. In either case, specify KVDB create-time parameters in the form <param>=<value> . For example, storage.capacity.path=/path/to/capacity/dir . The following KVDB create-time parameters are part of the stable API. Parameter Default Description storage.capacity.path <KVDB home>/capacity Capacity media class directory storage.staging.path null Staging media class directory","title":"KVDB Create-time Parameters"},{"location":"gs/params/#kvdb-runtime-parameters","text":"KVDB runtime parameters may be specified in the hse_kvdb_open() API call or in the optional kvdb.conf JSON file in the KVDB home directory, which is also specified in hse_kvdb_open() . For hse_kvdb_open() API calls, specify KVDB runtime parameters in the form <param>=<value> . For example, durability.interval_ms=1000 . The following KVDB runtime parameters are part of the stable API. Parameter Default Description read_only false Access mode (false==read/write, true==read-only) durability.enabled true Journaling mode (false==disabled, true==enabled) durability.interval_ms 100 Max time data is cached (in milliseconds) when durability.enabled==true durability.mclass capacity Media class for journal (capacity, staging) throttling.init_policy default Ingest throttle at startup (light, medium, default)","title":"KVDB Runtime Parameters"},{"location":"gs/params/#durability-settings","text":"The KVDB durability parameters control how HSE journals updates for that KVDB to provide for recovery in the event of a failure. The parameter durability.enabled determines whether or not journaling is enabled. In general, you should always set this to true . As a rare exception, applications that implement their own form of durability may want to disable HSE journaling to increase performance. The parameter durability.interval_ms specifies the frequency (in milliseconds) for automatically flushing cached updates to the journal on stable storage. Increasing this value may improve performance but also increases the amount of data that may be lost in the event of a failure. The parameter durability.mclass specifies the media class for storing journal files. In general, best performance is achieved by storing the journal files on the fastest media class configured for a KVDB. See the discussion on HSE durability controls for additional details.","title":"Durability Settings"},{"location":"gs/params/#initial-throttle-setting","text":"On startup, HSE throttles the rate at which it processes updates in a KVDB, referred to as the ingest rate . HSE increases the ingest rate for the KVDB until it reaches the maximum sustainable value for the underlying storage. This ramp-up process can take up to 200 seconds . For benchmarks, this initial throttling can greatly distort results. In general operation, this initial throttling may impact the time before a service is fully operational. The throttling.init_policy parameter can be used to achieve the maximum ingest rate in far less time. It specifies a relative initial throttling value of light (minimum), medium , or default (maximum) throttling. Setting the throttling.init_policy parameter improperly for the underlying storage can cause the durability interval ( durability.interval_ms ) to be violated or internal indexing structures to become unbalanced for a period of time. For example, this may occur if throttling.init_policy is set to light with relatively slow KVDB storage. The CLI provides a command to determine the appropriate throttling.init_policy setting for your KVDB storage. You can run it as follows. hse storage profile /path/to/capacity/storage/for/the/kvdb The path specified in hse storage profile should be a directory in the file system hosting the capacity media class for the KVDB of interest. Use the output of hse storage profile to specify the throttling.init_policy value for that KVDB.","title":"Initial Throttle Setting"},{"location":"gs/params/#kvs-parameters","text":"KVS parameters apply when a KVS is created or opened.","title":"KVS Parameters"},{"location":"gs/params/#kvs-create-time-parameters","text":"KVS create-time parameters may be specified in the hse_kvdb_kvs_create() API call or when using the CLI to create a KVS. In either case, specify KVS create-time parameters in the form <param>=<value> . For example, prefix.length=8 . The following KVS create-time parameters are part of the stable API. Parameter Default Description prefix.length 0 Key prefix length (bytes) Tip The KVS name default is reserved and may not be used in hse_kvdb_kvs_create() API calls or with the CLI.","title":"KVS Create-time Parameters"},{"location":"gs/params/#kvs-runtime-parameters","text":"KVS runtime parameters may be specified in the hse_kvdb_kvs_open() API call or in the optional kvdb.conf configuration file in the KVDB home directory, which is also specified in hse_kvdb_open() . For hse_kvdb_kvs_open() API calls, specify KVS runtime parameters in the form <param>=<value> . For example, compression.value.algorithm=lz4 . The following KVS runtime parameters are part of the stable API. Parameter Default Description transactions.enabled false Transaction mode (false==disabled, true==enabled) mclass.policy capacity_only See discussion below for values compression.value.algorithm none Value compression method (none, lz4) compression.value.min_length 12 Value length above which compression is attempted (bytes)","title":"KVS Runtime Parameters"},{"location":"gs/params/#transaction-mode","text":"When a KVS is opened, the transactions.enabled value determines whether or not transactions are enabled for the KVS. This mode may be changed by closing and reopening the KVS. See the discussion on HSE transactions for additional details.","title":"Transaction Mode"},{"location":"gs/params/#media-class-usage","text":"The media class usage policy for a KVS defines how the key-value data in that KVS is stored and managed in a KVDB configured with a staging media class. Key-value data in a KVS can either be pinned to a particular media class, or tiered from the staging media class to the capacity media class as it ages, as determined by the mclass.policy value for the KVS: capacity_only pins all key-value data to the capacity media class staging_only pins all key-value data to the staging media class staging_min_capacity tiers all key-value data staging_max_capacity pins all key data to the staging media class and tiers all value data Of the two tiering options, staging_max_capacity will generally yield the highest throughput, lowest latency, and least write-amplification in the capacity media class. The trade-off is more storage required in the staging media class. Info If no staging media class is present, and an mclass.policy value other than capacity_only is specified, a warning is logged and capacity_only is applied.","title":"Media Class Usage"},{"location":"gs/params/#configuration-files","text":"The following are the JSON file formats for the optional HSE configuration files.","title":"Configuration Files"},{"location":"gs/params/#hseconf-json-file","text":"See the discussion on global parameters for definitions, legal values, and defaults. { \"logging\": { \"enabled\": boolean, \"structured\": boolean, \"destination\": \"stdout | stderr | file | syslog\", \"path\": \"/log/file/path\", \"level\": integer }, \"socket\": { \"enabled\": boolean, \"path\": \"/UNIX/socket/file/path\" } }","title":"hse.conf JSON File"},{"location":"gs/params/#kvdbconf-json-file","text":"See the discussions on KVDB runtime parameters and KVS runtime parameters for definitions, legal values, and defaults. { \"read_only\": boolean, \"durability\": { \"enabled\": boolean, \"interval\": integer, \"mclass\": \"capacity | staging\" }, \"throttling\": { \"init_policy\": \"light | medium | default\" }, \"kvs\": { \"<kvs name>\": { \"transactions\": { \"enabled\": boolean }, \"mclass\": { \"policy\": \"see KVS runtime parameter discussion for value strings\" }, \"compression\": { \"value\": { \"algorithm\": \"lz4 | none\", \"min_length\": integer } } } } } The KVS name default is reserved and its parameters apply to all the KVS in a KVDB. Parameters specified for a named KVS override those specified via default .","title":"kvdb.conf JSON File"},{"location":"gs/params/#precedence-of-parameters","text":"The final value for a specific configuration parameter is determined of follows: The built-in default value is applied first The value is then overridden by an API (or CLI) setting, if any The value is then overridden by an hse.conf or kvdb.conf setting, if any This ordering allows the effective value of a configuration parameter to be modified without recompiling an HSE application.","title":"Precedence of Parameters"},{"location":"gs/storage/","text":"KVDB Storage The following provides an overview of important KVDB storage concepts. Media Classes The KVDB storage model is based on the concept of media classes, where each media class represents a tier of storage. HSE currently defines two media classes for a KVDB: Capacity , which is required and represents the bulk (bottom) tier of storage Staging , which is optional and represents a faster (higher) tier of storage Each media class for a KVDB is simply a directory in a file system. For example, a KVDB could be configured with a capacity directory in a file system on cost-optimized SATA QLC SSDs, and a staging directory in a file system on performance-optimized NVMe TLC SSDs. The data for a KVDB is stored as a set of files in each of its capacity and (optional) staging directories. KVDB Homes Every KVDB has a home directory with files storing its metadata. A KVDB home directory may also contain an optional kvdb.conf file with user-defined KVDB and KVS parameter settings. Info Most applications will use a single KVDB with only the capacity media class configured. In this common case, the capacity media class will be located next to other KVDB files within the KVDB home.","title":"KVDB Storage"},{"location":"gs/storage/#kvdb-storage","text":"The following provides an overview of important KVDB storage concepts.","title":"KVDB Storage"},{"location":"gs/storage/#media-classes","text":"The KVDB storage model is based on the concept of media classes, where each media class represents a tier of storage. HSE currently defines two media classes for a KVDB: Capacity , which is required and represents the bulk (bottom) tier of storage Staging , which is optional and represents a faster (higher) tier of storage Each media class for a KVDB is simply a directory in a file system. For example, a KVDB could be configured with a capacity directory in a file system on cost-optimized SATA QLC SSDs, and a staging directory in a file system on performance-optimized NVMe TLC SSDs. The data for a KVDB is stored as a set of files in each of its capacity and (optional) staging directories.","title":"Media Classes"},{"location":"gs/storage/#kvdb-homes","text":"Every KVDB has a home directory with files storing its metadata. A KVDB home directory may also contain an optional kvdb.conf file with user-defined KVDB and KVS parameter settings. Info Most applications will use a single KVDB with only the capacity media class configured. In this common case, the capacity media class will be located next to other KVDB files within the KVDB home.","title":"KVDB Homes"},{"location":"gs/sysreqs/","text":"System Requirements The following are system requirements for running HSE applications. Hardware Hardware requirements are largely dictated by the application embedding HSE and the amount of data stored. The following are general guidelines. CPU : x86_64; 3.0 GHz or higher; 16 threads or more Memory : 32 GB or more Storage : SSD volumes only ; use NVMe for best performance If KVDB storage is configured on multiple devices, such as when using XFS with LVM, performance can be significantly improved by balancing these devices across NUMA nodes. Tools like lstopo can be helpful in creating and verifying a balanced configuration. Operating System HSE should work with most modern Linux\u00ae 64-bit operating system distributions. We have run HSE on the following. Red Hat\u00ae Enterprise Linux\u00ae 8 (RHEL 8) Ubuntu\u00ae 18.04 Fedora\u00ae 34 File System HSE requires the following file system features. fallocate(2) with modes zero (0), FALLOC_FL_PUNCH_HOLE , FALLOC_FL_KEEP_SIZE openat(2) with flag O_DIRECT Several common file systems support these features, including XFS and ext4. For most HSE applications we recommend using XFS. Virtual Memory HSE performance and quality of service (QoS) can be significantly improved by configuring huge pages and other virtual memory tuning parameters . For most HSE applications we recommend the following settings. sudo sysctl -w vm.nr_hugepages = 256 sudo sysctl -w vm.swappiness = 1 sudo sysctl -w vm.dirty_background_ratio = 5 sudo sysctl -w vm.dirty_ratio = 15","title":"System Requirements"},{"location":"gs/sysreqs/#system-requirements","text":"The following are system requirements for running HSE applications.","title":"System Requirements"},{"location":"gs/sysreqs/#hardware","text":"Hardware requirements are largely dictated by the application embedding HSE and the amount of data stored. The following are general guidelines. CPU : x86_64; 3.0 GHz or higher; 16 threads or more Memory : 32 GB or more Storage : SSD volumes only ; use NVMe for best performance If KVDB storage is configured on multiple devices, such as when using XFS with LVM, performance can be significantly improved by balancing these devices across NUMA nodes. Tools like lstopo can be helpful in creating and verifying a balanced configuration.","title":"Hardware"},{"location":"gs/sysreqs/#operating-system","text":"HSE should work with most modern Linux\u00ae 64-bit operating system distributions. We have run HSE on the following. Red Hat\u00ae Enterprise Linux\u00ae 8 (RHEL 8) Ubuntu\u00ae 18.04 Fedora\u00ae 34","title":"Operating System"},{"location":"gs/sysreqs/#file-system","text":"HSE requires the following file system features. fallocate(2) with modes zero (0), FALLOC_FL_PUNCH_HOLE , FALLOC_FL_KEEP_SIZE openat(2) with flag O_DIRECT Several common file systems support these features, including XFS and ext4. For most HSE applications we recommend using XFS.","title":"File System"},{"location":"gs/sysreqs/#virtual-memory","text":"HSE performance and quality of service (QoS) can be significantly improved by configuring huge pages and other virtual memory tuning parameters . For most HSE applications we recommend the following settings. sudo sysctl -w vm.nr_hugepages = 256 sudo sysctl -w vm.swappiness = 1 sudo sysctl -w vm.dirty_background_ratio = 5 sudo sysctl -w vm.dirty_ratio = 15","title":"Virtual Memory"},{"location":"res/benchmarking/","text":"Benchmarking Tips The following are tips for benchmarking HSE applications. System Requirements The system running the HSE application should meet the specified requirements . In particular: Configure huge pages and other virtual memory tuning parameters as documented Balance storage devices across NUMA nodes when applicable Configuration Parameters In the HSE application or kvdb.conf file, provide appropriate values for at least the following parameters. KVDB parameters : throttling.init_policy with a value determined by hse storage profile durability.interval_ms with a value appropriate for the application durability.mclass=staging if a staging media class is configured for the KVDB KVS parameters : compression.value.algorithm=lz4 for all KVSs, unless the application performs its own value compression or values are known to not compress","title":"Benchmarking Tips"},{"location":"res/benchmarking/#benchmarking-tips","text":"The following are tips for benchmarking HSE applications.","title":"Benchmarking Tips"},{"location":"res/benchmarking/#system-requirements","text":"The system running the HSE application should meet the specified requirements . In particular: Configure huge pages and other virtual memory tuning parameters as documented Balance storage devices across NUMA nodes when applicable","title":"System Requirements"},{"location":"res/benchmarking/#configuration-parameters","text":"In the HSE application or kvdb.conf file, provide appropriate values for at least the following parameters. KVDB parameters : throttling.init_policy with a value determined by hse storage profile durability.interval_ms with a value appropriate for the application durability.mclass=staging if a staging media class is configured for the KVDB KVS parameters : compression.value.algorithm=lz4 for all KVSs, unless the application performs its own value compression or values are known to not compress","title":"Configuration Parameters"},{"location":"res/community/","text":"Community Resources are available to report a bug, ask a question, provide feedback on how we can improve HSE, or contribute to development. Report a Bug You can file an issue to report an bug. In doing so, please provide all the information requested in the issue template. Ask a Question You can ask a question in the HSE discussions forum using the Q&A category. Participate in Discussions You can discuss all aspects of HSE in the discussions forum using the following categories. Q&A to ask a question Ideas to discuss a new feature or enhancement Show and tell to talk about your experiences with HSE General to discuss all other aspects of the project Contribute to Development We welcome your contributions to the HSE project. As a starting point, see CONTRIBUTING.md in the hse repo for instructions on how to participate.","title":"Community"},{"location":"res/community/#community","text":"Resources are available to report a bug, ask a question, provide feedback on how we can improve HSE, or contribute to development.","title":"Community"},{"location":"res/community/#report-a-bug","text":"You can file an issue to report an bug. In doing so, please provide all the information requested in the issue template.","title":"Report a Bug"},{"location":"res/community/#ask-a-question","text":"You can ask a question in the HSE discussions forum using the Q&A category.","title":"Ask a Question"},{"location":"res/community/#participate-in-discussions","text":"You can discuss all aspects of HSE in the discussions forum using the following categories. Q&A to ask a question Ideas to discuss a new feature or enhancement Show and tell to talk about your experiences with HSE General to discuss all other aspects of the project","title":"Participate in Discussions"},{"location":"res/community/#contribute-to-development","text":"We welcome your contributions to the HSE project. As a starting point, see CONTRIBUTING.md in the hse repo for instructions on how to participate.","title":"Contribute to Development"}]}