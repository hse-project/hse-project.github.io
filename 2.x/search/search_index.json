{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Heterogeneous-Memory Storage Engine HSE is a fast embeddable key-value store designed for SSDs and persistent memory. HSE optimizes performance and endurance by orchestrating data placement across DRAM and multiple classes of solid-state storage devices. HSE is ideal for powering Databases, Software-Defined Storage (SDS), High-Performance Computing (HPC), Internet of Things (IoT), and Machine Learning (ML). Key Features Rich set of key-value operations Full transactions with snapshot-isolation spanning multiple independent key-value collections Cursors for iterating over snapshot views Data model for optimizing mixed use-case workloads in a single data store Key and value compression Flexible durability controls Configurable data orchestration schemes Native C library that can be embedded in any application Benefits Scales to terabytes of data and hundreds of billions of keys per store Efficiently handles thousands of concurrent operations Dramatically improves throughput, latency, write-amplification, and read-amplification versus common alternatives for many workloads Optionally combines multiple classes of solid-state storage to optimize performance and endurance","title":"Home"},{"location":"#heterogeneous-memory-storage-engine","text":"HSE is a fast embeddable key-value store designed for SSDs and persistent memory. HSE optimizes performance and endurance by orchestrating data placement across DRAM and multiple classes of solid-state storage devices. HSE is ideal for powering Databases, Software-Defined Storage (SDS), High-Performance Computing (HPC), Internet of Things (IoT), and Machine Learning (ML).","title":"Heterogeneous-Memory Storage Engine"},{"location":"#key-features","text":"Rich set of key-value operations Full transactions with snapshot-isolation spanning multiple independent key-value collections Cursors for iterating over snapshot views Data model for optimizing mixed use-case workloads in a single data store Key and value compression Flexible durability controls Configurable data orchestration schemes Native C library that can be embedded in any application","title":"Key Features"},{"location":"#benefits","text":"Scales to terabytes of data and hundreds of billions of keys per store Efficiently handles thousands of concurrent operations Dramatically improves throughput, latency, write-amplification, and read-amplification versus common alternatives for many workloads Optionally combines multiple classes of solid-state storage to optimize performance and endurance","title":"Benefits"},{"location":"api/","text":"Overview This documentation is geared towards describing the structure of the HSE API and the specifics of each entry point's operation. Refer to https://hse-project.github.io for a conceptual overview of HSE. Terminology KVS - Key-value store, containing zero or more key-value pairs KVDB - Key-value database, comprised of one or more KVSs and defining a transaction domain key - A byte string used to uniquely identify values for storage, retrieval, and deletion in a KVS segmented key - A key that is logically divided into N segments (N >= 2), arranged to group related key-value pairs when keys are sorted lexicographically key prefix - For segmented keys, the first K segments (1 <= K < N) key prefix length - The length of a key prefix (bytes) Updated on 16 December 2021 at 14:04:28 CST","title":"Overview"},{"location":"api/#overview","text":"This documentation is geared towards describing the structure of the HSE API and the specifics of each entry point's operation. Refer to https://hse-project.github.io for a conceptual overview of HSE.","title":"Overview"},{"location":"api/#terminology","text":"KVS - Key-value store, containing zero or more key-value pairs KVDB - Key-value database, comprised of one or more KVSs and defining a transaction domain key - A byte string used to uniquely identify values for storage, retrieval, and deletion in a KVS segmented key - A key that is logically divided into N segments (N >= 2), arranged to group related key-value pairs when keys are sorted lexicographically key prefix - For segmented keys, the first K segments (1 <= K < N) key prefix length - The length of a key prefix (bytes) Updated on 16 December 2021 at 14:04:28 CST","title":"Terminology"},{"location":"api/Files/","text":"Files dir include dir hse file hse/version.h dir include dir hse file hse/flags.h file hse/hse.h file hse/limits.h file hse/types.h Updated on 16 December 2021 at 14:04:28 CST","title":"Files"},{"location":"api/Files/#files","text":"dir include dir hse file hse/version.h dir include dir hse file hse/flags.h file hse/hse.h file hse/limits.h file hse/types.h Updated on 16 December 2021 at 14:04:28 CST","title":"Files"},{"location":"api/Files/dir_04700ab32882dd6f5919291731388d84/","text":"hse Files Name hse/version.h Updated on 16 December 2021 at 14:04:27 CST","title":"hse"},{"location":"api/Files/dir_04700ab32882dd6f5919291731388d84/#hse","text":"","title":"hse"},{"location":"api/Files/dir_04700ab32882dd6f5919291731388d84/#files","text":"Name hse/version.h Updated on 16 December 2021 at 14:04:27 CST","title":"Files"},{"location":"api/Files/dir_74519b06cb360fd5deb315947aad9941/","text":"hse Files Name hse/flags.h hse/hse.h hse/limits.h hse/types.h Updated on 16 December 2021 at 14:04:27 CST","title":"hse"},{"location":"api/Files/dir_74519b06cb360fd5deb315947aad9941/#hse","text":"","title":"hse"},{"location":"api/Files/dir_74519b06cb360fd5deb315947aad9941/#files","text":"Name hse/flags.h hse/hse.h hse/limits.h hse/types.h Updated on 16 December 2021 at 14:04:27 CST","title":"Files"},{"location":"api/Files/dir_8f2980731aba7ec7b9fcae5764f196e3/","text":"include Directories Name hse Updated on 16 December 2021 at 14:04:27 CST","title":"include"},{"location":"api/Files/dir_8f2980731aba7ec7b9fcae5764f196e3/#include","text":"","title":"include"},{"location":"api/Files/dir_8f2980731aba7ec7b9fcae5764f196e3/#directories","text":"Name hse Updated on 16 December 2021 at 14:04:27 CST","title":"Directories"},{"location":"api/Files/dir_d44c64559bbebec7f509842c48db8b23/","text":"include Directories Name hse Updated on 16 December 2021 at 14:04:27 CST","title":"include"},{"location":"api/Files/dir_d44c64559bbebec7f509842c48db8b23/#include","text":"","title":"include"},{"location":"api/Files/dir_d44c64559bbebec7f509842c48db8b23/#directories","text":"Name hse Updated on 16 December 2021 at 14:04:27 CST","title":"Directories"},{"location":"api/Files/flags_8h/","text":"hse/flags.h Defines Name HSE_KVDB_SYNC_ASYNC HSE_KVDB_SYNC_RSVD1 HSE_KVS_PUT_PRIO HSE_KVS_PUT_VCOMP_OFF HSE_CURSOR_CREATE_REV Macros Documentation define HSE_KVDB_SYNC_ASYNC #define HSE_KVDB_SYNC_ASYNC (1u << 0) define HSE_KVDB_SYNC_RSVD1 #define HSE_KVDB_SYNC_RSVD1 (1u << 1) define HSE_KVS_PUT_PRIO #define HSE_KVS_PUT_PRIO (1u << 0) define HSE_KVS_PUT_VCOMP_OFF #define HSE_KVS_PUT_VCOMP_OFF (1u << 1) define HSE_CURSOR_CREATE_REV #define HSE_CURSOR_CREATE_REV (1u << 0) Source code /* SPDX-License-Identifier: Apache-2.0 */ /* * Copyright (C) 2021 Micron Technology, Inc. All rights reserved. */ #ifndef HSE_FLAGS_H #define HSE_FLAGS_H #ifdef __cplusplus extern \"C\" { #endif /* Documentation for these flags appears in hse.h */ /* hse_kvdb_sync() flags */ #define HSE_KVDB_SYNC_ASYNC (1u << 0) #define HSE_KVDB_SYNC_RSVD1 (1u << 1) /* hse_kvs_put() flags */ #define HSE_KVS_PUT_PRIO (1u << 0) #define HSE_KVS_PUT_VCOMP_OFF (1u << 1) /* hse_kvs_cursor_create() flags */ #define HSE_CURSOR_CREATE_REV (1u << 0) #ifdef __cplusplus } #endif #endif Updated on 16 December 2021 at 14:04:27 CST","title":"hse/flags.h"},{"location":"api/Files/flags_8h/#hseflagsh","text":"","title":"hse/flags.h"},{"location":"api/Files/flags_8h/#defines","text":"Name HSE_KVDB_SYNC_ASYNC HSE_KVDB_SYNC_RSVD1 HSE_KVS_PUT_PRIO HSE_KVS_PUT_VCOMP_OFF HSE_CURSOR_CREATE_REV","title":"Defines"},{"location":"api/Files/flags_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"api/Files/flags_8h/#define-hse_kvdb_sync_async","text":"#define HSE_KVDB_SYNC_ASYNC (1u << 0)","title":"define HSE_KVDB_SYNC_ASYNC"},{"location":"api/Files/flags_8h/#define-hse_kvdb_sync_rsvd1","text":"#define HSE_KVDB_SYNC_RSVD1 (1u << 1)","title":"define HSE_KVDB_SYNC_RSVD1"},{"location":"api/Files/flags_8h/#define-hse_kvs_put_prio","text":"#define HSE_KVS_PUT_PRIO (1u << 0)","title":"define HSE_KVS_PUT_PRIO"},{"location":"api/Files/flags_8h/#define-hse_kvs_put_vcomp_off","text":"#define HSE_KVS_PUT_VCOMP_OFF (1u << 1)","title":"define HSE_KVS_PUT_VCOMP_OFF"},{"location":"api/Files/flags_8h/#define-hse_cursor_create_rev","text":"#define HSE_CURSOR_CREATE_REV (1u << 0)","title":"define HSE_CURSOR_CREATE_REV"},{"location":"api/Files/flags_8h/#source-code","text":"/* SPDX-License-Identifier: Apache-2.0 */ /* * Copyright (C) 2021 Micron Technology, Inc. All rights reserved. */ #ifndef HSE_FLAGS_H #define HSE_FLAGS_H #ifdef __cplusplus extern \"C\" { #endif /* Documentation for these flags appears in hse.h */ /* hse_kvdb_sync() flags */ #define HSE_KVDB_SYNC_ASYNC (1u << 0) #define HSE_KVDB_SYNC_RSVD1 (1u << 1) /* hse_kvs_put() flags */ #define HSE_KVS_PUT_PRIO (1u << 0) #define HSE_KVS_PUT_VCOMP_OFF (1u << 1) /* hse_kvs_cursor_create() flags */ #define HSE_CURSOR_CREATE_REV (1u << 0) #ifdef __cplusplus } #endif #endif Updated on 16 December 2021 at 14:04:27 CST","title":"Source code"},{"location":"api/Files/hse_8h/","text":"hse/hse.h Functions Name int hse_err_to_errno ( hse_err_t err) Return an hse_err_t value's errno representation. size_t hse_strerror ( hse_err_t err, char * buf, size_t buf_len) Return an hse_err_t value's string representation. enum hse_err_ctx hse_err_to_ctx ( hse_err_t err) Return an hse_err_t value's error context. hse_err_t hse_init (const char * config, size_t paramc, const char *const * paramv) Initialize the HSE subsystem. void hse_fini (void ) Shutdown the HSE subsystem. hse_err_t hse_param_get (const char * param, char * buf, size_t buf_sz, size_t * needed_sz) Get HSE global parameter. hse_err_t hse_kvdb_close (struct hse_kvdb * kvdb) Close a KVDB. hse_err_t hse_kvdb_create (const char * kvdb_home, size_t paramc, const char *const * paramv) Create a KVDB. hse_err_t hse_kvdb_drop (const char * kvdb_home) Drop a KVDB. const char * hse_kvdb_home_get (struct hse_kvdb * kvdb) Get the KVDB home. hse_err_t hse_kvdb_kvs_names_get (struct hse_kvdb * kvdb, size_t * namec, char *** namev) Get the names of the KVSs within the given KVDB. void hse_kvdb_kvs_names_free (struct hse_kvdb * kvdb, char ** namev) Free the names collection obtained through hse_kvdb_kvs_names_get() . hse_err_t hse_kvdb_mclass_info_get (struct hse_kvdb * kvdb, enum hse_mclass mclass, struct hse_mclass_info * info) Get media class information from a KVDB. bool hse_kvdb_mclass_is_configured (struct hse_kvdb * kvdb, enum hse_mclass mclass) Check if a media class is configured for a KVDB. hse_err_t hse_kvdb_open (const char * kvdb_home, size_t paramc, const char const * paramv, struct hse_kvdb * kvdb) Open a KVDB. hse_err_t hse_kvdb_param_get (struct hse_kvdb * kvdb, const char * param, char * buf, size_t buf_sz, size_t * needed_sz) Get KVDB parameter. hse_err_t hse_kvdb_storage_add (const char * kvdb_home, size_t paramc, const char *const * paramv) Add new media class storage to an existing offline KVDB. hse_err_t hse_kvdb_sync (struct hse_kvdb * kvdb, unsigned int flags) Sync data in all of the referenced KVDB's KVSs to stable media. const char * hse_mclass_name_get (enum hse_mclass mclass) Get the name of a media class. hse_err_t hse_kvdb_kvs_close (struct hse_kvs * kvs) Close an open KVS. hse_err_t hse_kvdb_kvs_create (struct hse_kvdb * kvdb, const char * kvs_name, size_t paramc, const char *const * paramv) Create a KVS within the referenced KVDB. hse_err_t hse_kvdb_kvs_drop (struct hse_kvdb * kvdb, const char * kvs_name) Drop a KVS from the referenced KVDB. hse_err_t hse_kvdb_kvs_open (struct hse_kvdb * handle, const char * kvs_name, const size_t paramc, const char const * paramv, struct hse_kvs * kvs_out) Open a KVS in a KVDB. hse_err_t hse_kvs_delete (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * key, size_t key_len) Delete the key and its associated value from the KVS. hse_err_t hse_kvs_get (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * key, size_t key_len, bool * found, void * buf, size_t buf_len, size_t * val_len) Retrieve the value for a given key from the KVS. const char * hse_kvs_name_get (struct hse_kvs * kvs) Get the name of a KVS. hse_err_t hse_kvs_param_get (struct hse_kvs * kvs, const char * param, char * buf, size_t buf_sz, size_t * needed_sz) Get KVS parameter. hse_err_t hse_kvs_prefix_delete (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * pfx, size_t pfx_len) Delete all key-value pairs matching the key prefix from a KVS storing segmented keys. hse_err_t hse_kvs_put (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * key, size_t key_len, const void * val, size_t val_len) Put a key-value pair into KVS. hse_err_t hse_kvdb_txn_abort (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Abort/rollback transaction. struct hse_kvdb_txn * hse_kvdb_txn_alloc (struct hse_kvdb * kvdb) Allocate transaction object. hse_err_t hse_kvdb_txn_begin (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Initiate transaction. hse_err_t hse_kvdb_txn_commit (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Commit all the mutations of the referenced transaction. void hse_kvdb_txn_free (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Free transaction object. enum hse_kvdb_txn_state hse_kvdb_txn_state_get (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Retrieve the state of the referenced transaction. hse_err_t hse_kvs_cursor_create (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * filter, size_t filter_len, struct hse_kvs_cursor ** cursor) Creates a cursor used to iterate over key-value pairs in a KVS. hse_err_t hse_kvs_cursor_destroy (struct hse_kvs_cursor * cursor) Destroy cursor. hse_err_t hse_kvs_cursor_read (struct hse_kvs_cursor * cursor, unsigned int flags, const void key, size_t * key_len, const void val, size_t * val_len, bool * eof) Iteratively access the elements pointed to by the cursor. hse_err_t hse_kvs_cursor_read_copy (struct hse_kvs_cursor * cursor, unsigned int flags, void * keybuf, size_t keybuf_sz, size_t * key_len, void * valbuf, size_t valbuf_sz, size_t * val_len, bool * eof) Iteratively access the elements pointed to by the cursor. hse_err_t hse_kvs_cursor_seek (struct hse_kvs_cursor * cursor, unsigned int flags, const void * key, size_t key_len, const void ** found, size_t * found_len) Move the cursor to point at the key-value pair at or closest to key . hse_err_t hse_kvs_cursor_seek_range (struct hse_kvs_cursor * cursor, unsigned int flags, const void * filt_min, size_t filt_min_len, const void * filt_max, size_t filt_max_len, const void ** found, size_t * found_len) Move the cursor to the closest match to key, gated by the given filter. hse_err_t hse_kvs_cursor_update_view (struct hse_kvs_cursor * cursor, unsigned int flags) Update a the cursor view. Functions Documentation function hse_err_to_errno int hse_err_to_errno ( hse_err_t err ) Return an hse_err_t value's errno representation. Parameters : err Error value returned from an HSE API function. Return : Error's errno equivalent. Note : This function is thread safe. The hse_err_t scalar value err is translated into its errno equivalent. function hse_strerror size_t hse_strerror ( hse_err_t err , char * buf , size_t buf_len ) Return an hse_err_t value's string representation. Parameters : err Error value returned from an HSE API function. buf Buffer to hold the formatted string. buf_len Length of buffer. Return : The number of characters (excluding the terminating NULL byte) which would have been written to the final string if enough space had been available. Note : This function is thread safe. The hse_err_t scalar value err is decoded into a NULL-terminated string representation giving more information about the error and where it occurred. The string will be truncated if buf_len is too small (a buf_len value of 128 is sufficient to avoid truncation of most error strings). function hse_err_to_ctx enum hse_err_ctx hse_err_to_ctx ( hse_err_t err ) Return an hse_err_t value's error context. Parameters : err Error value returned from an HSE API function. Return : The error's context. Note : This function is thread safe. The error context value is retrieved from the hse_err_t value. function hse_init hse_err_t hse_init ( const char * config , size_t paramc , const char * const * paramv ) Initialize the HSE subsystem. Parameters : config Path to a global configuration file. paramc Number of initialization parameters in paramv . paramv List of parameters in key=value format. Return : Error status. Note : This function is not thread safe and is idempotent. This function initializes a range of different internal HSE structures. It must be called before any other HSE functions are used. function hse_fini void hse_fini ( void ) Shutdown the HSE subsystem. Note : This function is not thread safe. Warning : After invoking this function, calling any other HSE functions will result in undefined behavior unless HSE is re-initialized. This function cleanly finalizes a range of different internal HSE structures. It should be called prior to application exit. function hse_param_get hse_err_t hse_param_get ( const char * param , char * buf , size_t buf_sz , size_t * needed_sz ) Get HSE global parameter. Parameters : param Parameter name. buf Buffer for writing stringified value of parameter. buf_sz Size of buf . needed_sz Needed size of buf . Return : Error status. Note : This function is thread safe. Remark : param must not be NULL. param must be a valid parameter. Puts the stringified version of the parameter value into buf . If buf_sz is NULL, then needed_sz will still be populated. function hse_kvdb_close hse_err_t hse_kvdb_close ( struct hse_kvdb * kvdb ) Close a KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() . Return : Error status. Note : This function is not thread safe. Warning : After invoking this function, calling any other KVDB functions will result in undefined behavior unless the KVDB is re-opened. Remark : kvdb must not be NULL. function hse_kvdb_create hse_err_t hse_kvdb_create ( const char * kvdb_home , size_t paramc , const char * const * paramv ) Create a KVDB. Parameters : kvdb_home KVDB home directory. paramc Number of configuration parameters in paramv . paramv List of parameters in key=value format. Return : Error status. Note : This function is not thread safe. Remark : kvdb_home must not be NULL. function hse_kvdb_drop hse_err_t hse_kvdb_drop ( const char * kvdb_home ) Drop a KVDB. Parameters : kvdb_home KVDB home directory. Return : Error status. Note : This function is not thread safe. Warning : It is an error to call this function on a KVDB that is open. Remark : kvdb_home must not be NULL. function hse_kvdb_home_get const char * hse_kvdb_home_get ( struct hse_kvdb * kvdb ) Get the KVDB home. Parameters : kvdb KVDB handle from hse_kvdb_open() . Returns : NULL if given an invalid KVDB handle. Return : KVDB home. Note : This function is thread safe. Remark : kvdb must not be NULL. function hse_kvdb_kvs_names_get hse_err_t hse_kvdb_kvs_names_get ( struct hse_kvdb * kvdb , size_t * namec , char *** namev ) Get the names of the KVSs within the given KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() . namec Number of KVSs in the KVDB. namev Vector of KVSs allocated by the function. Return : Error status. Note : This function is thread safe. Remark : kvdb must not be NULL. namev must not be NULL. Key-value stores (KVSs) are opened by name. This function allocates a vector of allocated strings, each containing the NULL-terminated name of a KVS. The memory must be freed via hse_kvdb_kvs_names_free() . Example Usage: int namec ; char ** namev ; hse_err_t err ; err = hse_kvdb_kvs_names_get ( kvdb , & namec , & namev ); if ( ! err ) { for ( int i = 0 ; i < namec ; i ++ ) printf ( \"%s \\n \" , namev [ i ]); } hse_kvdb_kvs_names_free ( namev ); Filename: .c function hse_kvdb_kvs_names_free void hse_kvdb_kvs_names_free ( struct hse_kvdb * kvdb , char ** namev ) Free the names collection obtained through hse_kvdb_kvs_names_get() . Parameters : kvdb KVDB handle from hse_kvdb_open() . namev Vector of KVS names that hse_kvdb_kvs_names_get() output. Note : This function is thread safe. function hse_kvdb_mclass_info_get hse_err_t hse_kvdb_mclass_info_get ( struct hse_kvdb * kvdb , enum hse_mclass mclass , struct hse_mclass_info * info ) Get media class information from a KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() . mclass Media class to query for. info Media class information object. Return : Error status. Note : This function is thread safe. Remark : kvdb must not be NULL. info must not be NULL. function hse_kvdb_mclass_is_configured bool hse_kvdb_mclass_is_configured ( struct hse_kvdb * kvdb , enum hse_mclass mclass ) Check if a media class is configured for a KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() . mclass Media class to query for. Returns : false if kvdb or mclass is invalid. Return : Whether or not mclass is configured. Note : This function is thread safe. Remark : kvdb must not be NULL. function hse_kvdb_open hse_err_t hse_kvdb_open ( const char * kvdb_home , size_t paramc , const char * const * paramv , struct hse_kvdb ** kvdb ) Open a KVDB. Parameters : kvdb_home KVDB home directory. paramc Number of configuration parameters in paramv . paramv List of parameters in key=value format. kvdb Handle to access the opened KVDB. Return : Error status. Note : This function is not thread safe. Remark : The KVDB must have already been created. kvdb_home must not be NULL. kvdb must not be NULL. function hse_kvdb_param_get hse_err_t hse_kvdb_param_get ( struct hse_kvdb * kvdb , const char * param , char * buf , size_t buf_sz , size_t * needed_sz ) Get KVDB parameter. Parameters : kvdb KVDB handle from hse_kvdb_open() . param Parameter name. buf Buffer for writing stringified value of parameter. buf_sz Size of buf . needed_sz Needed size of buf . Return : Error status. Note : This function is thread safe. Remark : kvdb must not be NULL. param must not be NULL. param must be a valid parameter. Puts the stringified version of the parameter value into buf . If buf_sz is NULL, then needed_sz will still be populated. function hse_kvdb_storage_add hse_err_t hse_kvdb_storage_add ( const char * kvdb_home , size_t paramc , const char * const * paramv ) Add new media class storage to an existing offline KVDB. Parameters : kvdb_home KVDB home directory. paramc Number of configuration parameters in paramv . paramv List of KVDB create-time parameters in key=value format. Return : Error status. Note : This function is not thread safe. Remark : kvdb_home must not be NULL. KVBD must have already been created. paramv must not be NULL. function hse_kvdb_sync hse_err_t hse_kvdb_sync ( struct hse_kvdb * kvdb , unsigned int flags ) Sync data in all of the referenced KVDB's KVSs to stable media. Parameters : kvdb KVDB handle from hse_kvdb_open() . flags Flags for operation specialization. Return : Error status. Note : This function is thread safe. Remark : kvdb must not be NULL. Flags: HSE_KVDB_SYNC_ASYNC - Return immediately after initiating operation instead of waiting for completion. function hse_mclass_name_get const char * hse_mclass_name_get ( enum hse_mclass mclass ) Get the name of a media class. Parameters : mclass Media class. Return : Name of media class. Note : This function is thread safe. function hse_kvdb_kvs_close hse_err_t hse_kvdb_kvs_close ( struct hse_kvs * kvs ) Close an open KVS. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . Return : Error status. Note : This function is not thread safe. Warning : After invoking this function, calling any other KVS functions will result in undefined behavior unless the KVS is re-opened. function hse_kvdb_kvs_create hse_err_t hse_kvdb_kvs_create ( struct hse_kvdb * kvdb , const char * kvs_name , size_t paramc , const char * const * paramv ) Create a KVS within the referenced KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() . kvs_name KVS name. paramc Number of configuration parameters in paramv . paramv List of parameters in key=value format. Return : Error status. Note : This function is not thread safe. Remark : kvdb must not be NULL. kvs_name must be non-NULL. kvs_name must be NULL-terminated. strlen( kvs_name ) must be less than HSE_KVS_NAME_LEN_MAX. kvs_name must match the following pattern: [-_A-Za-z0-9]+. kvs_name cannot already exist. function hse_kvdb_kvs_drop hse_err_t hse_kvdb_kvs_drop ( struct hse_kvdb * kvdb , const char * kvs_name ) Drop a KVS from the referenced KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() . kvs_name KVS name. Return : Error status. Note : This function is not thread safe. Warning : It is an error to call this function on a KVS that is open. Remark : kvdb must not be NULL. kvs_name must not be NULL. kvs_name must be NULL-terminated. function hse_kvdb_kvs_open hse_err_t hse_kvdb_kvs_open ( struct hse_kvdb * handle , const char * kvs_name , const size_t paramc , const char * const * paramv , struct hse_kvs ** kvs_out ) Open a KVS in a KVDB. Parameters : handle KVDB handle from hse_kvdb_open() . kvs_name KVS name. paramc Number of configuration parameters in paramv . paramv List of parameters in key=value format. kvs_out Handle to access the opened KVS. Return : Error status. Remark : kvdb must not be NULL. kvs_name must not be NULL. kvs_name must be NULL-terminated. kvs_out must not be NULL. This function is not thread safe. function hse_kvs_delete hse_err_t hse_kvs_delete ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * key , size_t key_len ) Delete the key and its associated value from the KVS. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . flags Flags for operation specialization. txn Transaction context (optional). key Key to be deleted from kvs . key_len Length of key . Return : Error status. Note : This function is thread safe. Remark : kvs must not be NULL. key must not be NULL. key_len must be within the range of [1, HSE_KVS_KEY_LEN_MAX]. It is not an error if the key does not exist within the KVS. See Transactions for information on how deletes within transactions are handled. Flags: 0 - Reserved for future use. function hse_kvs_get hse_err_t hse_kvs_get ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * key , size_t key_len , bool * found , void * buf , size_t buf_len , size_t * val_len ) Retrieve the value for a given key from the KVS. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . flags Flags for operation specialization. txn Transaction context (optional). key Key to get from kvs . key_len Length of key . found Whether or not key was found. buf Buffer into which the value associated with key will be copied (optional). buf_len Length of buf . val_len Actual length of value if key was found. Return : Error status. Note : This function is thread safe. Remark : kvs must not be NULL. key must not be NULL. key_len must be within the range of [1, HSE_KVS_KEY_LEN_MAX]. found must not be NULL. val_len must not be NULL. If the key exists in the KVS, then the referent of found is set to true. If the caller's value buffer is large enough then the data will be returned. Regardless, the actual length of the value is placed in val_len . See Transactions for information on how gets within transactions are handled. Flags: 0 - Reserved for future use. function hse_kvs_name_get const char * hse_kvs_name_get ( struct hse_kvs * kvs ) Get the name of a KVS. Parameters : kvs KVS handle from hse_kvdb_kvs_open() Returns : NULL if given an invalid KVS handle. Return : KVS name. Note : This function is thread safe. Remark : kvs must not be NULL. function hse_kvs_param_get hse_err_t hse_kvs_param_get ( struct hse_kvs * kvs , const char * param , char * buf , size_t buf_sz , size_t * needed_sz ) Get KVS parameter. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . param Parameter name. buf Buffer for writing stringified value of parameter. buf_sz Size of buf . needed_sz Needed size of buf . Return : Error status. Note : This function is thread safe. Remark : kvs must not be NULL. param must not be NULL. param must be a valid parameter. Puts the stringified version of the parameter value into buf . If buf_sz is NULL, then needed_sz will still be populated. function hse_kvs_prefix_delete hse_err_t hse_kvs_prefix_delete ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * pfx , size_t pfx_len ) Delete all key-value pairs matching the key prefix from a KVS storing segmented keys. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . flags Flags for operation specialization. txn Transaction context (optional). pfx Prefix of keys to delete. pfx_len Length of pfx . Return : Error status. Note : This function is thread safe. Remark : kvs must not be NULL. pfx_len must be less than or equal to HSE_KVS_PFX_LEN_MAX. This interface is used to delete an entire range of segmented keys. To do this the caller passes a filter with a length equal to the KVSs key prefix length. It is not an error if no keys exist matching the filter. If there is a filtered iteration in progress, then that iteration can fail if hse_kvs_prefix_delete() is called with a filter matching the iteration. If hse_kvs_prefix_delete() is called from a transaction context, it affects no key-value mutations that are part of the same transaction. Stated differently, for KVS commands issued within a transaction, all calls to hse_kvs_prefix_delete() are treated as though they were issued serially at the beginning of the transaction regardless of the actual order these commands appeared in. Flags: 0 - Reserved for future use. function hse_kvs_put hse_err_t hse_kvs_put ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * key , size_t key_len , const void * val , size_t val_len ) Put a key-value pair into KVS. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . flags Flags for operation specialization. txn Transaction context (optional). key Key to put into kvs . key_len Length of key . val Value associated with key (optional). val_len Length of value . Return : Error status Note : This function is thread safe. Remark : kvs must not be NULL. key must not be NULL. key_len must be within the range of [1, HSE_KVS_KEY_LEN_MAX]. val_len must be within the range of [0, HSE_KVS_VALUE_LEN_MAX]. If the key already exists in the KVS then the value is effectively overwritten. See Transactions for information on how puts within transactions are handled. The HSE KVDB attempts to maintain reasonable QoS and for high-throughput clients this results in very short sleep's being inserted into the put path. For some kinds of data (e.g., control metadata) the client may wish to not experience that delay. For relatively low data rate uses, the caller can set the HSE_KVS_PUT_PRIO flag for an hse_kvs_put() . Care should be taken when doing so to ensure that the system does not become overrun. As a rough approximation, doing 1M priority puts per second marked as PRIO is likely an issue. On the other hand, doing 1K small puts per second marked as PRIO is almost certainly fine. If compression is enabled for the given kvs, then hse_kvs_put() will attempt to compress the value unless the HSE_KVS_PUT_VCOMP_OFF flag is given. Otherwise, the HSE_KVS_PUT_VCOMP_OFF flag is ignored. Flags: HSE_KVS_PUT_PRIO - Operation will not be throttled. HSE_KVS_PUT_VCOMP_OFF - Value will not be compressed. function hse_kvdb_txn_abort hse_err_t hse_kvdb_txn_abort ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Abort/rollback transaction. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle from hse_kvdb_txn_alloc() . Return : Error status. Note : This function is thread safe with different transactions. Warning : The call fails if the referenced transaction is not in the ACTIVE state. Remark : kvdb must not be NULL. txn must not be NULL. function hse_kvdb_txn_alloc struct hse_kvdb_txn * hse_kvdb_txn_alloc ( struct hse_kvdb * kvdb ) Allocate transaction object. Parameters : kvdb KVDB handle from hse_kvdb_open() . Return : The allocated transaction structure. Note : This function is thread safe. Remark : kvdb must not be NULL. This object can and should be re-used many times to avoid the overhead of allocation. function hse_kvdb_txn_begin hse_err_t hse_kvdb_txn_begin ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Initiate transaction. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle from hse_kvdb_txn_alloc() . Return : Error status. Note : This function is thread safe with different transactions. Warning : The call fails if the transaction handle refers to an ACTIVE transaction. Remark : kvdb must not be NULL. txn must not be NULL. function hse_kvdb_txn_commit hse_err_t hse_kvdb_txn_commit ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Commit all the mutations of the referenced transaction. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle from hse_kvdb_txn_alloc() . Return : Error status Note : This function is thread safe with different transactions. Warning : The call fails if the referenced transaction is not in the ACTIVE state. Remark : kvdb must not be NULL. txn must not be NULL. function hse_kvdb_txn_free void hse_kvdb_txn_free ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Free transaction object. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle. Note : If the transaction handle refers to an ACTIVE transaction, the transaction is aborted prior to being freed. This function is thread safe with different transactions. Warning : After invoking this function, calling any other transaction functions with this handle will result in undefined behavior. Remark : kvdb must not be NULL. txn must not be NULL. function hse_kvdb_txn_state_get enum hse_kvdb_txn_state hse_kvdb_txn_state_get ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Retrieve the state of the referenced transaction. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle from hse_kvdb_txn_alloc() . Return : Transaction's state. Remark : kvdb must not be NULL. txn must not be NULL. This function is thread safe with different transactions. function hse_kvs_cursor_create hse_err_t hse_kvs_cursor_create ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * filter , size_t filter_len , struct hse_kvs_cursor ** cursor ) Creates a cursor used to iterate over key-value pairs in a KVS. Parameters : kvs KVS to iterate over, handle from hse_kvdb_kvs_open() . flags Flags for operation specialization. txn Transaction context (optional). filter Iteration limited to keys matching this prefix filter (optional). filter_len Length of filter (optional). cursor Cursor handle. Return : Error status Note : This function is thread safe. Remark : kvs must not be NULL. cursor must not be NULL. Non-transactional cursors: If txn is NULL, a non-transactional cursor is created. Non-transactional cursors have an ephemeral snapshot view of the KVS at the time it the cursor is created. The snapshot view is maintained for the life of the cursor. Writes to the KVS (put, deletes, etc.) made after the cursor is created will not be visible to the cursor unless hse_kvs_cursor_update_view() is used to obtain a more recent snapshot view. Non-transactional cursors can be used on transactional and non-transactional KVSs. Transactional cursors: If txn is not NULL, it must be a valid transaction handle or undefined behavior will result. If it is a valid handle to a transaction in the ACTIVE state, a transactional cursor is created. A transaction cursor's view includes the transaction's writes overlaid on the transaction's ephemeral snapshot view of the KVS. If the transaction is committed or aborted before the cursor is destroyed, the cursor's view reverts to same snaphsot view the transaction had when first became active. The cursor will no longer be able to see the transaction's writes. Calling hse_kvs_cursor_update_view() on a transactional cursor is a no-op and has no effect on the cursor's view. Transactional cursors can only be used on transactional KVSs. Prefix vs non-prefix cursors: Parameters filter and filter_len can be used to iterate over the subset of keys in the KVS whose first filter_len bytes match the filter_len bytes pointed to by filter . A prefix cursor is created when: KVS was created with pfx_len > 0 (i.e., it is a prefix KVS), and filter != NULL and filter_len >= pfx_len . Otherwise, a non-prefix cursor is created. Applications should arrange their key-value data to avoid the need for non-prefix cursors as they are significantly slower and more resource-intensive than prefix cursors. Note that simply using a filter doesn't create a prefix cursor \u2013 it must meet the two conditions listed above. Flags: HSE_CURSOR_CREATE_REV - Iterate in reverse lexicographical order. function hse_kvs_cursor_destroy hse_err_t hse_kvs_cursor_destroy ( struct hse_kvs_cursor * cursor ) Destroy cursor. Parameters : cursor Cursor handle from hse_kvs_cursor_create() . Return : Error status. Note : Cursor objects are not thread safe. Warning : After invoking this function, calling any other cursor functions with this handle will result in undefined behavior. Remark : cursor must not be NULL. function hse_kvs_cursor_read hse_err_t hse_kvs_cursor_read ( struct hse_kvs_cursor * cursor , unsigned int flags , const void ** key , size_t * key_len , const void ** val , size_t * val_len , bool * eof ) Iteratively access the elements pointed to by the cursor. Parameters : cursor Cursor handle from hse_kvs_cursor_create() . flags Flags for operation specialization. key Next key in sequence. key_len Length of key . val Next value in sequence. val_len Length of val . eof If true, no more key-value pairs in sequence. Return : Error status Note : If the cursor is at EOF, attempts to read from it will not change the state of the cursor. Cursor objects are not thread safe. Remark : cursor must not be NULL. key must not be NULL. key_len must not be NULL. val must not be NULL. val_len must not be NULL. eof must not be NULL. Read a key-value pair from the cursor, advancing the cursor past its current location. If the argument val is NULL, only the key is read. Flags: 0 - Reserved for future use. function hse_kvs_cursor_read_copy hse_err_t hse_kvs_cursor_read_copy ( struct hse_kvs_cursor * cursor , unsigned int flags , void * keybuf , size_t keybuf_sz , size_t * key_len , void * valbuf , size_t valbuf_sz , size_t * val_len , bool * eof ) Iteratively access the elements pointed to by the cursor. Parameters : cursor Cursor handle from hse_kvs_cursor_create() . flags Flags for operation specialization. keybuf Buffer into which the next key will be copied. keybuf_sz Size of keybuf . key_len Length of the key. valbuf Buffer into which the next key's value will be copied. valbuf_sz Size of valbuf val_len Length of val . eof If true, no more key-value pairs in sequence. Return : Error status Note : If the cursor is at EOF, attempts to read from it will not change the state of the cursor. Cursor objects are not thread safe. Remark : cursor must not be NULL. key must not be NULL. key_len must not be NULL. val must not be NULL. val_len must not be NULL. eof must not be NULL. Read a key-value pair from the cursor, advancing the cursor past its current location. The key-value pair will be copied into the user's buffer(s). If the argument valbuf is NULL, only the key is read. Flags: 0 - Reserved for future use. function hse_kvs_cursor_seek hse_err_t hse_kvs_cursor_seek ( struct hse_kvs_cursor * cursor , unsigned int flags , const void * key , size_t key_len , const void ** found , size_t * found_len ) Move the cursor to point at the key-value pair at or closest to key . Parameters : cursor Cursor handle from hse_kvs_cursor_create() . flags Flags for operation specialization. key Key to find. key_len Length of key . found If non-NULL, referent point to next key in sequence (optional). found_len If found is non-NULL, referent is length of found key. Return : Error status. Note : Cursor objects are not thread safe. Remark : cursor must not be NULL. The next hse_kvs_cursor_read() will start at this point. Both found and found_len must be non-NULL for that functionality to work. Flags: 0 - Reserved for future use. function hse_kvs_cursor_seek_range hse_err_t hse_kvs_cursor_seek_range ( struct hse_kvs_cursor * cursor , unsigned int flags , const void * filt_min , size_t filt_min_len , const void * filt_max , size_t filt_max_len , const void ** found , size_t * found_len ) Move the cursor to the closest match to key, gated by the given filter. Parameters : cursor Cursor handle from hse_kvs_cursor_create() . flags Flags for operation specialization. filt_min Filter minimum. filt_min_len Length of filt_min . filt_max Filter maximum. filt_max_len Length of filt_max . found If non-NULL, referent points to next key in sequence (optional). found_len If non-NULL, referent is length of found key (optional). Return : Error status. Note : This is only supported for forward cursors. Cursor objects are not thread safe. Remark : cursor must not be NULL. Keys read from this cursor will belong to the closed interval defined by the given filter: [ filt_min , filt_max ]. For KVSs storing segmented keys, performance will be enhanced when filt_min_len and filt_max_len are greater than or equal to the KVS key prefix length. Both found and found_len must be non-NULL for that functionality to work. Flags: 0 - Reserved for future use. function hse_kvs_cursor_update_view hse_err_t hse_kvs_cursor_update_view ( struct hse_kvs_cursor * cursor , unsigned int flags ) Update a the cursor view. Parameters : cursor Cursor handle from hse_kvs_cursor_create() . flags Flags for operation specialization. Return : Error status. Note : Cursor objects are not thread safe. Remark : cursor must not be NULL. This operation updates the snapshot view of a non-transaction cursor. It is a no-op on transaction cursors. Flags: 0 - Reserved for future use. Source code /* SPDX-License-Identifier: Apache-2.0 */ /* * Copyright (C) 2015-2021 Micron Technology, Inc. All rights reserved. */ #ifndef HSE_HSE_H #define HSE_HSE_H /* MTF_MOCK_DECL(hse) */ #include <hse/flags.h> #include <hse/limits.h> #include <hse/types.h> #include <hse/version.h> #include <stdbool.h> #include <stddef.h> #include <stdint.h> #include <stdlib.h> #include <limits.h> #ifdef __cplusplus extern \"C\" { #endif #pragma GCC visibility push(default) int hse_err_to_errno ( hse_err_t err ); size_t hse_strerror ( hse_err_t err , char * buf , size_t buf_len ); enum hse_err_ctx hse_err_to_ctx ( hse_err_t err ); hse_err_t hse_init ( const char * config , size_t paramc , const char * const * paramv ); void hse_fini ( void ); hse_err_t hse_param_get ( const char * param , char * buf , size_t buf_sz , size_t * needed_sz ); /* MTF_MOCK */ hse_err_t hse_kvdb_close ( struct hse_kvdb * kvdb ); /* MTF_MOCK */ hse_err_t hse_kvdb_create ( const char * kvdb_home , size_t paramc , const char * const * paramv ); hse_err_t hse_kvdb_drop ( const char * kvdb_home ); const char * hse_kvdb_home_get ( struct hse_kvdb * kvdb ); /* MTF_MOCK */ hse_err_t hse_kvdb_kvs_names_get ( struct hse_kvdb * kvdb , size_t * namec , char *** namev ); void hse_kvdb_kvs_names_free ( struct hse_kvdb * kvdb , char ** namev ); hse_err_t hse_kvdb_mclass_info_get ( struct hse_kvdb * kvdb , enum hse_mclass mclass , struct hse_mclass_info * info ); bool hse_kvdb_mclass_is_configured ( struct hse_kvdb * kvdb , enum hse_mclass mclass ); /* MTF_MOCK */ hse_err_t hse_kvdb_open ( const char * kvdb_home , size_t paramc , const char * const * paramv , struct hse_kvdb ** kvdb ); hse_err_t hse_kvdb_param_get ( struct hse_kvdb * kvdb , const char * param , char * buf , size_t buf_sz , size_t * needed_sz ); hse_err_t hse_kvdb_storage_add ( const char * kvdb_home , size_t paramc , const char * const * paramv ); /* MTF_MOCK */ hse_err_t hse_kvdb_sync ( struct hse_kvdb * kvdb , unsigned int flags ); const char * hse_mclass_name_get ( enum hse_mclass mclass ); hse_err_t hse_kvdb_kvs_close ( struct hse_kvs * kvs ); /* MTF_MOCK */ hse_err_t hse_kvdb_kvs_create ( struct hse_kvdb * kvdb , const char * kvs_name , size_t paramc , const char * const * paramv ); hse_err_t hse_kvdb_kvs_drop ( struct hse_kvdb * kvdb , const char * kvs_name ); hse_err_t hse_kvdb_kvs_open ( struct hse_kvdb * handle , const char * kvs_name , const size_t paramc , const char * const * paramv , struct hse_kvs ** kvs_out ); /* MTF_MOCK */ hse_err_t hse_kvs_delete ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * key , size_t key_len ); /* MTF_MOCK */ hse_err_t hse_kvs_get ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * key , size_t key_len , bool * found , void * buf , size_t buf_len , size_t * val_len ); const char * hse_kvs_name_get ( struct hse_kvs * kvs ); hse_err_t hse_kvs_param_get ( struct hse_kvs * kvs , const char * param , char * buf , size_t buf_sz , size_t * needed_sz ); /* MTF_MOCK */ hse_err_t hse_kvs_prefix_delete ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * pfx , size_t pfx_len ); /* MTF_MOCK */ hse_err_t hse_kvs_put ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * key , size_t key_len , const void * val , size_t val_len ); /* MTF_MOCK */ hse_err_t hse_kvdb_txn_abort ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ); /* MTF_MOCK */ struct hse_kvdb_txn * hse_kvdb_txn_alloc ( struct hse_kvdb * kvdb ); /* MTF_MOCK */ hse_err_t hse_kvdb_txn_begin ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ); /* MTF_MOCK */ hse_err_t hse_kvdb_txn_commit ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ); /* MTF_MOCK */ void hse_kvdb_txn_free ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ); /* MTF_MOCK */ enum hse_kvdb_txn_state hse_kvdb_txn_state_get ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ); /* MTF_MOCK */ hse_err_t hse_kvs_cursor_create ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * filter , size_t filter_len , struct hse_kvs_cursor ** cursor ); /* MTF_MOCK */ hse_err_t hse_kvs_cursor_destroy ( struct hse_kvs_cursor * cursor ); /* MTF_MOCK */ hse_err_t hse_kvs_cursor_read ( struct hse_kvs_cursor * cursor , unsigned int flags , const void ** key , size_t * key_len , const void ** val , size_t * val_len , bool * eof ); hse_err_t hse_kvs_cursor_read_copy ( struct hse_kvs_cursor * cursor , unsigned int flags , void * keybuf , size_t keybuf_sz , size_t * key_len , void * valbuf , size_t valbuf_sz , size_t * val_len , bool * eof ); /* MTF_MOCK */ hse_err_t hse_kvs_cursor_seek ( struct hse_kvs_cursor * cursor , unsigned int flags , const void * key , size_t key_len , const void ** found , size_t * found_len ); /* MTF_MOCK */ hse_err_t hse_kvs_cursor_seek_range ( struct hse_kvs_cursor * cursor , unsigned int flags , const void * filt_min , size_t filt_min_len , const void * filt_max , size_t filt_max_len , const void ** found , size_t * found_len ); /* MTF_MOCK */ hse_err_t hse_kvs_cursor_update_view ( struct hse_kvs_cursor * cursor , unsigned int flags ); #pragma GCC visibility pop #if HSE_MOCKING #include \"hse_ut.h\" #endif /* HSE_MOCKING */ #ifdef __cplusplus } #endif #endif Updated on 16 December 2021 at 14:04:27 CST","title":"hse/hse.h"},{"location":"api/Files/hse_8h/#hsehseh","text":"","title":"hse/hse.h"},{"location":"api/Files/hse_8h/#functions","text":"Name int hse_err_to_errno ( hse_err_t err) Return an hse_err_t value's errno representation. size_t hse_strerror ( hse_err_t err, char * buf, size_t buf_len) Return an hse_err_t value's string representation. enum hse_err_ctx hse_err_to_ctx ( hse_err_t err) Return an hse_err_t value's error context. hse_err_t hse_init (const char * config, size_t paramc, const char *const * paramv) Initialize the HSE subsystem. void hse_fini (void ) Shutdown the HSE subsystem. hse_err_t hse_param_get (const char * param, char * buf, size_t buf_sz, size_t * needed_sz) Get HSE global parameter. hse_err_t hse_kvdb_close (struct hse_kvdb * kvdb) Close a KVDB. hse_err_t hse_kvdb_create (const char * kvdb_home, size_t paramc, const char *const * paramv) Create a KVDB. hse_err_t hse_kvdb_drop (const char * kvdb_home) Drop a KVDB. const char * hse_kvdb_home_get (struct hse_kvdb * kvdb) Get the KVDB home. hse_err_t hse_kvdb_kvs_names_get (struct hse_kvdb * kvdb, size_t * namec, char *** namev) Get the names of the KVSs within the given KVDB. void hse_kvdb_kvs_names_free (struct hse_kvdb * kvdb, char ** namev) Free the names collection obtained through hse_kvdb_kvs_names_get() . hse_err_t hse_kvdb_mclass_info_get (struct hse_kvdb * kvdb, enum hse_mclass mclass, struct hse_mclass_info * info) Get media class information from a KVDB. bool hse_kvdb_mclass_is_configured (struct hse_kvdb * kvdb, enum hse_mclass mclass) Check if a media class is configured for a KVDB. hse_err_t hse_kvdb_open (const char * kvdb_home, size_t paramc, const char const * paramv, struct hse_kvdb * kvdb) Open a KVDB. hse_err_t hse_kvdb_param_get (struct hse_kvdb * kvdb, const char * param, char * buf, size_t buf_sz, size_t * needed_sz) Get KVDB parameter. hse_err_t hse_kvdb_storage_add (const char * kvdb_home, size_t paramc, const char *const * paramv) Add new media class storage to an existing offline KVDB. hse_err_t hse_kvdb_sync (struct hse_kvdb * kvdb, unsigned int flags) Sync data in all of the referenced KVDB's KVSs to stable media. const char * hse_mclass_name_get (enum hse_mclass mclass) Get the name of a media class. hse_err_t hse_kvdb_kvs_close (struct hse_kvs * kvs) Close an open KVS. hse_err_t hse_kvdb_kvs_create (struct hse_kvdb * kvdb, const char * kvs_name, size_t paramc, const char *const * paramv) Create a KVS within the referenced KVDB. hse_err_t hse_kvdb_kvs_drop (struct hse_kvdb * kvdb, const char * kvs_name) Drop a KVS from the referenced KVDB. hse_err_t hse_kvdb_kvs_open (struct hse_kvdb * handle, const char * kvs_name, const size_t paramc, const char const * paramv, struct hse_kvs * kvs_out) Open a KVS in a KVDB. hse_err_t hse_kvs_delete (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * key, size_t key_len) Delete the key and its associated value from the KVS. hse_err_t hse_kvs_get (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * key, size_t key_len, bool * found, void * buf, size_t buf_len, size_t * val_len) Retrieve the value for a given key from the KVS. const char * hse_kvs_name_get (struct hse_kvs * kvs) Get the name of a KVS. hse_err_t hse_kvs_param_get (struct hse_kvs * kvs, const char * param, char * buf, size_t buf_sz, size_t * needed_sz) Get KVS parameter. hse_err_t hse_kvs_prefix_delete (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * pfx, size_t pfx_len) Delete all key-value pairs matching the key prefix from a KVS storing segmented keys. hse_err_t hse_kvs_put (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * key, size_t key_len, const void * val, size_t val_len) Put a key-value pair into KVS. hse_err_t hse_kvdb_txn_abort (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Abort/rollback transaction. struct hse_kvdb_txn * hse_kvdb_txn_alloc (struct hse_kvdb * kvdb) Allocate transaction object. hse_err_t hse_kvdb_txn_begin (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Initiate transaction. hse_err_t hse_kvdb_txn_commit (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Commit all the mutations of the referenced transaction. void hse_kvdb_txn_free (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Free transaction object. enum hse_kvdb_txn_state hse_kvdb_txn_state_get (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Retrieve the state of the referenced transaction. hse_err_t hse_kvs_cursor_create (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * filter, size_t filter_len, struct hse_kvs_cursor ** cursor) Creates a cursor used to iterate over key-value pairs in a KVS. hse_err_t hse_kvs_cursor_destroy (struct hse_kvs_cursor * cursor) Destroy cursor. hse_err_t hse_kvs_cursor_read (struct hse_kvs_cursor * cursor, unsigned int flags, const void key, size_t * key_len, const void val, size_t * val_len, bool * eof) Iteratively access the elements pointed to by the cursor. hse_err_t hse_kvs_cursor_read_copy (struct hse_kvs_cursor * cursor, unsigned int flags, void * keybuf, size_t keybuf_sz, size_t * key_len, void * valbuf, size_t valbuf_sz, size_t * val_len, bool * eof) Iteratively access the elements pointed to by the cursor. hse_err_t hse_kvs_cursor_seek (struct hse_kvs_cursor * cursor, unsigned int flags, const void * key, size_t key_len, const void ** found, size_t * found_len) Move the cursor to point at the key-value pair at or closest to key . hse_err_t hse_kvs_cursor_seek_range (struct hse_kvs_cursor * cursor, unsigned int flags, const void * filt_min, size_t filt_min_len, const void * filt_max, size_t filt_max_len, const void ** found, size_t * found_len) Move the cursor to the closest match to key, gated by the given filter. hse_err_t hse_kvs_cursor_update_view (struct hse_kvs_cursor * cursor, unsigned int flags) Update a the cursor view.","title":"Functions"},{"location":"api/Files/hse_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/Files/hse_8h/#function-hse_err_to_errno","text":"int hse_err_to_errno ( hse_err_t err ) Return an hse_err_t value's errno representation. Parameters : err Error value returned from an HSE API function. Return : Error's errno equivalent. Note : This function is thread safe. The hse_err_t scalar value err is translated into its errno equivalent.","title":"function hse_err_to_errno"},{"location":"api/Files/hse_8h/#function-hse_strerror","text":"size_t hse_strerror ( hse_err_t err , char * buf , size_t buf_len ) Return an hse_err_t value's string representation. Parameters : err Error value returned from an HSE API function. buf Buffer to hold the formatted string. buf_len Length of buffer. Return : The number of characters (excluding the terminating NULL byte) which would have been written to the final string if enough space had been available. Note : This function is thread safe. The hse_err_t scalar value err is decoded into a NULL-terminated string representation giving more information about the error and where it occurred. The string will be truncated if buf_len is too small (a buf_len value of 128 is sufficient to avoid truncation of most error strings).","title":"function hse_strerror"},{"location":"api/Files/hse_8h/#function-hse_err_to_ctx","text":"enum hse_err_ctx hse_err_to_ctx ( hse_err_t err ) Return an hse_err_t value's error context. Parameters : err Error value returned from an HSE API function. Return : The error's context. Note : This function is thread safe. The error context value is retrieved from the hse_err_t value.","title":"function hse_err_to_ctx"},{"location":"api/Files/hse_8h/#function-hse_init","text":"hse_err_t hse_init ( const char * config , size_t paramc , const char * const * paramv ) Initialize the HSE subsystem. Parameters : config Path to a global configuration file. paramc Number of initialization parameters in paramv . paramv List of parameters in key=value format. Return : Error status. Note : This function is not thread safe and is idempotent. This function initializes a range of different internal HSE structures. It must be called before any other HSE functions are used.","title":"function hse_init"},{"location":"api/Files/hse_8h/#function-hse_fini","text":"void hse_fini ( void ) Shutdown the HSE subsystem. Note : This function is not thread safe. Warning : After invoking this function, calling any other HSE functions will result in undefined behavior unless HSE is re-initialized. This function cleanly finalizes a range of different internal HSE structures. It should be called prior to application exit.","title":"function hse_fini"},{"location":"api/Files/hse_8h/#function-hse_param_get","text":"hse_err_t hse_param_get ( const char * param , char * buf , size_t buf_sz , size_t * needed_sz ) Get HSE global parameter. Parameters : param Parameter name. buf Buffer for writing stringified value of parameter. buf_sz Size of buf . needed_sz Needed size of buf . Return : Error status. Note : This function is thread safe. Remark : param must not be NULL. param must be a valid parameter. Puts the stringified version of the parameter value into buf . If buf_sz is NULL, then needed_sz will still be populated.","title":"function hse_param_get"},{"location":"api/Files/hse_8h/#function-hse_kvdb_close","text":"hse_err_t hse_kvdb_close ( struct hse_kvdb * kvdb ) Close a KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() . Return : Error status. Note : This function is not thread safe. Warning : After invoking this function, calling any other KVDB functions will result in undefined behavior unless the KVDB is re-opened. Remark : kvdb must not be NULL.","title":"function hse_kvdb_close"},{"location":"api/Files/hse_8h/#function-hse_kvdb_create","text":"hse_err_t hse_kvdb_create ( const char * kvdb_home , size_t paramc , const char * const * paramv ) Create a KVDB. Parameters : kvdb_home KVDB home directory. paramc Number of configuration parameters in paramv . paramv List of parameters in key=value format. Return : Error status. Note : This function is not thread safe. Remark : kvdb_home must not be NULL.","title":"function hse_kvdb_create"},{"location":"api/Files/hse_8h/#function-hse_kvdb_drop","text":"hse_err_t hse_kvdb_drop ( const char * kvdb_home ) Drop a KVDB. Parameters : kvdb_home KVDB home directory. Return : Error status. Note : This function is not thread safe. Warning : It is an error to call this function on a KVDB that is open. Remark : kvdb_home must not be NULL.","title":"function hse_kvdb_drop"},{"location":"api/Files/hse_8h/#function-hse_kvdb_home_get","text":"const char * hse_kvdb_home_get ( struct hse_kvdb * kvdb ) Get the KVDB home. Parameters : kvdb KVDB handle from hse_kvdb_open() . Returns : NULL if given an invalid KVDB handle. Return : KVDB home. Note : This function is thread safe. Remark : kvdb must not be NULL.","title":"function hse_kvdb_home_get"},{"location":"api/Files/hse_8h/#function-hse_kvdb_kvs_names_get","text":"hse_err_t hse_kvdb_kvs_names_get ( struct hse_kvdb * kvdb , size_t * namec , char *** namev ) Get the names of the KVSs within the given KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() . namec Number of KVSs in the KVDB. namev Vector of KVSs allocated by the function. Return : Error status. Note : This function is thread safe. Remark : kvdb must not be NULL. namev must not be NULL. Key-value stores (KVSs) are opened by name. This function allocates a vector of allocated strings, each containing the NULL-terminated name of a KVS. The memory must be freed via hse_kvdb_kvs_names_free() . Example Usage: int namec ; char ** namev ; hse_err_t err ; err = hse_kvdb_kvs_names_get ( kvdb , & namec , & namev ); if ( ! err ) { for ( int i = 0 ; i < namec ; i ++ ) printf ( \"%s \\n \" , namev [ i ]); } hse_kvdb_kvs_names_free ( namev ); Filename: .c","title":"function hse_kvdb_kvs_names_get"},{"location":"api/Files/hse_8h/#function-hse_kvdb_kvs_names_free","text":"void hse_kvdb_kvs_names_free ( struct hse_kvdb * kvdb , char ** namev ) Free the names collection obtained through hse_kvdb_kvs_names_get() . Parameters : kvdb KVDB handle from hse_kvdb_open() . namev Vector of KVS names that hse_kvdb_kvs_names_get() output. Note : This function is thread safe.","title":"function hse_kvdb_kvs_names_free"},{"location":"api/Files/hse_8h/#function-hse_kvdb_mclass_info_get","text":"hse_err_t hse_kvdb_mclass_info_get ( struct hse_kvdb * kvdb , enum hse_mclass mclass , struct hse_mclass_info * info ) Get media class information from a KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() . mclass Media class to query for. info Media class information object. Return : Error status. Note : This function is thread safe. Remark : kvdb must not be NULL. info must not be NULL.","title":"function hse_kvdb_mclass_info_get"},{"location":"api/Files/hse_8h/#function-hse_kvdb_mclass_is_configured","text":"bool hse_kvdb_mclass_is_configured ( struct hse_kvdb * kvdb , enum hse_mclass mclass ) Check if a media class is configured for a KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() . mclass Media class to query for. Returns : false if kvdb or mclass is invalid. Return : Whether or not mclass is configured. Note : This function is thread safe. Remark : kvdb must not be NULL.","title":"function hse_kvdb_mclass_is_configured"},{"location":"api/Files/hse_8h/#function-hse_kvdb_open","text":"hse_err_t hse_kvdb_open ( const char * kvdb_home , size_t paramc , const char * const * paramv , struct hse_kvdb ** kvdb ) Open a KVDB. Parameters : kvdb_home KVDB home directory. paramc Number of configuration parameters in paramv . paramv List of parameters in key=value format. kvdb Handle to access the opened KVDB. Return : Error status. Note : This function is not thread safe. Remark : The KVDB must have already been created. kvdb_home must not be NULL. kvdb must not be NULL.","title":"function hse_kvdb_open"},{"location":"api/Files/hse_8h/#function-hse_kvdb_param_get","text":"hse_err_t hse_kvdb_param_get ( struct hse_kvdb * kvdb , const char * param , char * buf , size_t buf_sz , size_t * needed_sz ) Get KVDB parameter. Parameters : kvdb KVDB handle from hse_kvdb_open() . param Parameter name. buf Buffer for writing stringified value of parameter. buf_sz Size of buf . needed_sz Needed size of buf . Return : Error status. Note : This function is thread safe. Remark : kvdb must not be NULL. param must not be NULL. param must be a valid parameter. Puts the stringified version of the parameter value into buf . If buf_sz is NULL, then needed_sz will still be populated.","title":"function hse_kvdb_param_get"},{"location":"api/Files/hse_8h/#function-hse_kvdb_storage_add","text":"hse_err_t hse_kvdb_storage_add ( const char * kvdb_home , size_t paramc , const char * const * paramv ) Add new media class storage to an existing offline KVDB. Parameters : kvdb_home KVDB home directory. paramc Number of configuration parameters in paramv . paramv List of KVDB create-time parameters in key=value format. Return : Error status. Note : This function is not thread safe. Remark : kvdb_home must not be NULL. KVBD must have already been created. paramv must not be NULL.","title":"function hse_kvdb_storage_add"},{"location":"api/Files/hse_8h/#function-hse_kvdb_sync","text":"hse_err_t hse_kvdb_sync ( struct hse_kvdb * kvdb , unsigned int flags ) Sync data in all of the referenced KVDB's KVSs to stable media. Parameters : kvdb KVDB handle from hse_kvdb_open() . flags Flags for operation specialization. Return : Error status. Note : This function is thread safe. Remark : kvdb must not be NULL. Flags: HSE_KVDB_SYNC_ASYNC - Return immediately after initiating operation instead of waiting for completion.","title":"function hse_kvdb_sync"},{"location":"api/Files/hse_8h/#function-hse_mclass_name_get","text":"const char * hse_mclass_name_get ( enum hse_mclass mclass ) Get the name of a media class. Parameters : mclass Media class. Return : Name of media class. Note : This function is thread safe.","title":"function hse_mclass_name_get"},{"location":"api/Files/hse_8h/#function-hse_kvdb_kvs_close","text":"hse_err_t hse_kvdb_kvs_close ( struct hse_kvs * kvs ) Close an open KVS. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . Return : Error status. Note : This function is not thread safe. Warning : After invoking this function, calling any other KVS functions will result in undefined behavior unless the KVS is re-opened.","title":"function hse_kvdb_kvs_close"},{"location":"api/Files/hse_8h/#function-hse_kvdb_kvs_create","text":"hse_err_t hse_kvdb_kvs_create ( struct hse_kvdb * kvdb , const char * kvs_name , size_t paramc , const char * const * paramv ) Create a KVS within the referenced KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() . kvs_name KVS name. paramc Number of configuration parameters in paramv . paramv List of parameters in key=value format. Return : Error status. Note : This function is not thread safe. Remark : kvdb must not be NULL. kvs_name must be non-NULL. kvs_name must be NULL-terminated. strlen( kvs_name ) must be less than HSE_KVS_NAME_LEN_MAX. kvs_name must match the following pattern: [-_A-Za-z0-9]+. kvs_name cannot already exist.","title":"function hse_kvdb_kvs_create"},{"location":"api/Files/hse_8h/#function-hse_kvdb_kvs_drop","text":"hse_err_t hse_kvdb_kvs_drop ( struct hse_kvdb * kvdb , const char * kvs_name ) Drop a KVS from the referenced KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() . kvs_name KVS name. Return : Error status. Note : This function is not thread safe. Warning : It is an error to call this function on a KVS that is open. Remark : kvdb must not be NULL. kvs_name must not be NULL. kvs_name must be NULL-terminated.","title":"function hse_kvdb_kvs_drop"},{"location":"api/Files/hse_8h/#function-hse_kvdb_kvs_open","text":"hse_err_t hse_kvdb_kvs_open ( struct hse_kvdb * handle , const char * kvs_name , const size_t paramc , const char * const * paramv , struct hse_kvs ** kvs_out ) Open a KVS in a KVDB. Parameters : handle KVDB handle from hse_kvdb_open() . kvs_name KVS name. paramc Number of configuration parameters in paramv . paramv List of parameters in key=value format. kvs_out Handle to access the opened KVS. Return : Error status. Remark : kvdb must not be NULL. kvs_name must not be NULL. kvs_name must be NULL-terminated. kvs_out must not be NULL. This function is not thread safe.","title":"function hse_kvdb_kvs_open"},{"location":"api/Files/hse_8h/#function-hse_kvs_delete","text":"hse_err_t hse_kvs_delete ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * key , size_t key_len ) Delete the key and its associated value from the KVS. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . flags Flags for operation specialization. txn Transaction context (optional). key Key to be deleted from kvs . key_len Length of key . Return : Error status. Note : This function is thread safe. Remark : kvs must not be NULL. key must not be NULL. key_len must be within the range of [1, HSE_KVS_KEY_LEN_MAX]. It is not an error if the key does not exist within the KVS. See Transactions for information on how deletes within transactions are handled. Flags: 0 - Reserved for future use.","title":"function hse_kvs_delete"},{"location":"api/Files/hse_8h/#function-hse_kvs_get","text":"hse_err_t hse_kvs_get ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * key , size_t key_len , bool * found , void * buf , size_t buf_len , size_t * val_len ) Retrieve the value for a given key from the KVS. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . flags Flags for operation specialization. txn Transaction context (optional). key Key to get from kvs . key_len Length of key . found Whether or not key was found. buf Buffer into which the value associated with key will be copied (optional). buf_len Length of buf . val_len Actual length of value if key was found. Return : Error status. Note : This function is thread safe. Remark : kvs must not be NULL. key must not be NULL. key_len must be within the range of [1, HSE_KVS_KEY_LEN_MAX]. found must not be NULL. val_len must not be NULL. If the key exists in the KVS, then the referent of found is set to true. If the caller's value buffer is large enough then the data will be returned. Regardless, the actual length of the value is placed in val_len . See Transactions for information on how gets within transactions are handled. Flags: 0 - Reserved for future use.","title":"function hse_kvs_get"},{"location":"api/Files/hse_8h/#function-hse_kvs_name_get","text":"const char * hse_kvs_name_get ( struct hse_kvs * kvs ) Get the name of a KVS. Parameters : kvs KVS handle from hse_kvdb_kvs_open() Returns : NULL if given an invalid KVS handle. Return : KVS name. Note : This function is thread safe. Remark : kvs must not be NULL.","title":"function hse_kvs_name_get"},{"location":"api/Files/hse_8h/#function-hse_kvs_param_get","text":"hse_err_t hse_kvs_param_get ( struct hse_kvs * kvs , const char * param , char * buf , size_t buf_sz , size_t * needed_sz ) Get KVS parameter. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . param Parameter name. buf Buffer for writing stringified value of parameter. buf_sz Size of buf . needed_sz Needed size of buf . Return : Error status. Note : This function is thread safe. Remark : kvs must not be NULL. param must not be NULL. param must be a valid parameter. Puts the stringified version of the parameter value into buf . If buf_sz is NULL, then needed_sz will still be populated.","title":"function hse_kvs_param_get"},{"location":"api/Files/hse_8h/#function-hse_kvs_prefix_delete","text":"hse_err_t hse_kvs_prefix_delete ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * pfx , size_t pfx_len ) Delete all key-value pairs matching the key prefix from a KVS storing segmented keys. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . flags Flags for operation specialization. txn Transaction context (optional). pfx Prefix of keys to delete. pfx_len Length of pfx . Return : Error status. Note : This function is thread safe. Remark : kvs must not be NULL. pfx_len must be less than or equal to HSE_KVS_PFX_LEN_MAX. This interface is used to delete an entire range of segmented keys. To do this the caller passes a filter with a length equal to the KVSs key prefix length. It is not an error if no keys exist matching the filter. If there is a filtered iteration in progress, then that iteration can fail if hse_kvs_prefix_delete() is called with a filter matching the iteration. If hse_kvs_prefix_delete() is called from a transaction context, it affects no key-value mutations that are part of the same transaction. Stated differently, for KVS commands issued within a transaction, all calls to hse_kvs_prefix_delete() are treated as though they were issued serially at the beginning of the transaction regardless of the actual order these commands appeared in. Flags: 0 - Reserved for future use.","title":"function hse_kvs_prefix_delete"},{"location":"api/Files/hse_8h/#function-hse_kvs_put","text":"hse_err_t hse_kvs_put ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * key , size_t key_len , const void * val , size_t val_len ) Put a key-value pair into KVS. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . flags Flags for operation specialization. txn Transaction context (optional). key Key to put into kvs . key_len Length of key . val Value associated with key (optional). val_len Length of value . Return : Error status Note : This function is thread safe. Remark : kvs must not be NULL. key must not be NULL. key_len must be within the range of [1, HSE_KVS_KEY_LEN_MAX]. val_len must be within the range of [0, HSE_KVS_VALUE_LEN_MAX]. If the key already exists in the KVS then the value is effectively overwritten. See Transactions for information on how puts within transactions are handled. The HSE KVDB attempts to maintain reasonable QoS and for high-throughput clients this results in very short sleep's being inserted into the put path. For some kinds of data (e.g., control metadata) the client may wish to not experience that delay. For relatively low data rate uses, the caller can set the HSE_KVS_PUT_PRIO flag for an hse_kvs_put() . Care should be taken when doing so to ensure that the system does not become overrun. As a rough approximation, doing 1M priority puts per second marked as PRIO is likely an issue. On the other hand, doing 1K small puts per second marked as PRIO is almost certainly fine. If compression is enabled for the given kvs, then hse_kvs_put() will attempt to compress the value unless the HSE_KVS_PUT_VCOMP_OFF flag is given. Otherwise, the HSE_KVS_PUT_VCOMP_OFF flag is ignored. Flags: HSE_KVS_PUT_PRIO - Operation will not be throttled. HSE_KVS_PUT_VCOMP_OFF - Value will not be compressed.","title":"function hse_kvs_put"},{"location":"api/Files/hse_8h/#function-hse_kvdb_txn_abort","text":"hse_err_t hse_kvdb_txn_abort ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Abort/rollback transaction. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle from hse_kvdb_txn_alloc() . Return : Error status. Note : This function is thread safe with different transactions. Warning : The call fails if the referenced transaction is not in the ACTIVE state. Remark : kvdb must not be NULL. txn must not be NULL.","title":"function hse_kvdb_txn_abort"},{"location":"api/Files/hse_8h/#function-hse_kvdb_txn_alloc","text":"struct hse_kvdb_txn * hse_kvdb_txn_alloc ( struct hse_kvdb * kvdb ) Allocate transaction object. Parameters : kvdb KVDB handle from hse_kvdb_open() . Return : The allocated transaction structure. Note : This function is thread safe. Remark : kvdb must not be NULL. This object can and should be re-used many times to avoid the overhead of allocation.","title":"function hse_kvdb_txn_alloc"},{"location":"api/Files/hse_8h/#function-hse_kvdb_txn_begin","text":"hse_err_t hse_kvdb_txn_begin ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Initiate transaction. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle from hse_kvdb_txn_alloc() . Return : Error status. Note : This function is thread safe with different transactions. Warning : The call fails if the transaction handle refers to an ACTIVE transaction. Remark : kvdb must not be NULL. txn must not be NULL.","title":"function hse_kvdb_txn_begin"},{"location":"api/Files/hse_8h/#function-hse_kvdb_txn_commit","text":"hse_err_t hse_kvdb_txn_commit ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Commit all the mutations of the referenced transaction. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle from hse_kvdb_txn_alloc() . Return : Error status Note : This function is thread safe with different transactions. Warning : The call fails if the referenced transaction is not in the ACTIVE state. Remark : kvdb must not be NULL. txn must not be NULL.","title":"function hse_kvdb_txn_commit"},{"location":"api/Files/hse_8h/#function-hse_kvdb_txn_free","text":"void hse_kvdb_txn_free ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Free transaction object. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle. Note : If the transaction handle refers to an ACTIVE transaction, the transaction is aborted prior to being freed. This function is thread safe with different transactions. Warning : After invoking this function, calling any other transaction functions with this handle will result in undefined behavior. Remark : kvdb must not be NULL. txn must not be NULL.","title":"function hse_kvdb_txn_free"},{"location":"api/Files/hse_8h/#function-hse_kvdb_txn_state_get","text":"enum hse_kvdb_txn_state hse_kvdb_txn_state_get ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Retrieve the state of the referenced transaction. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle from hse_kvdb_txn_alloc() . Return : Transaction's state. Remark : kvdb must not be NULL. txn must not be NULL. This function is thread safe with different transactions.","title":"function hse_kvdb_txn_state_get"},{"location":"api/Files/hse_8h/#function-hse_kvs_cursor_create","text":"hse_err_t hse_kvs_cursor_create ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * filter , size_t filter_len , struct hse_kvs_cursor ** cursor ) Creates a cursor used to iterate over key-value pairs in a KVS. Parameters : kvs KVS to iterate over, handle from hse_kvdb_kvs_open() . flags Flags for operation specialization. txn Transaction context (optional). filter Iteration limited to keys matching this prefix filter (optional). filter_len Length of filter (optional). cursor Cursor handle. Return : Error status Note : This function is thread safe. Remark : kvs must not be NULL. cursor must not be NULL. Non-transactional cursors: If txn is NULL, a non-transactional cursor is created. Non-transactional cursors have an ephemeral snapshot view of the KVS at the time it the cursor is created. The snapshot view is maintained for the life of the cursor. Writes to the KVS (put, deletes, etc.) made after the cursor is created will not be visible to the cursor unless hse_kvs_cursor_update_view() is used to obtain a more recent snapshot view. Non-transactional cursors can be used on transactional and non-transactional KVSs. Transactional cursors: If txn is not NULL, it must be a valid transaction handle or undefined behavior will result. If it is a valid handle to a transaction in the ACTIVE state, a transactional cursor is created. A transaction cursor's view includes the transaction's writes overlaid on the transaction's ephemeral snapshot view of the KVS. If the transaction is committed or aborted before the cursor is destroyed, the cursor's view reverts to same snaphsot view the transaction had when first became active. The cursor will no longer be able to see the transaction's writes. Calling hse_kvs_cursor_update_view() on a transactional cursor is a no-op and has no effect on the cursor's view. Transactional cursors can only be used on transactional KVSs. Prefix vs non-prefix cursors: Parameters filter and filter_len can be used to iterate over the subset of keys in the KVS whose first filter_len bytes match the filter_len bytes pointed to by filter . A prefix cursor is created when: KVS was created with pfx_len > 0 (i.e., it is a prefix KVS), and filter != NULL and filter_len >= pfx_len . Otherwise, a non-prefix cursor is created. Applications should arrange their key-value data to avoid the need for non-prefix cursors as they are significantly slower and more resource-intensive than prefix cursors. Note that simply using a filter doesn't create a prefix cursor \u2013 it must meet the two conditions listed above. Flags: HSE_CURSOR_CREATE_REV - Iterate in reverse lexicographical order.","title":"function hse_kvs_cursor_create"},{"location":"api/Files/hse_8h/#function-hse_kvs_cursor_destroy","text":"hse_err_t hse_kvs_cursor_destroy ( struct hse_kvs_cursor * cursor ) Destroy cursor. Parameters : cursor Cursor handle from hse_kvs_cursor_create() . Return : Error status. Note : Cursor objects are not thread safe. Warning : After invoking this function, calling any other cursor functions with this handle will result in undefined behavior. Remark : cursor must not be NULL.","title":"function hse_kvs_cursor_destroy"},{"location":"api/Files/hse_8h/#function-hse_kvs_cursor_read","text":"hse_err_t hse_kvs_cursor_read ( struct hse_kvs_cursor * cursor , unsigned int flags , const void ** key , size_t * key_len , const void ** val , size_t * val_len , bool * eof ) Iteratively access the elements pointed to by the cursor. Parameters : cursor Cursor handle from hse_kvs_cursor_create() . flags Flags for operation specialization. key Next key in sequence. key_len Length of key . val Next value in sequence. val_len Length of val . eof If true, no more key-value pairs in sequence. Return : Error status Note : If the cursor is at EOF, attempts to read from it will not change the state of the cursor. Cursor objects are not thread safe. Remark : cursor must not be NULL. key must not be NULL. key_len must not be NULL. val must not be NULL. val_len must not be NULL. eof must not be NULL. Read a key-value pair from the cursor, advancing the cursor past its current location. If the argument val is NULL, only the key is read. Flags: 0 - Reserved for future use.","title":"function hse_kvs_cursor_read"},{"location":"api/Files/hse_8h/#function-hse_kvs_cursor_read_copy","text":"hse_err_t hse_kvs_cursor_read_copy ( struct hse_kvs_cursor * cursor , unsigned int flags , void * keybuf , size_t keybuf_sz , size_t * key_len , void * valbuf , size_t valbuf_sz , size_t * val_len , bool * eof ) Iteratively access the elements pointed to by the cursor. Parameters : cursor Cursor handle from hse_kvs_cursor_create() . flags Flags for operation specialization. keybuf Buffer into which the next key will be copied. keybuf_sz Size of keybuf . key_len Length of the key. valbuf Buffer into which the next key's value will be copied. valbuf_sz Size of valbuf val_len Length of val . eof If true, no more key-value pairs in sequence. Return : Error status Note : If the cursor is at EOF, attempts to read from it will not change the state of the cursor. Cursor objects are not thread safe. Remark : cursor must not be NULL. key must not be NULL. key_len must not be NULL. val must not be NULL. val_len must not be NULL. eof must not be NULL. Read a key-value pair from the cursor, advancing the cursor past its current location. The key-value pair will be copied into the user's buffer(s). If the argument valbuf is NULL, only the key is read. Flags: 0 - Reserved for future use.","title":"function hse_kvs_cursor_read_copy"},{"location":"api/Files/hse_8h/#function-hse_kvs_cursor_seek","text":"hse_err_t hse_kvs_cursor_seek ( struct hse_kvs_cursor * cursor , unsigned int flags , const void * key , size_t key_len , const void ** found , size_t * found_len ) Move the cursor to point at the key-value pair at or closest to key . Parameters : cursor Cursor handle from hse_kvs_cursor_create() . flags Flags for operation specialization. key Key to find. key_len Length of key . found If non-NULL, referent point to next key in sequence (optional). found_len If found is non-NULL, referent is length of found key. Return : Error status. Note : Cursor objects are not thread safe. Remark : cursor must not be NULL. The next hse_kvs_cursor_read() will start at this point. Both found and found_len must be non-NULL for that functionality to work. Flags: 0 - Reserved for future use.","title":"function hse_kvs_cursor_seek"},{"location":"api/Files/hse_8h/#function-hse_kvs_cursor_seek_range","text":"hse_err_t hse_kvs_cursor_seek_range ( struct hse_kvs_cursor * cursor , unsigned int flags , const void * filt_min , size_t filt_min_len , const void * filt_max , size_t filt_max_len , const void ** found , size_t * found_len ) Move the cursor to the closest match to key, gated by the given filter. Parameters : cursor Cursor handle from hse_kvs_cursor_create() . flags Flags for operation specialization. filt_min Filter minimum. filt_min_len Length of filt_min . filt_max Filter maximum. filt_max_len Length of filt_max . found If non-NULL, referent points to next key in sequence (optional). found_len If non-NULL, referent is length of found key (optional). Return : Error status. Note : This is only supported for forward cursors. Cursor objects are not thread safe. Remark : cursor must not be NULL. Keys read from this cursor will belong to the closed interval defined by the given filter: [ filt_min , filt_max ]. For KVSs storing segmented keys, performance will be enhanced when filt_min_len and filt_max_len are greater than or equal to the KVS key prefix length. Both found and found_len must be non-NULL for that functionality to work. Flags: 0 - Reserved for future use.","title":"function hse_kvs_cursor_seek_range"},{"location":"api/Files/hse_8h/#function-hse_kvs_cursor_update_view","text":"hse_err_t hse_kvs_cursor_update_view ( struct hse_kvs_cursor * cursor , unsigned int flags ) Update a the cursor view. Parameters : cursor Cursor handle from hse_kvs_cursor_create() . flags Flags for operation specialization. Return : Error status. Note : Cursor objects are not thread safe. Remark : cursor must not be NULL. This operation updates the snapshot view of a non-transaction cursor. It is a no-op on transaction cursors. Flags: 0 - Reserved for future use.","title":"function hse_kvs_cursor_update_view"},{"location":"api/Files/hse_8h/#source-code","text":"/* SPDX-License-Identifier: Apache-2.0 */ /* * Copyright (C) 2015-2021 Micron Technology, Inc. All rights reserved. */ #ifndef HSE_HSE_H #define HSE_HSE_H /* MTF_MOCK_DECL(hse) */ #include <hse/flags.h> #include <hse/limits.h> #include <hse/types.h> #include <hse/version.h> #include <stdbool.h> #include <stddef.h> #include <stdint.h> #include <stdlib.h> #include <limits.h> #ifdef __cplusplus extern \"C\" { #endif #pragma GCC visibility push(default) int hse_err_to_errno ( hse_err_t err ); size_t hse_strerror ( hse_err_t err , char * buf , size_t buf_len ); enum hse_err_ctx hse_err_to_ctx ( hse_err_t err ); hse_err_t hse_init ( const char * config , size_t paramc , const char * const * paramv ); void hse_fini ( void ); hse_err_t hse_param_get ( const char * param , char * buf , size_t buf_sz , size_t * needed_sz ); /* MTF_MOCK */ hse_err_t hse_kvdb_close ( struct hse_kvdb * kvdb ); /* MTF_MOCK */ hse_err_t hse_kvdb_create ( const char * kvdb_home , size_t paramc , const char * const * paramv ); hse_err_t hse_kvdb_drop ( const char * kvdb_home ); const char * hse_kvdb_home_get ( struct hse_kvdb * kvdb ); /* MTF_MOCK */ hse_err_t hse_kvdb_kvs_names_get ( struct hse_kvdb * kvdb , size_t * namec , char *** namev ); void hse_kvdb_kvs_names_free ( struct hse_kvdb * kvdb , char ** namev ); hse_err_t hse_kvdb_mclass_info_get ( struct hse_kvdb * kvdb , enum hse_mclass mclass , struct hse_mclass_info * info ); bool hse_kvdb_mclass_is_configured ( struct hse_kvdb * kvdb , enum hse_mclass mclass ); /* MTF_MOCK */ hse_err_t hse_kvdb_open ( const char * kvdb_home , size_t paramc , const char * const * paramv , struct hse_kvdb ** kvdb ); hse_err_t hse_kvdb_param_get ( struct hse_kvdb * kvdb , const char * param , char * buf , size_t buf_sz , size_t * needed_sz ); hse_err_t hse_kvdb_storage_add ( const char * kvdb_home , size_t paramc , const char * const * paramv ); /* MTF_MOCK */ hse_err_t hse_kvdb_sync ( struct hse_kvdb * kvdb , unsigned int flags ); const char * hse_mclass_name_get ( enum hse_mclass mclass ); hse_err_t hse_kvdb_kvs_close ( struct hse_kvs * kvs ); /* MTF_MOCK */ hse_err_t hse_kvdb_kvs_create ( struct hse_kvdb * kvdb , const char * kvs_name , size_t paramc , const char * const * paramv ); hse_err_t hse_kvdb_kvs_drop ( struct hse_kvdb * kvdb , const char * kvs_name ); hse_err_t hse_kvdb_kvs_open ( struct hse_kvdb * handle , const char * kvs_name , const size_t paramc , const char * const * paramv , struct hse_kvs ** kvs_out ); /* MTF_MOCK */ hse_err_t hse_kvs_delete ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * key , size_t key_len ); /* MTF_MOCK */ hse_err_t hse_kvs_get ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * key , size_t key_len , bool * found , void * buf , size_t buf_len , size_t * val_len ); const char * hse_kvs_name_get ( struct hse_kvs * kvs ); hse_err_t hse_kvs_param_get ( struct hse_kvs * kvs , const char * param , char * buf , size_t buf_sz , size_t * needed_sz ); /* MTF_MOCK */ hse_err_t hse_kvs_prefix_delete ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * pfx , size_t pfx_len ); /* MTF_MOCK */ hse_err_t hse_kvs_put ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * key , size_t key_len , const void * val , size_t val_len ); /* MTF_MOCK */ hse_err_t hse_kvdb_txn_abort ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ); /* MTF_MOCK */ struct hse_kvdb_txn * hse_kvdb_txn_alloc ( struct hse_kvdb * kvdb ); /* MTF_MOCK */ hse_err_t hse_kvdb_txn_begin ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ); /* MTF_MOCK */ hse_err_t hse_kvdb_txn_commit ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ); /* MTF_MOCK */ void hse_kvdb_txn_free ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ); /* MTF_MOCK */ enum hse_kvdb_txn_state hse_kvdb_txn_state_get ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ); /* MTF_MOCK */ hse_err_t hse_kvs_cursor_create ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * filter , size_t filter_len , struct hse_kvs_cursor ** cursor ); /* MTF_MOCK */ hse_err_t hse_kvs_cursor_destroy ( struct hse_kvs_cursor * cursor ); /* MTF_MOCK */ hse_err_t hse_kvs_cursor_read ( struct hse_kvs_cursor * cursor , unsigned int flags , const void ** key , size_t * key_len , const void ** val , size_t * val_len , bool * eof ); hse_err_t hse_kvs_cursor_read_copy ( struct hse_kvs_cursor * cursor , unsigned int flags , void * keybuf , size_t keybuf_sz , size_t * key_len , void * valbuf , size_t valbuf_sz , size_t * val_len , bool * eof ); /* MTF_MOCK */ hse_err_t hse_kvs_cursor_seek ( struct hse_kvs_cursor * cursor , unsigned int flags , const void * key , size_t key_len , const void ** found , size_t * found_len ); /* MTF_MOCK */ hse_err_t hse_kvs_cursor_seek_range ( struct hse_kvs_cursor * cursor , unsigned int flags , const void * filt_min , size_t filt_min_len , const void * filt_max , size_t filt_max_len , const void ** found , size_t * found_len ); /* MTF_MOCK */ hse_err_t hse_kvs_cursor_update_view ( struct hse_kvs_cursor * cursor , unsigned int flags ); #pragma GCC visibility pop #if HSE_MOCKING #include \"hse_ut.h\" #endif /* HSE_MOCKING */ #ifdef __cplusplus } #endif #endif Updated on 16 December 2021 at 14:04:27 CST","title":"Source code"},{"location":"api/Files/limits_8h/","text":"hse/limits.h Defines Name HSE_KVS_COUNT_MAX Maximum number of KVSs contained within one KVDB. HSE_KVS_KEY_LEN_MAX Maximum key length. HSE_KVS_NAME_LEN_MAX Maximum length of a KVS name. HSE_KVS_PFX_LEN_MAX Max key prefix length. HSE_KVS_VALUE_LEN_MAX Max value length is 1MiB. Macros Documentation define HSE_KVS_COUNT_MAX #define HSE_KVS_COUNT_MAX (256) Maximum number of KVSs contained within one KVDB. define HSE_KVS_KEY_LEN_MAX #define HSE_KVS_KEY_LEN_MAX 1344 Maximum key length. A common requirement clients have for key length is 1024. Combined with a discriminant and (potentially) a chunk key, this pushes us to 1030 bytes keys. Looking at the packing for the on-media format for data, we can have at most 3 keys of such large size in a 4k page. Lopping off 64-bytes for other data, and we can have 3 keys of 1344 bytes. Keys need not be NULL-terminated. define HSE_KVS_NAME_LEN_MAX #define HSE_KVS_NAME_LEN_MAX 32 Maximum length of a KVS name. KVS names are NULL-terminated strings. The string plus the NULL-terminator must fit into a HSE_KVS_NAME_LEN_MAX byte buffer. define HSE_KVS_PFX_LEN_MAX #define HSE_KVS_PFX_LEN_MAX 32 Max key prefix length. define HSE_KVS_VALUE_LEN_MAX #define HSE_KVS_VALUE_LEN_MAX (1024 * 1024) Max value length is 1MiB. Values need not be NULL-terminated. Source code /* SPDX-License-Identifier: Apache-2.0 */ /* * Copyright (C) 2015-2021 Micron Technology, Inc. All rights reserved. */ #ifndef HSE_LIMITS_H #define HSE_LIMITS_H #ifdef __cplusplus extern \"C\" { #endif #define HSE_KVS_COUNT_MAX (256) #define HSE_KVS_KEY_LEN_MAX 1344 #define HSE_KVS_NAME_LEN_MAX 32 #define HSE_KVS_PFX_LEN_MAX 32 #define HSE_KVS_VALUE_LEN_MAX (1024 * 1024) #ifdef __cplusplus } #endif #endif Updated on 16 December 2021 at 14:04:28 CST","title":"hse/limits.h"},{"location":"api/Files/limits_8h/#hselimitsh","text":"","title":"hse/limits.h"},{"location":"api/Files/limits_8h/#defines","text":"Name HSE_KVS_COUNT_MAX Maximum number of KVSs contained within one KVDB. HSE_KVS_KEY_LEN_MAX Maximum key length. HSE_KVS_NAME_LEN_MAX Maximum length of a KVS name. HSE_KVS_PFX_LEN_MAX Max key prefix length. HSE_KVS_VALUE_LEN_MAX Max value length is 1MiB.","title":"Defines"},{"location":"api/Files/limits_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"api/Files/limits_8h/#define-hse_kvs_count_max","text":"#define HSE_KVS_COUNT_MAX (256) Maximum number of KVSs contained within one KVDB.","title":"define HSE_KVS_COUNT_MAX"},{"location":"api/Files/limits_8h/#define-hse_kvs_key_len_max","text":"#define HSE_KVS_KEY_LEN_MAX 1344 Maximum key length. A common requirement clients have for key length is 1024. Combined with a discriminant and (potentially) a chunk key, this pushes us to 1030 bytes keys. Looking at the packing for the on-media format for data, we can have at most 3 keys of such large size in a 4k page. Lopping off 64-bytes for other data, and we can have 3 keys of 1344 bytes. Keys need not be NULL-terminated.","title":"define HSE_KVS_KEY_LEN_MAX"},{"location":"api/Files/limits_8h/#define-hse_kvs_name_len_max","text":"#define HSE_KVS_NAME_LEN_MAX 32 Maximum length of a KVS name. KVS names are NULL-terminated strings. The string plus the NULL-terminator must fit into a HSE_KVS_NAME_LEN_MAX byte buffer.","title":"define HSE_KVS_NAME_LEN_MAX"},{"location":"api/Files/limits_8h/#define-hse_kvs_pfx_len_max","text":"#define HSE_KVS_PFX_LEN_MAX 32 Max key prefix length.","title":"define HSE_KVS_PFX_LEN_MAX"},{"location":"api/Files/limits_8h/#define-hse_kvs_value_len_max","text":"#define HSE_KVS_VALUE_LEN_MAX (1024 * 1024) Max value length is 1MiB. Values need not be NULL-terminated.","title":"define HSE_KVS_VALUE_LEN_MAX"},{"location":"api/Files/limits_8h/#source-code","text":"/* SPDX-License-Identifier: Apache-2.0 */ /* * Copyright (C) 2015-2021 Micron Technology, Inc. All rights reserved. */ #ifndef HSE_LIMITS_H #define HSE_LIMITS_H #ifdef __cplusplus extern \"C\" { #endif #define HSE_KVS_COUNT_MAX (256) #define HSE_KVS_KEY_LEN_MAX 1344 #define HSE_KVS_NAME_LEN_MAX 32 #define HSE_KVS_PFX_LEN_MAX 32 #define HSE_KVS_VALUE_LEN_MAX (1024 * 1024) #ifdef __cplusplus } #endif #endif Updated on 16 December 2021 at 14:04:28 CST","title":"Source code"},{"location":"api/Files/types_8h/","text":"hse/types.h Data Structures Name struct hse_mclass_info Media class information. Types Name enum hse_err_ctx { HSE_ERR_CTX_NONE} Error context values. enum hse_mclass { HSE_MCLASS_CAPACITY = 0, HSE_MCLASS_STAGING = 1, HSE_MCLASS_PMEM = 2} Media classes. enum hse_kvdb_txn_state { HSE_KVDB_TXN_INVALID = 0, HSE_KVDB_TXN_ACTIVE = 1, HSE_KVDB_TXN_COMMITTED = 2, HSE_KVDB_TXN_ABORTED = 3} Transaction state. typedef uint64_t hse_err_t Generic return type for the HSE library. Defines Name HSE_ERR_CTX_BASE Smallest error context value. HSE_ERR_CTX_MAX Largest error context value. HSE_MCLASS_BASE HSE_MCLASS_MAX HSE_MCLASS_COUNT HSE_MCLASS_CAPACITY_NAME HSE_MCLASS_STAGING_NAME HSE_MCLASS_PMEM_NAME Types Documentation enum hse_err_ctx Enumerator Value Description HSE_ERR_CTX_NONE No context Error context values. enum hse_mclass Enumerator Value Description HSE_MCLASS_CAPACITY 0 HSE_MCLASS_STAGING 1 HSE_MCLASS_PMEM 2 Media classes. enum hse_kvdb_txn_state Enumerator Value Description HSE_KVDB_TXN_INVALID 0 invalid state HSE_KVDB_TXN_ACTIVE 1 active state HSE_KVDB_TXN_COMMITTED 2 committed state HSE_KVDB_TXN_ABORTED 3 aborted state Transaction state. typedef hse_err_t hse_err_t ; Generic return type for the HSE library. If this scalar quantity is 0 then the call succeeded. If it is non-zero, then the 64-bit quantity can be used by the client in two ways: (1) call hse_err_to_errno() to get a mapping to a POSIX errno value, and (2) call hse_strerror() to get a textual reference about what error occurred and where. The following special errno error codes are worth mentioning here. errno Caller action EAGAIN The caller is expected to retry the operation. ECANCELED The caller is expected to retry the operation in a new transaction. See [write conflicts]. e.g., the code snippet below shows a typical non-transactional usage: int retries = 0 ; hse_err_t ret = 0 ; while ( retries < MAX_RETRIES ) { ret = hse_kvs_put ( kvs_handle , flags , txn , key , k_len , val , v_len ) if ( EAGAIN != hse_err_to_errno ( ret )) break ; retries ++ ; } Filename: .c Macros Documentation define HSE_ERR_CTX_BASE #define HSE_ERR_CTX_BASE [HSE_ERR_CTX_NONE](/2.x/api/Modules/group__ERRORS/#enumvalue-hse_err_ctx_none) Smallest error context value. define HSE_ERR_CTX_MAX #define HSE_ERR_CTX_MAX [HSE_ERR_CTX_NONE](/2.x/api/Modules/group__ERRORS/#enumvalue-hse_err_ctx_none) Largest error context value. define HSE_MCLASS_BASE #define HSE_MCLASS_BASE HSE_MCLASS_CAPACITY Capacity media class. define HSE_MCLASS_MAX #define HSE_MCLASS_MAX HSE_MCLASS_PMEM Staging media class. define HSE_MCLASS_COUNT #define HSE_MCLASS_COUNT ([HSE_MCLASS_MAX](/2.x/api/Modules/group__KVDB/#define-hse_mclass_max) + 1) PMEM media class. define HSE_MCLASS_CAPACITY_NAME #define HSE_MCLASS_CAPACITY_NAME \"capacity\" Capacity media class name. define HSE_MCLASS_STAGING_NAME #define HSE_MCLASS_STAGING_NAME \"staging\" Staging media class name. define HSE_MCLASS_PMEM_NAME #define HSE_MCLASS_PMEM_NAME \"pmem\" PMEM media class name. Source code /* SPDX-License-Identifier: Apache-2.0 */ /* * Copyright (C) 2021 Micron Technology, Inc. All rights reserved. */ #ifndef HSE_TYPES_H #define HSE_TYPES_H #ifdef __cplusplus extern \"C\" { #endif #include <inttypes.h> #include <limits.h> typedef uint64_t hse_err_t ; enum hse_err_ctx { HSE_ERR_CTX_NONE , }; #define HSE_ERR_CTX_BASE HSE_ERR_CTX_NONE #define HSE_ERR_CTX_MAX HSE_ERR_CTX_NONE struct hse_kvdb ; enum hse_mclass { HSE_MCLASS_CAPACITY = 0 , HSE_MCLASS_STAGING = 1 , HSE_MCLASS_PMEM = 2 , }; #define HSE_MCLASS_BASE HSE_MCLASS_CAPACITY #define HSE_MCLASS_MAX HSE_MCLASS_PMEM #define HSE_MCLASS_COUNT (HSE_MCLASS_MAX + 1) #define HSE_MCLASS_CAPACITY_NAME \"capacity\" #define HSE_MCLASS_STAGING_NAME \"staging\" #define HSE_MCLASS_PMEM_NAME \"pmem\" struct hse_mclass_info { uint64_t mi_allocated_bytes ; uint64_t mi_used_bytes ; uint64_t mi_reserved [ 8 ]; char mi_path [ PATH_MAX ]; }; struct hse_kvs ; struct hse_kvs_cursor ; struct hse_kvdb_txn ; enum hse_kvdb_txn_state { HSE_KVDB_TXN_INVALID = 0 , HSE_KVDB_TXN_ACTIVE = 1 , HSE_KVDB_TXN_COMMITTED = 2 , HSE_KVDB_TXN_ABORTED = 3 , }; #ifdef __cplusplus } #endif #endif Updated on 16 December 2021 at 14:04:28 CST","title":"hse/types.h"},{"location":"api/Files/types_8h/#hsetypesh","text":"","title":"hse/types.h"},{"location":"api/Files/types_8h/#data-structures","text":"Name struct hse_mclass_info Media class information.","title":"Data Structures"},{"location":"api/Files/types_8h/#types","text":"Name enum hse_err_ctx { HSE_ERR_CTX_NONE} Error context values. enum hse_mclass { HSE_MCLASS_CAPACITY = 0, HSE_MCLASS_STAGING = 1, HSE_MCLASS_PMEM = 2} Media classes. enum hse_kvdb_txn_state { HSE_KVDB_TXN_INVALID = 0, HSE_KVDB_TXN_ACTIVE = 1, HSE_KVDB_TXN_COMMITTED = 2, HSE_KVDB_TXN_ABORTED = 3} Transaction state. typedef uint64_t hse_err_t Generic return type for the HSE library.","title":"Types"},{"location":"api/Files/types_8h/#defines","text":"Name HSE_ERR_CTX_BASE Smallest error context value. HSE_ERR_CTX_MAX Largest error context value. HSE_MCLASS_BASE HSE_MCLASS_MAX HSE_MCLASS_COUNT HSE_MCLASS_CAPACITY_NAME HSE_MCLASS_STAGING_NAME HSE_MCLASS_PMEM_NAME","title":"Defines"},{"location":"api/Files/types_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"api/Files/types_8h/#enum-hse_err_ctx","text":"Enumerator Value Description HSE_ERR_CTX_NONE No context Error context values.","title":"enum hse_err_ctx"},{"location":"api/Files/types_8h/#enum-hse_mclass","text":"Enumerator Value Description HSE_MCLASS_CAPACITY 0 HSE_MCLASS_STAGING 1 HSE_MCLASS_PMEM 2 Media classes.","title":"enum hse_mclass"},{"location":"api/Files/types_8h/#enum-hse_kvdb_txn_state","text":"Enumerator Value Description HSE_KVDB_TXN_INVALID 0 invalid state HSE_KVDB_TXN_ACTIVE 1 active state HSE_KVDB_TXN_COMMITTED 2 committed state HSE_KVDB_TXN_ABORTED 3 aborted state Transaction state.","title":"enum hse_kvdb_txn_state"},{"location":"api/Files/types_8h/#typedef-hse_err_t","text":"hse_err_t ; Generic return type for the HSE library. If this scalar quantity is 0 then the call succeeded. If it is non-zero, then the 64-bit quantity can be used by the client in two ways: (1) call hse_err_to_errno() to get a mapping to a POSIX errno value, and (2) call hse_strerror() to get a textual reference about what error occurred and where. The following special errno error codes are worth mentioning here. errno Caller action EAGAIN The caller is expected to retry the operation. ECANCELED The caller is expected to retry the operation in a new transaction. See [write conflicts]. e.g., the code snippet below shows a typical non-transactional usage: int retries = 0 ; hse_err_t ret = 0 ; while ( retries < MAX_RETRIES ) { ret = hse_kvs_put ( kvs_handle , flags , txn , key , k_len , val , v_len ) if ( EAGAIN != hse_err_to_errno ( ret )) break ; retries ++ ; } Filename: .c","title":"typedef hse_err_t"},{"location":"api/Files/types_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"api/Files/types_8h/#define-hse_err_ctx_base","text":"#define HSE_ERR_CTX_BASE [HSE_ERR_CTX_NONE](/2.x/api/Modules/group__ERRORS/#enumvalue-hse_err_ctx_none) Smallest error context value.","title":"define HSE_ERR_CTX_BASE"},{"location":"api/Files/types_8h/#define-hse_err_ctx_max","text":"#define HSE_ERR_CTX_MAX [HSE_ERR_CTX_NONE](/2.x/api/Modules/group__ERRORS/#enumvalue-hse_err_ctx_none) Largest error context value.","title":"define HSE_ERR_CTX_MAX"},{"location":"api/Files/types_8h/#define-hse_mclass_base","text":"#define HSE_MCLASS_BASE HSE_MCLASS_CAPACITY Capacity media class.","title":"define HSE_MCLASS_BASE"},{"location":"api/Files/types_8h/#define-hse_mclass_max","text":"#define HSE_MCLASS_MAX HSE_MCLASS_PMEM Staging media class.","title":"define HSE_MCLASS_MAX"},{"location":"api/Files/types_8h/#define-hse_mclass_count","text":"#define HSE_MCLASS_COUNT ([HSE_MCLASS_MAX](/2.x/api/Modules/group__KVDB/#define-hse_mclass_max) + 1) PMEM media class.","title":"define HSE_MCLASS_COUNT"},{"location":"api/Files/types_8h/#define-hse_mclass_capacity_name","text":"#define HSE_MCLASS_CAPACITY_NAME \"capacity\" Capacity media class name.","title":"define HSE_MCLASS_CAPACITY_NAME"},{"location":"api/Files/types_8h/#define-hse_mclass_staging_name","text":"#define HSE_MCLASS_STAGING_NAME \"staging\" Staging media class name.","title":"define HSE_MCLASS_STAGING_NAME"},{"location":"api/Files/types_8h/#define-hse_mclass_pmem_name","text":"#define HSE_MCLASS_PMEM_NAME \"pmem\" PMEM media class name.","title":"define HSE_MCLASS_PMEM_NAME"},{"location":"api/Files/types_8h/#source-code","text":"/* SPDX-License-Identifier: Apache-2.0 */ /* * Copyright (C) 2021 Micron Technology, Inc. All rights reserved. */ #ifndef HSE_TYPES_H #define HSE_TYPES_H #ifdef __cplusplus extern \"C\" { #endif #include <inttypes.h> #include <limits.h> typedef uint64_t hse_err_t ; enum hse_err_ctx { HSE_ERR_CTX_NONE , }; #define HSE_ERR_CTX_BASE HSE_ERR_CTX_NONE #define HSE_ERR_CTX_MAX HSE_ERR_CTX_NONE struct hse_kvdb ; enum hse_mclass { HSE_MCLASS_CAPACITY = 0 , HSE_MCLASS_STAGING = 1 , HSE_MCLASS_PMEM = 2 , }; #define HSE_MCLASS_BASE HSE_MCLASS_CAPACITY #define HSE_MCLASS_MAX HSE_MCLASS_PMEM #define HSE_MCLASS_COUNT (HSE_MCLASS_MAX + 1) #define HSE_MCLASS_CAPACITY_NAME \"capacity\" #define HSE_MCLASS_STAGING_NAME \"staging\" #define HSE_MCLASS_PMEM_NAME \"pmem\" struct hse_mclass_info { uint64_t mi_allocated_bytes ; uint64_t mi_used_bytes ; uint64_t mi_reserved [ 8 ]; char mi_path [ PATH_MAX ]; }; struct hse_kvs ; struct hse_kvs_cursor ; struct hse_kvdb_txn ; enum hse_kvdb_txn_state { HSE_KVDB_TXN_INVALID = 0 , HSE_KVDB_TXN_ACTIVE = 1 , HSE_KVDB_TXN_COMMITTED = 2 , HSE_KVDB_TXN_ABORTED = 3 , }; #ifdef __cplusplus } #endif #endif Updated on 16 December 2021 at 14:04:28 CST","title":"Source code"},{"location":"api/Files/version_8h/","text":"hse/version.h Defines Name HSE_VERSION_STRING A string representing the HSE version. HSE_VERSION_MAJOR Major version of HSE. HSE_VERSION_MINOR Minor version of HSE. HSE_VERSION_PATCH Patch version of HSE. Macros Documentation define HSE_VERSION_STRING #define HSE_VERSION_STRING \"r2.1.0-0-g90a19368\" A string representing the HSE version. define HSE_VERSION_MAJOR #define HSE_VERSION_MAJOR 2 Major version of HSE. define HSE_VERSION_MINOR #define HSE_VERSION_MINOR 1 Minor version of HSE. define HSE_VERSION_PATCH #define HSE_VERSION_PATCH 0 Patch version of HSE. Source code /* SPDX-License-Identifier: Apache-2.0 */ /* * Copyright (C) 2015-2021 Micron Technology, Inc. All rights reserved. */ #ifndef HSE_VERSION_H #define HSE_VERSION_H #ifdef __cplusplus extern \"C\" { #endif #define HSE_VERSION_STRING \"r2.1.0-0-g90a19368\" /* clang-format off */ #define HSE_VERSION_MAJOR 2 #define HSE_VERSION_MINOR 1 #define HSE_VERSION_PATCH 0 /* clang-format on */ #ifdef __cplusplus } #endif #endif Updated on 16 December 2021 at 14:04:27 CST","title":"hse/version.h"},{"location":"api/Files/version_8h/#hseversionh","text":"","title":"hse/version.h"},{"location":"api/Files/version_8h/#defines","text":"Name HSE_VERSION_STRING A string representing the HSE version. HSE_VERSION_MAJOR Major version of HSE. HSE_VERSION_MINOR Minor version of HSE. HSE_VERSION_PATCH Patch version of HSE.","title":"Defines"},{"location":"api/Files/version_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"api/Files/version_8h/#define-hse_version_string","text":"#define HSE_VERSION_STRING \"r2.1.0-0-g90a19368\" A string representing the HSE version.","title":"define HSE_VERSION_STRING"},{"location":"api/Files/version_8h/#define-hse_version_major","text":"#define HSE_VERSION_MAJOR 2 Major version of HSE.","title":"define HSE_VERSION_MAJOR"},{"location":"api/Files/version_8h/#define-hse_version_minor","text":"#define HSE_VERSION_MINOR 1 Minor version of HSE.","title":"define HSE_VERSION_MINOR"},{"location":"api/Files/version_8h/#define-hse_version_patch","text":"#define HSE_VERSION_PATCH 0 Patch version of HSE.","title":"define HSE_VERSION_PATCH"},{"location":"api/Files/version_8h/#source-code","text":"/* SPDX-License-Identifier: Apache-2.0 */ /* * Copyright (C) 2015-2021 Micron Technology, Inc. All rights reserved. */ #ifndef HSE_VERSION_H #define HSE_VERSION_H #ifdef __cplusplus extern \"C\" { #endif #define HSE_VERSION_STRING \"r2.1.0-0-g90a19368\" /* clang-format off */ #define HSE_VERSION_MAJOR 2 #define HSE_VERSION_MINOR 1 #define HSE_VERSION_PATCH 0 /* clang-format on */ #ifdef __cplusplus } #endif #endif Updated on 16 December 2021 at 14:04:27 CST","title":"Source code"},{"location":"api/Modules/","text":"Modules group Cursors group Errors group Key-Value Database (KVDB) group Key-Value Store (KVS) group Subsystem group Transactions group Version Information Updated on 16 December 2021 at 14:04:28 CST","title":"Modules"},{"location":"api/Modules/#modules","text":"group Cursors group Errors group Key-Value Database (KVDB) group Key-Value Store (KVS) group Subsystem group Transactions group Version Information Updated on 16 December 2021 at 14:04:28 CST","title":"Modules"},{"location":"api/Modules/group__CURSORS/","text":"Cursors More... Data Structures Name struct hse_kvs_cursor Opaque structure, a pointer to which is a handle to a cursor within a KVS. Functions Name hse_err_t hse_kvs_cursor_create (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * filter, size_t filter_len, struct hse_kvs_cursor ** cursor) Creates a cursor used to iterate over key-value pairs in a KVS. hse_err_t hse_kvs_cursor_destroy (struct hse_kvs_cursor * cursor) Destroy cursor. hse_err_t hse_kvs_cursor_read (struct hse_kvs_cursor * cursor, unsigned int flags, const void key, size_t * key_len, const void val, size_t * val_len, bool * eof) Iteratively access the elements pointed to by the cursor. hse_err_t hse_kvs_cursor_read_copy (struct hse_kvs_cursor * cursor, unsigned int flags, void * keybuf, size_t keybuf_sz, size_t * key_len, void * valbuf, size_t valbuf_sz, size_t * val_len, bool * eof) Iteratively access the elements pointed to by the cursor. hse_err_t hse_kvs_cursor_seek (struct hse_kvs_cursor * cursor, unsigned int flags, const void * key, size_t key_len, const void ** found, size_t * found_len) Move the cursor to point at the key-value pair at or closest to key . hse_err_t hse_kvs_cursor_seek_range (struct hse_kvs_cursor * cursor, unsigned int flags, const void * filt_min, size_t filt_min_len, const void * filt_max, size_t filt_max_len, const void ** found, size_t * found_len) Move the cursor to the closest match to key, gated by the given filter. hse_err_t hse_kvs_cursor_update_view (struct hse_kvs_cursor * cursor, unsigned int flags) Update a the cursor view. Detailed Description See the concepts and best practices sections on https://hse-project.github.io . Functions Documentation function hse_kvs_cursor_create hse_err_t hse_kvs_cursor_create ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * filter , size_t filter_len , struct hse_kvs_cursor ** cursor ) Creates a cursor used to iterate over key-value pairs in a KVS. Parameters : kvs KVS to iterate over, handle from hse_kvdb_kvs_open() . flags Flags for operation specialization. txn Transaction context (optional). filter Iteration limited to keys matching this prefix filter (optional). filter_len Length of filter (optional). cursor Cursor handle. Return : Error status Note : This function is thread safe. Remark : kvs must not be NULL. cursor must not be NULL. Non-transactional cursors: If txn is NULL, a non-transactional cursor is created. Non-transactional cursors have an ephemeral snapshot view of the KVS at the time it the cursor is created. The snapshot view is maintained for the life of the cursor. Writes to the KVS (put, deletes, etc.) made after the cursor is created will not be visible to the cursor unless hse_kvs_cursor_update_view() is used to obtain a more recent snapshot view. Non-transactional cursors can be used on transactional and non-transactional KVSs. Transactional cursors: If txn is not NULL, it must be a valid transaction handle or undefined behavior will result. If it is a valid handle to a transaction in the ACTIVE state, a transactional cursor is created. A transaction cursor's view includes the transaction's writes overlaid on the transaction's ephemeral snapshot view of the KVS. If the transaction is committed or aborted before the cursor is destroyed, the cursor's view reverts to same snaphsot view the transaction had when first became active. The cursor will no longer be able to see the transaction's writes. Calling hse_kvs_cursor_update_view() on a transactional cursor is a no-op and has no effect on the cursor's view. Transactional cursors can only be used on transactional KVSs. Prefix vs non-prefix cursors: Parameters filter and filter_len can be used to iterate over the subset of keys in the KVS whose first filter_len bytes match the filter_len bytes pointed to by filter . A prefix cursor is created when: KVS was created with pfx_len > 0 (i.e., it is a prefix KVS), and filter != NULL and filter_len >= pfx_len . Otherwise, a non-prefix cursor is created. Applications should arrange their key-value data to avoid the need for non-prefix cursors as they are significantly slower and more resource-intensive than prefix cursors. Note that simply using a filter doesn't create a prefix cursor \u2013 it must meet the two conditions listed above. Flags: HSE_CURSOR_CREATE_REV - Iterate in reverse lexicographical order. function hse_kvs_cursor_destroy hse_err_t hse_kvs_cursor_destroy ( struct hse_kvs_cursor * cursor ) Destroy cursor. Parameters : cursor Cursor handle from hse_kvs_cursor_create() . Return : Error status. Note : Cursor objects are not thread safe. Warning : After invoking this function, calling any other cursor functions with this handle will result in undefined behavior. Remark : cursor must not be NULL. function hse_kvs_cursor_read hse_err_t hse_kvs_cursor_read ( struct hse_kvs_cursor * cursor , unsigned int flags , const void ** key , size_t * key_len , const void ** val , size_t * val_len , bool * eof ) Iteratively access the elements pointed to by the cursor. Parameters : cursor Cursor handle from hse_kvs_cursor_create() . flags Flags for operation specialization. key Next key in sequence. key_len Length of key . val Next value in sequence. val_len Length of val . eof If true, no more key-value pairs in sequence. Return : Error status Note : If the cursor is at EOF, attempts to read from it will not change the state of the cursor. Cursor objects are not thread safe. Remark : cursor must not be NULL. key must not be NULL. key_len must not be NULL. val must not be NULL. val_len must not be NULL. eof must not be NULL. Read a key-value pair from the cursor, advancing the cursor past its current location. If the argument val is NULL, only the key is read. Flags: 0 - Reserved for future use. function hse_kvs_cursor_read_copy hse_err_t hse_kvs_cursor_read_copy ( struct hse_kvs_cursor * cursor , unsigned int flags , void * keybuf , size_t keybuf_sz , size_t * key_len , void * valbuf , size_t valbuf_sz , size_t * val_len , bool * eof ) Iteratively access the elements pointed to by the cursor. Parameters : cursor Cursor handle from hse_kvs_cursor_create() . flags Flags for operation specialization. keybuf Buffer into which the next key will be copied. keybuf_sz Size of keybuf . key_len Length of the key. valbuf Buffer into which the next key's value will be copied. valbuf_sz Size of valbuf val_len Length of val . eof If true, no more key-value pairs in sequence. Return : Error status Note : If the cursor is at EOF, attempts to read from it will not change the state of the cursor. Cursor objects are not thread safe. Remark : cursor must not be NULL. key must not be NULL. key_len must not be NULL. val must not be NULL. val_len must not be NULL. eof must not be NULL. Read a key-value pair from the cursor, advancing the cursor past its current location. The key-value pair will be copied into the user's buffer(s). If the argument valbuf is NULL, only the key is read. Flags: 0 - Reserved for future use. function hse_kvs_cursor_seek hse_err_t hse_kvs_cursor_seek ( struct hse_kvs_cursor * cursor , unsigned int flags , const void * key , size_t key_len , const void ** found , size_t * found_len ) Move the cursor to point at the key-value pair at or closest to key . Parameters : cursor Cursor handle from hse_kvs_cursor_create() . flags Flags for operation specialization. key Key to find. key_len Length of key . found If non-NULL, referent point to next key in sequence (optional). found_len If found is non-NULL, referent is length of found key. Return : Error status. Note : Cursor objects are not thread safe. Remark : cursor must not be NULL. The next hse_kvs_cursor_read() will start at this point. Both found and found_len must be non-NULL for that functionality to work. Flags: 0 - Reserved for future use. function hse_kvs_cursor_seek_range hse_err_t hse_kvs_cursor_seek_range ( struct hse_kvs_cursor * cursor , unsigned int flags , const void * filt_min , size_t filt_min_len , const void * filt_max , size_t filt_max_len , const void ** found , size_t * found_len ) Move the cursor to the closest match to key, gated by the given filter. Parameters : cursor Cursor handle from hse_kvs_cursor_create() . flags Flags for operation specialization. filt_min Filter minimum. filt_min_len Length of filt_min . filt_max Filter maximum. filt_max_len Length of filt_max . found If non-NULL, referent points to next key in sequence (optional). found_len If non-NULL, referent is length of found key (optional). Return : Error status. Note : This is only supported for forward cursors. Cursor objects are not thread safe. Remark : cursor must not be NULL. Keys read from this cursor will belong to the closed interval defined by the given filter: [ filt_min , filt_max ]. For KVSs storing segmented keys, performance will be enhanced when filt_min_len and filt_max_len are greater than or equal to the KVS key prefix length. Both found and found_len must be non-NULL for that functionality to work. Flags: 0 - Reserved for future use. function hse_kvs_cursor_update_view hse_err_t hse_kvs_cursor_update_view ( struct hse_kvs_cursor * cursor , unsigned int flags ) Update a the cursor view. Parameters : cursor Cursor handle from hse_kvs_cursor_create() . flags Flags for operation specialization. Return : Error status. Note : Cursor objects are not thread safe. Remark : cursor must not be NULL. This operation updates the snapshot view of a non-transaction cursor. It is a no-op on transaction cursors. Flags: 0 - Reserved for future use. Updated on 16 December 2021 at 14:04:27 CST","title":"Cursors"},{"location":"api/Modules/group__CURSORS/#cursors","text":"More...","title":"Cursors"},{"location":"api/Modules/group__CURSORS/#data-structures","text":"Name struct hse_kvs_cursor Opaque structure, a pointer to which is a handle to a cursor within a KVS.","title":"Data Structures"},{"location":"api/Modules/group__CURSORS/#functions","text":"Name hse_err_t hse_kvs_cursor_create (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * filter, size_t filter_len, struct hse_kvs_cursor ** cursor) Creates a cursor used to iterate over key-value pairs in a KVS. hse_err_t hse_kvs_cursor_destroy (struct hse_kvs_cursor * cursor) Destroy cursor. hse_err_t hse_kvs_cursor_read (struct hse_kvs_cursor * cursor, unsigned int flags, const void key, size_t * key_len, const void val, size_t * val_len, bool * eof) Iteratively access the elements pointed to by the cursor. hse_err_t hse_kvs_cursor_read_copy (struct hse_kvs_cursor * cursor, unsigned int flags, void * keybuf, size_t keybuf_sz, size_t * key_len, void * valbuf, size_t valbuf_sz, size_t * val_len, bool * eof) Iteratively access the elements pointed to by the cursor. hse_err_t hse_kvs_cursor_seek (struct hse_kvs_cursor * cursor, unsigned int flags, const void * key, size_t key_len, const void ** found, size_t * found_len) Move the cursor to point at the key-value pair at or closest to key . hse_err_t hse_kvs_cursor_seek_range (struct hse_kvs_cursor * cursor, unsigned int flags, const void * filt_min, size_t filt_min_len, const void * filt_max, size_t filt_max_len, const void ** found, size_t * found_len) Move the cursor to the closest match to key, gated by the given filter. hse_err_t hse_kvs_cursor_update_view (struct hse_kvs_cursor * cursor, unsigned int flags) Update a the cursor view.","title":"Functions"},{"location":"api/Modules/group__CURSORS/#detailed-description","text":"See the concepts and best practices sections on https://hse-project.github.io .","title":"Detailed Description"},{"location":"api/Modules/group__CURSORS/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/Modules/group__CURSORS/#function-hse_kvs_cursor_create","text":"hse_err_t hse_kvs_cursor_create ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * filter , size_t filter_len , struct hse_kvs_cursor ** cursor ) Creates a cursor used to iterate over key-value pairs in a KVS. Parameters : kvs KVS to iterate over, handle from hse_kvdb_kvs_open() . flags Flags for operation specialization. txn Transaction context (optional). filter Iteration limited to keys matching this prefix filter (optional). filter_len Length of filter (optional). cursor Cursor handle. Return : Error status Note : This function is thread safe. Remark : kvs must not be NULL. cursor must not be NULL. Non-transactional cursors: If txn is NULL, a non-transactional cursor is created. Non-transactional cursors have an ephemeral snapshot view of the KVS at the time it the cursor is created. The snapshot view is maintained for the life of the cursor. Writes to the KVS (put, deletes, etc.) made after the cursor is created will not be visible to the cursor unless hse_kvs_cursor_update_view() is used to obtain a more recent snapshot view. Non-transactional cursors can be used on transactional and non-transactional KVSs. Transactional cursors: If txn is not NULL, it must be a valid transaction handle or undefined behavior will result. If it is a valid handle to a transaction in the ACTIVE state, a transactional cursor is created. A transaction cursor's view includes the transaction's writes overlaid on the transaction's ephemeral snapshot view of the KVS. If the transaction is committed or aborted before the cursor is destroyed, the cursor's view reverts to same snaphsot view the transaction had when first became active. The cursor will no longer be able to see the transaction's writes. Calling hse_kvs_cursor_update_view() on a transactional cursor is a no-op and has no effect on the cursor's view. Transactional cursors can only be used on transactional KVSs. Prefix vs non-prefix cursors: Parameters filter and filter_len can be used to iterate over the subset of keys in the KVS whose first filter_len bytes match the filter_len bytes pointed to by filter . A prefix cursor is created when: KVS was created with pfx_len > 0 (i.e., it is a prefix KVS), and filter != NULL and filter_len >= pfx_len . Otherwise, a non-prefix cursor is created. Applications should arrange their key-value data to avoid the need for non-prefix cursors as they are significantly slower and more resource-intensive than prefix cursors. Note that simply using a filter doesn't create a prefix cursor \u2013 it must meet the two conditions listed above. Flags: HSE_CURSOR_CREATE_REV - Iterate in reverse lexicographical order.","title":"function hse_kvs_cursor_create"},{"location":"api/Modules/group__CURSORS/#function-hse_kvs_cursor_destroy","text":"hse_err_t hse_kvs_cursor_destroy ( struct hse_kvs_cursor * cursor ) Destroy cursor. Parameters : cursor Cursor handle from hse_kvs_cursor_create() . Return : Error status. Note : Cursor objects are not thread safe. Warning : After invoking this function, calling any other cursor functions with this handle will result in undefined behavior. Remark : cursor must not be NULL.","title":"function hse_kvs_cursor_destroy"},{"location":"api/Modules/group__CURSORS/#function-hse_kvs_cursor_read","text":"hse_err_t hse_kvs_cursor_read ( struct hse_kvs_cursor * cursor , unsigned int flags , const void ** key , size_t * key_len , const void ** val , size_t * val_len , bool * eof ) Iteratively access the elements pointed to by the cursor. Parameters : cursor Cursor handle from hse_kvs_cursor_create() . flags Flags for operation specialization. key Next key in sequence. key_len Length of key . val Next value in sequence. val_len Length of val . eof If true, no more key-value pairs in sequence. Return : Error status Note : If the cursor is at EOF, attempts to read from it will not change the state of the cursor. Cursor objects are not thread safe. Remark : cursor must not be NULL. key must not be NULL. key_len must not be NULL. val must not be NULL. val_len must not be NULL. eof must not be NULL. Read a key-value pair from the cursor, advancing the cursor past its current location. If the argument val is NULL, only the key is read. Flags: 0 - Reserved for future use.","title":"function hse_kvs_cursor_read"},{"location":"api/Modules/group__CURSORS/#function-hse_kvs_cursor_read_copy","text":"hse_err_t hse_kvs_cursor_read_copy ( struct hse_kvs_cursor * cursor , unsigned int flags , void * keybuf , size_t keybuf_sz , size_t * key_len , void * valbuf , size_t valbuf_sz , size_t * val_len , bool * eof ) Iteratively access the elements pointed to by the cursor. Parameters : cursor Cursor handle from hse_kvs_cursor_create() . flags Flags for operation specialization. keybuf Buffer into which the next key will be copied. keybuf_sz Size of keybuf . key_len Length of the key. valbuf Buffer into which the next key's value will be copied. valbuf_sz Size of valbuf val_len Length of val . eof If true, no more key-value pairs in sequence. Return : Error status Note : If the cursor is at EOF, attempts to read from it will not change the state of the cursor. Cursor objects are not thread safe. Remark : cursor must not be NULL. key must not be NULL. key_len must not be NULL. val must not be NULL. val_len must not be NULL. eof must not be NULL. Read a key-value pair from the cursor, advancing the cursor past its current location. The key-value pair will be copied into the user's buffer(s). If the argument valbuf is NULL, only the key is read. Flags: 0 - Reserved for future use.","title":"function hse_kvs_cursor_read_copy"},{"location":"api/Modules/group__CURSORS/#function-hse_kvs_cursor_seek","text":"hse_err_t hse_kvs_cursor_seek ( struct hse_kvs_cursor * cursor , unsigned int flags , const void * key , size_t key_len , const void ** found , size_t * found_len ) Move the cursor to point at the key-value pair at or closest to key . Parameters : cursor Cursor handle from hse_kvs_cursor_create() . flags Flags for operation specialization. key Key to find. key_len Length of key . found If non-NULL, referent point to next key in sequence (optional). found_len If found is non-NULL, referent is length of found key. Return : Error status. Note : Cursor objects are not thread safe. Remark : cursor must not be NULL. The next hse_kvs_cursor_read() will start at this point. Both found and found_len must be non-NULL for that functionality to work. Flags: 0 - Reserved for future use.","title":"function hse_kvs_cursor_seek"},{"location":"api/Modules/group__CURSORS/#function-hse_kvs_cursor_seek_range","text":"hse_err_t hse_kvs_cursor_seek_range ( struct hse_kvs_cursor * cursor , unsigned int flags , const void * filt_min , size_t filt_min_len , const void * filt_max , size_t filt_max_len , const void ** found , size_t * found_len ) Move the cursor to the closest match to key, gated by the given filter. Parameters : cursor Cursor handle from hse_kvs_cursor_create() . flags Flags for operation specialization. filt_min Filter minimum. filt_min_len Length of filt_min . filt_max Filter maximum. filt_max_len Length of filt_max . found If non-NULL, referent points to next key in sequence (optional). found_len If non-NULL, referent is length of found key (optional). Return : Error status. Note : This is only supported for forward cursors. Cursor objects are not thread safe. Remark : cursor must not be NULL. Keys read from this cursor will belong to the closed interval defined by the given filter: [ filt_min , filt_max ]. For KVSs storing segmented keys, performance will be enhanced when filt_min_len and filt_max_len are greater than or equal to the KVS key prefix length. Both found and found_len must be non-NULL for that functionality to work. Flags: 0 - Reserved for future use.","title":"function hse_kvs_cursor_seek_range"},{"location":"api/Modules/group__CURSORS/#function-hse_kvs_cursor_update_view","text":"hse_err_t hse_kvs_cursor_update_view ( struct hse_kvs_cursor * cursor , unsigned int flags ) Update a the cursor view. Parameters : cursor Cursor handle from hse_kvs_cursor_create() . flags Flags for operation specialization. Return : Error status. Note : Cursor objects are not thread safe. Remark : cursor must not be NULL. This operation updates the snapshot view of a non-transaction cursor. It is a no-op on transaction cursors. Flags: 0 - Reserved for future use. Updated on 16 December 2021 at 14:04:27 CST","title":"function hse_kvs_cursor_update_view"},{"location":"api/Modules/group__ERRORS/","text":"Errors More... Types Name enum hse_err_ctx { HSE_ERR_CTX_NONE} Error context values. typedef uint64_t hse_err_t Generic return type for the HSE library. Functions Name int hse_err_to_errno ( hse_err_t err) Return an hse_err_t value's errno representation. size_t hse_strerror ( hse_err_t err, char * buf, size_t buf_len) Return an hse_err_t value's string representation. enum hse_err_ctx hse_err_to_ctx ( hse_err_t err) Return an hse_err_t value's error context. Defines Name HSE_ERR_CTX_BASE Smallest error context value. HSE_ERR_CTX_MAX Largest error context value. Detailed Description Describes the HSE API return code type and associated utilities. Types Documentation enum hse_err_ctx Enumerator Value Description HSE_ERR_CTX_NONE No context Error context values. typedef hse_err_t hse_err_t ; Generic return type for the HSE library. If this scalar quantity is 0 then the call succeeded. If it is non-zero, then the 64-bit quantity can be used by the client in two ways: (1) call hse_err_to_errno() to get a mapping to a POSIX errno value, and (2) call hse_strerror() to get a textual reference about what error occurred and where. The following special errno error codes are worth mentioning here. errno Caller action EAGAIN The caller is expected to retry the operation. ECANCELED The caller is expected to retry the operation in a new transaction. See [write conflicts]. e.g., the code snippet below shows a typical non-transactional usage: int retries = 0 ; hse_err_t ret = 0 ; while ( retries < MAX_RETRIES ) { ret = hse_kvs_put ( kvs_handle , flags , txn , key , k_len , val , v_len ) if ( EAGAIN != hse_err_to_errno ( ret )) break ; retries ++ ; } Filename: .c Functions Documentation function hse_err_to_errno int hse_err_to_errno ( hse_err_t err ) Return an hse_err_t value's errno representation. Parameters : err Error value returned from an HSE API function. Return : Error's errno equivalent. Note : This function is thread safe. The hse_err_t scalar value err is translated into its errno equivalent. function hse_strerror size_t hse_strerror ( hse_err_t err , char * buf , size_t buf_len ) Return an hse_err_t value's string representation. Parameters : err Error value returned from an HSE API function. buf Buffer to hold the formatted string. buf_len Length of buffer. Return : The number of characters (excluding the terminating NULL byte) which would have been written to the final string if enough space had been available. Note : This function is thread safe. The hse_err_t scalar value err is decoded into a NULL-terminated string representation giving more information about the error and where it occurred. The string will be truncated if buf_len is too small (a buf_len value of 128 is sufficient to avoid truncation of most error strings). function hse_err_to_ctx enum hse_err_ctx hse_err_to_ctx ( hse_err_t err ) Return an hse_err_t value's error context. Parameters : err Error value returned from an HSE API function. Return : The error's context. Note : This function is thread safe. The error context value is retrieved from the hse_err_t value. Macros Documentation define HSE_ERR_CTX_BASE #define HSE_ERR_CTX_BASE [HSE_ERR_CTX_NONE](/2.x/api/Modules/group__ERRORS/#enumvalue-hse_err_ctx_none) Smallest error context value. define HSE_ERR_CTX_MAX #define HSE_ERR_CTX_MAX [HSE_ERR_CTX_NONE](/2.x/api/Modules/group__ERRORS/#enumvalue-hse_err_ctx_none) Largest error context value. Updated on 16 December 2021 at 14:04:27 CST","title":"Errors"},{"location":"api/Modules/group__ERRORS/#errors","text":"More...","title":"Errors"},{"location":"api/Modules/group__ERRORS/#types","text":"Name enum hse_err_ctx { HSE_ERR_CTX_NONE} Error context values. typedef uint64_t hse_err_t Generic return type for the HSE library.","title":"Types"},{"location":"api/Modules/group__ERRORS/#functions","text":"Name int hse_err_to_errno ( hse_err_t err) Return an hse_err_t value's errno representation. size_t hse_strerror ( hse_err_t err, char * buf, size_t buf_len) Return an hse_err_t value's string representation. enum hse_err_ctx hse_err_to_ctx ( hse_err_t err) Return an hse_err_t value's error context.","title":"Functions"},{"location":"api/Modules/group__ERRORS/#defines","text":"Name HSE_ERR_CTX_BASE Smallest error context value. HSE_ERR_CTX_MAX Largest error context value.","title":"Defines"},{"location":"api/Modules/group__ERRORS/#detailed-description","text":"Describes the HSE API return code type and associated utilities.","title":"Detailed Description"},{"location":"api/Modules/group__ERRORS/#types-documentation","text":"","title":"Types Documentation"},{"location":"api/Modules/group__ERRORS/#enum-hse_err_ctx","text":"Enumerator Value Description HSE_ERR_CTX_NONE No context Error context values.","title":"enum hse_err_ctx"},{"location":"api/Modules/group__ERRORS/#typedef-hse_err_t","text":"hse_err_t ; Generic return type for the HSE library. If this scalar quantity is 0 then the call succeeded. If it is non-zero, then the 64-bit quantity can be used by the client in two ways: (1) call hse_err_to_errno() to get a mapping to a POSIX errno value, and (2) call hse_strerror() to get a textual reference about what error occurred and where. The following special errno error codes are worth mentioning here. errno Caller action EAGAIN The caller is expected to retry the operation. ECANCELED The caller is expected to retry the operation in a new transaction. See [write conflicts]. e.g., the code snippet below shows a typical non-transactional usage: int retries = 0 ; hse_err_t ret = 0 ; while ( retries < MAX_RETRIES ) { ret = hse_kvs_put ( kvs_handle , flags , txn , key , k_len , val , v_len ) if ( EAGAIN != hse_err_to_errno ( ret )) break ; retries ++ ; } Filename: .c","title":"typedef hse_err_t"},{"location":"api/Modules/group__ERRORS/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/Modules/group__ERRORS/#function-hse_err_to_errno","text":"int hse_err_to_errno ( hse_err_t err ) Return an hse_err_t value's errno representation. Parameters : err Error value returned from an HSE API function. Return : Error's errno equivalent. Note : This function is thread safe. The hse_err_t scalar value err is translated into its errno equivalent.","title":"function hse_err_to_errno"},{"location":"api/Modules/group__ERRORS/#function-hse_strerror","text":"size_t hse_strerror ( hse_err_t err , char * buf , size_t buf_len ) Return an hse_err_t value's string representation. Parameters : err Error value returned from an HSE API function. buf Buffer to hold the formatted string. buf_len Length of buffer. Return : The number of characters (excluding the terminating NULL byte) which would have been written to the final string if enough space had been available. Note : This function is thread safe. The hse_err_t scalar value err is decoded into a NULL-terminated string representation giving more information about the error and where it occurred. The string will be truncated if buf_len is too small (a buf_len value of 128 is sufficient to avoid truncation of most error strings).","title":"function hse_strerror"},{"location":"api/Modules/group__ERRORS/#function-hse_err_to_ctx","text":"enum hse_err_ctx hse_err_to_ctx ( hse_err_t err ) Return an hse_err_t value's error context. Parameters : err Error value returned from an HSE API function. Return : The error's context. Note : This function is thread safe. The error context value is retrieved from the hse_err_t value.","title":"function hse_err_to_ctx"},{"location":"api/Modules/group__ERRORS/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"api/Modules/group__ERRORS/#define-hse_err_ctx_base","text":"#define HSE_ERR_CTX_BASE [HSE_ERR_CTX_NONE](/2.x/api/Modules/group__ERRORS/#enumvalue-hse_err_ctx_none) Smallest error context value.","title":"define HSE_ERR_CTX_BASE"},{"location":"api/Modules/group__ERRORS/#define-hse_err_ctx_max","text":"#define HSE_ERR_CTX_MAX [HSE_ERR_CTX_NONE](/2.x/api/Modules/group__ERRORS/#enumvalue-hse_err_ctx_none) Largest error context value. Updated on 16 December 2021 at 14:04:27 CST","title":"define HSE_ERR_CTX_MAX"},{"location":"api/Modules/group__KVDB/","text":"Key-Value Database (KVDB) Data Structures Name struct hse_mclass_info Media class information. struct hse_kvdb Opaque structure, a pointer to which is a handle to an HSE key-value database (KVDB). Types Name enum hse_mclass { HSE_MCLASS_CAPACITY = 0, HSE_MCLASS_STAGING = 1, HSE_MCLASS_PMEM = 2} Media classes. Functions Name hse_err_t hse_kvdb_close (struct hse_kvdb * kvdb) Close a KVDB. hse_err_t hse_kvdb_create (const char * kvdb_home, size_t paramc, const char *const * paramv) Create a KVDB. hse_err_t hse_kvdb_drop (const char * kvdb_home) Drop a KVDB. const char * hse_kvdb_home_get (struct hse_kvdb * kvdb) Get the KVDB home. hse_err_t hse_kvdb_kvs_names_get (struct hse_kvdb * kvdb, size_t * namec, char *** namev) Get the names of the KVSs within the given KVDB. void hse_kvdb_kvs_names_free (struct hse_kvdb * kvdb, char ** namev) Free the names collection obtained through hse_kvdb_kvs_names_get() . hse_err_t hse_kvdb_mclass_info_get (struct hse_kvdb * kvdb, enum hse_mclass mclass, struct hse_mclass_info * info) Get media class information from a KVDB. bool hse_kvdb_mclass_is_configured (struct hse_kvdb * kvdb, enum hse_mclass mclass) Check if a media class is configured for a KVDB. hse_err_t hse_kvdb_open (const char * kvdb_home, size_t paramc, const char const * paramv, struct hse_kvdb * kvdb) Open a KVDB. hse_err_t hse_kvdb_param_get (struct hse_kvdb * kvdb, const char * param, char * buf, size_t buf_sz, size_t * needed_sz) Get KVDB parameter. hse_err_t hse_kvdb_storage_add (const char * kvdb_home, size_t paramc, const char *const * paramv) Add new media class storage to an existing offline KVDB. hse_err_t hse_kvdb_sync (struct hse_kvdb * kvdb, unsigned int flags) Sync data in all of the referenced KVDB's KVSs to stable media. const char * hse_mclass_name_get (enum hse_mclass mclass) Get the name of a media class. Defines Name HSE_MCLASS_BASE HSE_MCLASS_MAX HSE_MCLASS_COUNT HSE_MCLASS_CAPACITY_NAME HSE_MCLASS_STAGING_NAME HSE_MCLASS_PMEM_NAME Types Documentation enum hse_mclass Enumerator Value Description HSE_MCLASS_CAPACITY 0 HSE_MCLASS_STAGING 1 HSE_MCLASS_PMEM 2 Media classes. Functions Documentation function hse_kvdb_close hse_err_t hse_kvdb_close ( struct hse_kvdb * kvdb ) Close a KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() . Return : Error status. Note : This function is not thread safe. Warning : After invoking this function, calling any other KVDB functions will result in undefined behavior unless the KVDB is re-opened. Remark : kvdb must not be NULL. function hse_kvdb_create hse_err_t hse_kvdb_create ( const char * kvdb_home , size_t paramc , const char * const * paramv ) Create a KVDB. Parameters : kvdb_home KVDB home directory. paramc Number of configuration parameters in paramv . paramv List of parameters in key=value format. Return : Error status. Note : This function is not thread safe. Remark : kvdb_home must not be NULL. function hse_kvdb_drop hse_err_t hse_kvdb_drop ( const char * kvdb_home ) Drop a KVDB. Parameters : kvdb_home KVDB home directory. Return : Error status. Note : This function is not thread safe. Warning : It is an error to call this function on a KVDB that is open. Remark : kvdb_home must not be NULL. function hse_kvdb_home_get const char * hse_kvdb_home_get ( struct hse_kvdb * kvdb ) Get the KVDB home. Parameters : kvdb KVDB handle from hse_kvdb_open() . Returns : NULL if given an invalid KVDB handle. Return : KVDB home. Note : This function is thread safe. Remark : kvdb must not be NULL. function hse_kvdb_kvs_names_get hse_err_t hse_kvdb_kvs_names_get ( struct hse_kvdb * kvdb , size_t * namec , char *** namev ) Get the names of the KVSs within the given KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() . namec Number of KVSs in the KVDB. namev Vector of KVSs allocated by the function. Return : Error status. Note : This function is thread safe. Remark : kvdb must not be NULL. namev must not be NULL. Key-value stores (KVSs) are opened by name. This function allocates a vector of allocated strings, each containing the NULL-terminated name of a KVS. The memory must be freed via hse_kvdb_kvs_names_free() . Example Usage: int namec ; char ** namev ; hse_err_t err ; err = hse_kvdb_kvs_names_get ( kvdb , & namec , & namev ); if ( ! err ) { for ( int i = 0 ; i < namec ; i ++ ) printf ( \"%s \\n \" , namev [ i ]); } hse_kvdb_kvs_names_free ( namev ); Filename: .c function hse_kvdb_kvs_names_free void hse_kvdb_kvs_names_free ( struct hse_kvdb * kvdb , char ** namev ) Free the names collection obtained through hse_kvdb_kvs_names_get() . Parameters : kvdb KVDB handle from hse_kvdb_open() . namev Vector of KVS names that hse_kvdb_kvs_names_get() output. Note : This function is thread safe. function hse_kvdb_mclass_info_get hse_err_t hse_kvdb_mclass_info_get ( struct hse_kvdb * kvdb , enum hse_mclass mclass , struct hse_mclass_info * info ) Get media class information from a KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() . mclass Media class to query for. info Media class information object. Return : Error status. Note : This function is thread safe. Remark : kvdb must not be NULL. info must not be NULL. function hse_kvdb_mclass_is_configured bool hse_kvdb_mclass_is_configured ( struct hse_kvdb * kvdb , enum hse_mclass mclass ) Check if a media class is configured for a KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() . mclass Media class to query for. Returns : false if kvdb or mclass is invalid. Return : Whether or not mclass is configured. Note : This function is thread safe. Remark : kvdb must not be NULL. function hse_kvdb_open hse_err_t hse_kvdb_open ( const char * kvdb_home , size_t paramc , const char * const * paramv , struct hse_kvdb ** kvdb ) Open a KVDB. Parameters : kvdb_home KVDB home directory. paramc Number of configuration parameters in paramv . paramv List of parameters in key=value format. kvdb Handle to access the opened KVDB. Return : Error status. Note : This function is not thread safe. Remark : The KVDB must have already been created. kvdb_home must not be NULL. kvdb must not be NULL. function hse_kvdb_param_get hse_err_t hse_kvdb_param_get ( struct hse_kvdb * kvdb , const char * param , char * buf , size_t buf_sz , size_t * needed_sz ) Get KVDB parameter. Parameters : kvdb KVDB handle from hse_kvdb_open() . param Parameter name. buf Buffer for writing stringified value of parameter. buf_sz Size of buf . needed_sz Needed size of buf . Return : Error status. Note : This function is thread safe. Remark : kvdb must not be NULL. param must not be NULL. param must be a valid parameter. Puts the stringified version of the parameter value into buf . If buf_sz is NULL, then needed_sz will still be populated. function hse_kvdb_storage_add hse_err_t hse_kvdb_storage_add ( const char * kvdb_home , size_t paramc , const char * const * paramv ) Add new media class storage to an existing offline KVDB. Parameters : kvdb_home KVDB home directory. paramc Number of configuration parameters in paramv . paramv List of KVDB create-time parameters in key=value format. Return : Error status. Note : This function is not thread safe. Remark : kvdb_home must not be NULL. KVBD must have already been created. paramv must not be NULL. function hse_kvdb_sync hse_err_t hse_kvdb_sync ( struct hse_kvdb * kvdb , unsigned int flags ) Sync data in all of the referenced KVDB's KVSs to stable media. Parameters : kvdb KVDB handle from hse_kvdb_open() . flags Flags for operation specialization. Return : Error status. Note : This function is thread safe. Remark : kvdb must not be NULL. Flags: HSE_KVDB_SYNC_ASYNC - Return immediately after initiating operation instead of waiting for completion. function hse_mclass_name_get const char * hse_mclass_name_get ( enum hse_mclass mclass ) Get the name of a media class. Parameters : mclass Media class. Return : Name of media class. Note : This function is thread safe. Macros Documentation define HSE_MCLASS_BASE #define HSE_MCLASS_BASE HSE_MCLASS_CAPACITY Capacity media class. define HSE_MCLASS_MAX #define HSE_MCLASS_MAX HSE_MCLASS_PMEM Staging media class. define HSE_MCLASS_COUNT #define HSE_MCLASS_COUNT ([HSE_MCLASS_MAX](/2.x/api/Modules/group__KVDB/#define-hse_mclass_max) + 1) PMEM media class. define HSE_MCLASS_CAPACITY_NAME #define HSE_MCLASS_CAPACITY_NAME \"capacity\" Capacity media class name. define HSE_MCLASS_STAGING_NAME #define HSE_MCLASS_STAGING_NAME \"staging\" Staging media class name. define HSE_MCLASS_PMEM_NAME #define HSE_MCLASS_PMEM_NAME \"pmem\" PMEM media class name. Updated on 16 December 2021 at 14:04:27 CST","title":"Key-Value Database (KVDB)"},{"location":"api/Modules/group__KVDB/#key-value-database-kvdb","text":"","title":"Key-Value Database (KVDB)"},{"location":"api/Modules/group__KVDB/#data-structures","text":"Name struct hse_mclass_info Media class information. struct hse_kvdb Opaque structure, a pointer to which is a handle to an HSE key-value database (KVDB).","title":"Data Structures"},{"location":"api/Modules/group__KVDB/#types","text":"Name enum hse_mclass { HSE_MCLASS_CAPACITY = 0, HSE_MCLASS_STAGING = 1, HSE_MCLASS_PMEM = 2} Media classes.","title":"Types"},{"location":"api/Modules/group__KVDB/#functions","text":"Name hse_err_t hse_kvdb_close (struct hse_kvdb * kvdb) Close a KVDB. hse_err_t hse_kvdb_create (const char * kvdb_home, size_t paramc, const char *const * paramv) Create a KVDB. hse_err_t hse_kvdb_drop (const char * kvdb_home) Drop a KVDB. const char * hse_kvdb_home_get (struct hse_kvdb * kvdb) Get the KVDB home. hse_err_t hse_kvdb_kvs_names_get (struct hse_kvdb * kvdb, size_t * namec, char *** namev) Get the names of the KVSs within the given KVDB. void hse_kvdb_kvs_names_free (struct hse_kvdb * kvdb, char ** namev) Free the names collection obtained through hse_kvdb_kvs_names_get() . hse_err_t hse_kvdb_mclass_info_get (struct hse_kvdb * kvdb, enum hse_mclass mclass, struct hse_mclass_info * info) Get media class information from a KVDB. bool hse_kvdb_mclass_is_configured (struct hse_kvdb * kvdb, enum hse_mclass mclass) Check if a media class is configured for a KVDB. hse_err_t hse_kvdb_open (const char * kvdb_home, size_t paramc, const char const * paramv, struct hse_kvdb * kvdb) Open a KVDB. hse_err_t hse_kvdb_param_get (struct hse_kvdb * kvdb, const char * param, char * buf, size_t buf_sz, size_t * needed_sz) Get KVDB parameter. hse_err_t hse_kvdb_storage_add (const char * kvdb_home, size_t paramc, const char *const * paramv) Add new media class storage to an existing offline KVDB. hse_err_t hse_kvdb_sync (struct hse_kvdb * kvdb, unsigned int flags) Sync data in all of the referenced KVDB's KVSs to stable media. const char * hse_mclass_name_get (enum hse_mclass mclass) Get the name of a media class.","title":"Functions"},{"location":"api/Modules/group__KVDB/#defines","text":"Name HSE_MCLASS_BASE HSE_MCLASS_MAX HSE_MCLASS_COUNT HSE_MCLASS_CAPACITY_NAME HSE_MCLASS_STAGING_NAME HSE_MCLASS_PMEM_NAME","title":"Defines"},{"location":"api/Modules/group__KVDB/#types-documentation","text":"","title":"Types Documentation"},{"location":"api/Modules/group__KVDB/#enum-hse_mclass","text":"Enumerator Value Description HSE_MCLASS_CAPACITY 0 HSE_MCLASS_STAGING 1 HSE_MCLASS_PMEM 2 Media classes.","title":"enum hse_mclass"},{"location":"api/Modules/group__KVDB/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/Modules/group__KVDB/#function-hse_kvdb_close","text":"hse_err_t hse_kvdb_close ( struct hse_kvdb * kvdb ) Close a KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() . Return : Error status. Note : This function is not thread safe. Warning : After invoking this function, calling any other KVDB functions will result in undefined behavior unless the KVDB is re-opened. Remark : kvdb must not be NULL.","title":"function hse_kvdb_close"},{"location":"api/Modules/group__KVDB/#function-hse_kvdb_create","text":"hse_err_t hse_kvdb_create ( const char * kvdb_home , size_t paramc , const char * const * paramv ) Create a KVDB. Parameters : kvdb_home KVDB home directory. paramc Number of configuration parameters in paramv . paramv List of parameters in key=value format. Return : Error status. Note : This function is not thread safe. Remark : kvdb_home must not be NULL.","title":"function hse_kvdb_create"},{"location":"api/Modules/group__KVDB/#function-hse_kvdb_drop","text":"hse_err_t hse_kvdb_drop ( const char * kvdb_home ) Drop a KVDB. Parameters : kvdb_home KVDB home directory. Return : Error status. Note : This function is not thread safe. Warning : It is an error to call this function on a KVDB that is open. Remark : kvdb_home must not be NULL.","title":"function hse_kvdb_drop"},{"location":"api/Modules/group__KVDB/#function-hse_kvdb_home_get","text":"const char * hse_kvdb_home_get ( struct hse_kvdb * kvdb ) Get the KVDB home. Parameters : kvdb KVDB handle from hse_kvdb_open() . Returns : NULL if given an invalid KVDB handle. Return : KVDB home. Note : This function is thread safe. Remark : kvdb must not be NULL.","title":"function hse_kvdb_home_get"},{"location":"api/Modules/group__KVDB/#function-hse_kvdb_kvs_names_get","text":"hse_err_t hse_kvdb_kvs_names_get ( struct hse_kvdb * kvdb , size_t * namec , char *** namev ) Get the names of the KVSs within the given KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() . namec Number of KVSs in the KVDB. namev Vector of KVSs allocated by the function. Return : Error status. Note : This function is thread safe. Remark : kvdb must not be NULL. namev must not be NULL. Key-value stores (KVSs) are opened by name. This function allocates a vector of allocated strings, each containing the NULL-terminated name of a KVS. The memory must be freed via hse_kvdb_kvs_names_free() . Example Usage: int namec ; char ** namev ; hse_err_t err ; err = hse_kvdb_kvs_names_get ( kvdb , & namec , & namev ); if ( ! err ) { for ( int i = 0 ; i < namec ; i ++ ) printf ( \"%s \\n \" , namev [ i ]); } hse_kvdb_kvs_names_free ( namev ); Filename: .c","title":"function hse_kvdb_kvs_names_get"},{"location":"api/Modules/group__KVDB/#function-hse_kvdb_kvs_names_free","text":"void hse_kvdb_kvs_names_free ( struct hse_kvdb * kvdb , char ** namev ) Free the names collection obtained through hse_kvdb_kvs_names_get() . Parameters : kvdb KVDB handle from hse_kvdb_open() . namev Vector of KVS names that hse_kvdb_kvs_names_get() output. Note : This function is thread safe.","title":"function hse_kvdb_kvs_names_free"},{"location":"api/Modules/group__KVDB/#function-hse_kvdb_mclass_info_get","text":"hse_err_t hse_kvdb_mclass_info_get ( struct hse_kvdb * kvdb , enum hse_mclass mclass , struct hse_mclass_info * info ) Get media class information from a KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() . mclass Media class to query for. info Media class information object. Return : Error status. Note : This function is thread safe. Remark : kvdb must not be NULL. info must not be NULL.","title":"function hse_kvdb_mclass_info_get"},{"location":"api/Modules/group__KVDB/#function-hse_kvdb_mclass_is_configured","text":"bool hse_kvdb_mclass_is_configured ( struct hse_kvdb * kvdb , enum hse_mclass mclass ) Check if a media class is configured for a KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() . mclass Media class to query for. Returns : false if kvdb or mclass is invalid. Return : Whether or not mclass is configured. Note : This function is thread safe. Remark : kvdb must not be NULL.","title":"function hse_kvdb_mclass_is_configured"},{"location":"api/Modules/group__KVDB/#function-hse_kvdb_open","text":"hse_err_t hse_kvdb_open ( const char * kvdb_home , size_t paramc , const char * const * paramv , struct hse_kvdb ** kvdb ) Open a KVDB. Parameters : kvdb_home KVDB home directory. paramc Number of configuration parameters in paramv . paramv List of parameters in key=value format. kvdb Handle to access the opened KVDB. Return : Error status. Note : This function is not thread safe. Remark : The KVDB must have already been created. kvdb_home must not be NULL. kvdb must not be NULL.","title":"function hse_kvdb_open"},{"location":"api/Modules/group__KVDB/#function-hse_kvdb_param_get","text":"hse_err_t hse_kvdb_param_get ( struct hse_kvdb * kvdb , const char * param , char * buf , size_t buf_sz , size_t * needed_sz ) Get KVDB parameter. Parameters : kvdb KVDB handle from hse_kvdb_open() . param Parameter name. buf Buffer for writing stringified value of parameter. buf_sz Size of buf . needed_sz Needed size of buf . Return : Error status. Note : This function is thread safe. Remark : kvdb must not be NULL. param must not be NULL. param must be a valid parameter. Puts the stringified version of the parameter value into buf . If buf_sz is NULL, then needed_sz will still be populated.","title":"function hse_kvdb_param_get"},{"location":"api/Modules/group__KVDB/#function-hse_kvdb_storage_add","text":"hse_err_t hse_kvdb_storage_add ( const char * kvdb_home , size_t paramc , const char * const * paramv ) Add new media class storage to an existing offline KVDB. Parameters : kvdb_home KVDB home directory. paramc Number of configuration parameters in paramv . paramv List of KVDB create-time parameters in key=value format. Return : Error status. Note : This function is not thread safe. Remark : kvdb_home must not be NULL. KVBD must have already been created. paramv must not be NULL.","title":"function hse_kvdb_storage_add"},{"location":"api/Modules/group__KVDB/#function-hse_kvdb_sync","text":"hse_err_t hse_kvdb_sync ( struct hse_kvdb * kvdb , unsigned int flags ) Sync data in all of the referenced KVDB's KVSs to stable media. Parameters : kvdb KVDB handle from hse_kvdb_open() . flags Flags for operation specialization. Return : Error status. Note : This function is thread safe. Remark : kvdb must not be NULL. Flags: HSE_KVDB_SYNC_ASYNC - Return immediately after initiating operation instead of waiting for completion.","title":"function hse_kvdb_sync"},{"location":"api/Modules/group__KVDB/#function-hse_mclass_name_get","text":"const char * hse_mclass_name_get ( enum hse_mclass mclass ) Get the name of a media class. Parameters : mclass Media class. Return : Name of media class. Note : This function is thread safe.","title":"function hse_mclass_name_get"},{"location":"api/Modules/group__KVDB/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"api/Modules/group__KVDB/#define-hse_mclass_base","text":"#define HSE_MCLASS_BASE HSE_MCLASS_CAPACITY Capacity media class.","title":"define HSE_MCLASS_BASE"},{"location":"api/Modules/group__KVDB/#define-hse_mclass_max","text":"#define HSE_MCLASS_MAX HSE_MCLASS_PMEM Staging media class.","title":"define HSE_MCLASS_MAX"},{"location":"api/Modules/group__KVDB/#define-hse_mclass_count","text":"#define HSE_MCLASS_COUNT ([HSE_MCLASS_MAX](/2.x/api/Modules/group__KVDB/#define-hse_mclass_max) + 1) PMEM media class.","title":"define HSE_MCLASS_COUNT"},{"location":"api/Modules/group__KVDB/#define-hse_mclass_capacity_name","text":"#define HSE_MCLASS_CAPACITY_NAME \"capacity\" Capacity media class name.","title":"define HSE_MCLASS_CAPACITY_NAME"},{"location":"api/Modules/group__KVDB/#define-hse_mclass_staging_name","text":"#define HSE_MCLASS_STAGING_NAME \"staging\" Staging media class name.","title":"define HSE_MCLASS_STAGING_NAME"},{"location":"api/Modules/group__KVDB/#define-hse_mclass_pmem_name","text":"#define HSE_MCLASS_PMEM_NAME \"pmem\" PMEM media class name. Updated on 16 December 2021 at 14:04:27 CST","title":"define HSE_MCLASS_PMEM_NAME"},{"location":"api/Modules/group__KVS/","text":"Key-Value Store (KVS) Data Structures Name struct hse_kvs Opaque structure, a pointer to which is a handle to an HSE KVS within a KVDB. Functions Name hse_err_t hse_kvdb_kvs_close (struct hse_kvs * kvs) Close an open KVS. hse_err_t hse_kvdb_kvs_create (struct hse_kvdb * kvdb, const char * kvs_name, size_t paramc, const char *const * paramv) Create a KVS within the referenced KVDB. hse_err_t hse_kvdb_kvs_drop (struct hse_kvdb * kvdb, const char * kvs_name) Drop a KVS from the referenced KVDB. hse_err_t hse_kvdb_kvs_open (struct hse_kvdb * handle, const char * kvs_name, const size_t paramc, const char const * paramv, struct hse_kvs * kvs_out) Open a KVS in a KVDB. hse_err_t hse_kvs_delete (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * key, size_t key_len) Delete the key and its associated value from the KVS. hse_err_t hse_kvs_get (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * key, size_t key_len, bool * found, void * buf, size_t buf_len, size_t * val_len) Retrieve the value for a given key from the KVS. const char * hse_kvs_name_get (struct hse_kvs * kvs) Get the name of a KVS. hse_err_t hse_kvs_param_get (struct hse_kvs * kvs, const char * param, char * buf, size_t buf_sz, size_t * needed_sz) Get KVS parameter. hse_err_t hse_kvs_prefix_delete (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * pfx, size_t pfx_len) Delete all key-value pairs matching the key prefix from a KVS storing segmented keys. hse_err_t hse_kvs_put (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * key, size_t key_len, const void * val, size_t val_len) Put a key-value pair into KVS. Defines Name HSE_KVS_COUNT_MAX Maximum number of KVSs contained within one KVDB. HSE_KVS_KEY_LEN_MAX Maximum key length. HSE_KVS_NAME_LEN_MAX Maximum length of a KVS name. HSE_KVS_PFX_LEN_MAX Max key prefix length. HSE_KVS_VALUE_LEN_MAX Max value length is 1MiB. Functions Documentation function hse_kvdb_kvs_close hse_err_t hse_kvdb_kvs_close ( struct hse_kvs * kvs ) Close an open KVS. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . Return : Error status. Note : This function is not thread safe. Warning : After invoking this function, calling any other KVS functions will result in undefined behavior unless the KVS is re-opened. function hse_kvdb_kvs_create hse_err_t hse_kvdb_kvs_create ( struct hse_kvdb * kvdb , const char * kvs_name , size_t paramc , const char * const * paramv ) Create a KVS within the referenced KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() . kvs_name KVS name. paramc Number of configuration parameters in paramv . paramv List of parameters in key=value format. Return : Error status. Note : This function is not thread safe. Remark : kvdb must not be NULL. kvs_name must be non-NULL. kvs_name must be NULL-terminated. strlen( kvs_name ) must be less than HSE_KVS_NAME_LEN_MAX. kvs_name must match the following pattern: [-_A-Za-z0-9]+. kvs_name cannot already exist. function hse_kvdb_kvs_drop hse_err_t hse_kvdb_kvs_drop ( struct hse_kvdb * kvdb , const char * kvs_name ) Drop a KVS from the referenced KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() . kvs_name KVS name. Return : Error status. Note : This function is not thread safe. Warning : It is an error to call this function on a KVS that is open. Remark : kvdb must not be NULL. kvs_name must not be NULL. kvs_name must be NULL-terminated. function hse_kvdb_kvs_open hse_err_t hse_kvdb_kvs_open ( struct hse_kvdb * handle , const char * kvs_name , const size_t paramc , const char * const * paramv , struct hse_kvs ** kvs_out ) Open a KVS in a KVDB. Parameters : handle KVDB handle from hse_kvdb_open() . kvs_name KVS name. paramc Number of configuration parameters in paramv . paramv List of parameters in key=value format. kvs_out Handle to access the opened KVS. Return : Error status. Remark : kvdb must not be NULL. kvs_name must not be NULL. kvs_name must be NULL-terminated. kvs_out must not be NULL. This function is not thread safe. function hse_kvs_delete hse_err_t hse_kvs_delete ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * key , size_t key_len ) Delete the key and its associated value from the KVS. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . flags Flags for operation specialization. txn Transaction context (optional). key Key to be deleted from kvs . key_len Length of key . Return : Error status. Note : This function is thread safe. Remark : kvs must not be NULL. key must not be NULL. key_len must be within the range of [1, HSE_KVS_KEY_LEN_MAX]. It is not an error if the key does not exist within the KVS. See Transactions for information on how deletes within transactions are handled. Flags: 0 - Reserved for future use. function hse_kvs_get hse_err_t hse_kvs_get ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * key , size_t key_len , bool * found , void * buf , size_t buf_len , size_t * val_len ) Retrieve the value for a given key from the KVS. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . flags Flags for operation specialization. txn Transaction context (optional). key Key to get from kvs . key_len Length of key . found Whether or not key was found. buf Buffer into which the value associated with key will be copied (optional). buf_len Length of buf . val_len Actual length of value if key was found. Return : Error status. Note : This function is thread safe. Remark : kvs must not be NULL. key must not be NULL. key_len must be within the range of [1, HSE_KVS_KEY_LEN_MAX]. found must not be NULL. val_len must not be NULL. If the key exists in the KVS, then the referent of found is set to true. If the caller's value buffer is large enough then the data will be returned. Regardless, the actual length of the value is placed in val_len . See Transactions for information on how gets within transactions are handled. Flags: 0 - Reserved for future use. function hse_kvs_name_get const char * hse_kvs_name_get ( struct hse_kvs * kvs ) Get the name of a KVS. Parameters : kvs KVS handle from hse_kvdb_kvs_open() Returns : NULL if given an invalid KVS handle. Return : KVS name. Note : This function is thread safe. Remark : kvs must not be NULL. function hse_kvs_param_get hse_err_t hse_kvs_param_get ( struct hse_kvs * kvs , const char * param , char * buf , size_t buf_sz , size_t * needed_sz ) Get KVS parameter. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . param Parameter name. buf Buffer for writing stringified value of parameter. buf_sz Size of buf . needed_sz Needed size of buf . Return : Error status. Note : This function is thread safe. Remark : kvs must not be NULL. param must not be NULL. param must be a valid parameter. Puts the stringified version of the parameter value into buf . If buf_sz is NULL, then needed_sz will still be populated. function hse_kvs_prefix_delete hse_err_t hse_kvs_prefix_delete ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * pfx , size_t pfx_len ) Delete all key-value pairs matching the key prefix from a KVS storing segmented keys. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . flags Flags for operation specialization. txn Transaction context (optional). pfx Prefix of keys to delete. pfx_len Length of pfx . Return : Error status. Note : This function is thread safe. Remark : kvs must not be NULL. pfx_len must be less than or equal to HSE_KVS_PFX_LEN_MAX. This interface is used to delete an entire range of segmented keys. To do this the caller passes a filter with a length equal to the KVSs key prefix length. It is not an error if no keys exist matching the filter. If there is a filtered iteration in progress, then that iteration can fail if hse_kvs_prefix_delete() is called with a filter matching the iteration. If hse_kvs_prefix_delete() is called from a transaction context, it affects no key-value mutations that are part of the same transaction. Stated differently, for KVS commands issued within a transaction, all calls to hse_kvs_prefix_delete() are treated as though they were issued serially at the beginning of the transaction regardless of the actual order these commands appeared in. Flags: 0 - Reserved for future use. function hse_kvs_put hse_err_t hse_kvs_put ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * key , size_t key_len , const void * val , size_t val_len ) Put a key-value pair into KVS. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . flags Flags for operation specialization. txn Transaction context (optional). key Key to put into kvs . key_len Length of key . val Value associated with key (optional). val_len Length of value . Return : Error status Note : This function is thread safe. Remark : kvs must not be NULL. key must not be NULL. key_len must be within the range of [1, HSE_KVS_KEY_LEN_MAX]. val_len must be within the range of [0, HSE_KVS_VALUE_LEN_MAX]. If the key already exists in the KVS then the value is effectively overwritten. See Transactions for information on how puts within transactions are handled. The HSE KVDB attempts to maintain reasonable QoS and for high-throughput clients this results in very short sleep's being inserted into the put path. For some kinds of data (e.g., control metadata) the client may wish to not experience that delay. For relatively low data rate uses, the caller can set the HSE_KVS_PUT_PRIO flag for an hse_kvs_put() . Care should be taken when doing so to ensure that the system does not become overrun. As a rough approximation, doing 1M priority puts per second marked as PRIO is likely an issue. On the other hand, doing 1K small puts per second marked as PRIO is almost certainly fine. If compression is enabled for the given kvs, then hse_kvs_put() will attempt to compress the value unless the HSE_KVS_PUT_VCOMP_OFF flag is given. Otherwise, the HSE_KVS_PUT_VCOMP_OFF flag is ignored. Flags: HSE_KVS_PUT_PRIO - Operation will not be throttled. HSE_KVS_PUT_VCOMP_OFF - Value will not be compressed. Macros Documentation define HSE_KVS_COUNT_MAX #define HSE_KVS_COUNT_MAX (256) Maximum number of KVSs contained within one KVDB. define HSE_KVS_KEY_LEN_MAX #define HSE_KVS_KEY_LEN_MAX 1344 Maximum key length. A common requirement clients have for key length is 1024. Combined with a discriminant and (potentially) a chunk key, this pushes us to 1030 bytes keys. Looking at the packing for the on-media format for data, we can have at most 3 keys of such large size in a 4k page. Lopping off 64-bytes for other data, and we can have 3 keys of 1344 bytes. Keys need not be NULL-terminated. define HSE_KVS_NAME_LEN_MAX #define HSE_KVS_NAME_LEN_MAX 32 Maximum length of a KVS name. KVS names are NULL-terminated strings. The string plus the NULL-terminator must fit into a HSE_KVS_NAME_LEN_MAX byte buffer. define HSE_KVS_PFX_LEN_MAX #define HSE_KVS_PFX_LEN_MAX 32 Max key prefix length. define HSE_KVS_VALUE_LEN_MAX #define HSE_KVS_VALUE_LEN_MAX (1024 * 1024) Max value length is 1MiB. Values need not be NULL-terminated. Updated on 16 December 2021 at 14:04:27 CST","title":"Key-Value Store (KVS)"},{"location":"api/Modules/group__KVS/#key-value-store-kvs","text":"","title":"Key-Value Store (KVS)"},{"location":"api/Modules/group__KVS/#data-structures","text":"Name struct hse_kvs Opaque structure, a pointer to which is a handle to an HSE KVS within a KVDB.","title":"Data Structures"},{"location":"api/Modules/group__KVS/#functions","text":"Name hse_err_t hse_kvdb_kvs_close (struct hse_kvs * kvs) Close an open KVS. hse_err_t hse_kvdb_kvs_create (struct hse_kvdb * kvdb, const char * kvs_name, size_t paramc, const char *const * paramv) Create a KVS within the referenced KVDB. hse_err_t hse_kvdb_kvs_drop (struct hse_kvdb * kvdb, const char * kvs_name) Drop a KVS from the referenced KVDB. hse_err_t hse_kvdb_kvs_open (struct hse_kvdb * handle, const char * kvs_name, const size_t paramc, const char const * paramv, struct hse_kvs * kvs_out) Open a KVS in a KVDB. hse_err_t hse_kvs_delete (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * key, size_t key_len) Delete the key and its associated value from the KVS. hse_err_t hse_kvs_get (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * key, size_t key_len, bool * found, void * buf, size_t buf_len, size_t * val_len) Retrieve the value for a given key from the KVS. const char * hse_kvs_name_get (struct hse_kvs * kvs) Get the name of a KVS. hse_err_t hse_kvs_param_get (struct hse_kvs * kvs, const char * param, char * buf, size_t buf_sz, size_t * needed_sz) Get KVS parameter. hse_err_t hse_kvs_prefix_delete (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * pfx, size_t pfx_len) Delete all key-value pairs matching the key prefix from a KVS storing segmented keys. hse_err_t hse_kvs_put (struct hse_kvs * kvs, unsigned int flags, struct hse_kvdb_txn * txn, const void * key, size_t key_len, const void * val, size_t val_len) Put a key-value pair into KVS.","title":"Functions"},{"location":"api/Modules/group__KVS/#defines","text":"Name HSE_KVS_COUNT_MAX Maximum number of KVSs contained within one KVDB. HSE_KVS_KEY_LEN_MAX Maximum key length. HSE_KVS_NAME_LEN_MAX Maximum length of a KVS name. HSE_KVS_PFX_LEN_MAX Max key prefix length. HSE_KVS_VALUE_LEN_MAX Max value length is 1MiB.","title":"Defines"},{"location":"api/Modules/group__KVS/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/Modules/group__KVS/#function-hse_kvdb_kvs_close","text":"hse_err_t hse_kvdb_kvs_close ( struct hse_kvs * kvs ) Close an open KVS. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . Return : Error status. Note : This function is not thread safe. Warning : After invoking this function, calling any other KVS functions will result in undefined behavior unless the KVS is re-opened.","title":"function hse_kvdb_kvs_close"},{"location":"api/Modules/group__KVS/#function-hse_kvdb_kvs_create","text":"hse_err_t hse_kvdb_kvs_create ( struct hse_kvdb * kvdb , const char * kvs_name , size_t paramc , const char * const * paramv ) Create a KVS within the referenced KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() . kvs_name KVS name. paramc Number of configuration parameters in paramv . paramv List of parameters in key=value format. Return : Error status. Note : This function is not thread safe. Remark : kvdb must not be NULL. kvs_name must be non-NULL. kvs_name must be NULL-terminated. strlen( kvs_name ) must be less than HSE_KVS_NAME_LEN_MAX. kvs_name must match the following pattern: [-_A-Za-z0-9]+. kvs_name cannot already exist.","title":"function hse_kvdb_kvs_create"},{"location":"api/Modules/group__KVS/#function-hse_kvdb_kvs_drop","text":"hse_err_t hse_kvdb_kvs_drop ( struct hse_kvdb * kvdb , const char * kvs_name ) Drop a KVS from the referenced KVDB. Parameters : kvdb KVDB handle from hse_kvdb_open() . kvs_name KVS name. Return : Error status. Note : This function is not thread safe. Warning : It is an error to call this function on a KVS that is open. Remark : kvdb must not be NULL. kvs_name must not be NULL. kvs_name must be NULL-terminated.","title":"function hse_kvdb_kvs_drop"},{"location":"api/Modules/group__KVS/#function-hse_kvdb_kvs_open","text":"hse_err_t hse_kvdb_kvs_open ( struct hse_kvdb * handle , const char * kvs_name , const size_t paramc , const char * const * paramv , struct hse_kvs ** kvs_out ) Open a KVS in a KVDB. Parameters : handle KVDB handle from hse_kvdb_open() . kvs_name KVS name. paramc Number of configuration parameters in paramv . paramv List of parameters in key=value format. kvs_out Handle to access the opened KVS. Return : Error status. Remark : kvdb must not be NULL. kvs_name must not be NULL. kvs_name must be NULL-terminated. kvs_out must not be NULL. This function is not thread safe.","title":"function hse_kvdb_kvs_open"},{"location":"api/Modules/group__KVS/#function-hse_kvs_delete","text":"hse_err_t hse_kvs_delete ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * key , size_t key_len ) Delete the key and its associated value from the KVS. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . flags Flags for operation specialization. txn Transaction context (optional). key Key to be deleted from kvs . key_len Length of key . Return : Error status. Note : This function is thread safe. Remark : kvs must not be NULL. key must not be NULL. key_len must be within the range of [1, HSE_KVS_KEY_LEN_MAX]. It is not an error if the key does not exist within the KVS. See Transactions for information on how deletes within transactions are handled. Flags: 0 - Reserved for future use.","title":"function hse_kvs_delete"},{"location":"api/Modules/group__KVS/#function-hse_kvs_get","text":"hse_err_t hse_kvs_get ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * key , size_t key_len , bool * found , void * buf , size_t buf_len , size_t * val_len ) Retrieve the value for a given key from the KVS. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . flags Flags for operation specialization. txn Transaction context (optional). key Key to get from kvs . key_len Length of key . found Whether or not key was found. buf Buffer into which the value associated with key will be copied (optional). buf_len Length of buf . val_len Actual length of value if key was found. Return : Error status. Note : This function is thread safe. Remark : kvs must not be NULL. key must not be NULL. key_len must be within the range of [1, HSE_KVS_KEY_LEN_MAX]. found must not be NULL. val_len must not be NULL. If the key exists in the KVS, then the referent of found is set to true. If the caller's value buffer is large enough then the data will be returned. Regardless, the actual length of the value is placed in val_len . See Transactions for information on how gets within transactions are handled. Flags: 0 - Reserved for future use.","title":"function hse_kvs_get"},{"location":"api/Modules/group__KVS/#function-hse_kvs_name_get","text":"const char * hse_kvs_name_get ( struct hse_kvs * kvs ) Get the name of a KVS. Parameters : kvs KVS handle from hse_kvdb_kvs_open() Returns : NULL if given an invalid KVS handle. Return : KVS name. Note : This function is thread safe. Remark : kvs must not be NULL.","title":"function hse_kvs_name_get"},{"location":"api/Modules/group__KVS/#function-hse_kvs_param_get","text":"hse_err_t hse_kvs_param_get ( struct hse_kvs * kvs , const char * param , char * buf , size_t buf_sz , size_t * needed_sz ) Get KVS parameter. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . param Parameter name. buf Buffer for writing stringified value of parameter. buf_sz Size of buf . needed_sz Needed size of buf . Return : Error status. Note : This function is thread safe. Remark : kvs must not be NULL. param must not be NULL. param must be a valid parameter. Puts the stringified version of the parameter value into buf . If buf_sz is NULL, then needed_sz will still be populated.","title":"function hse_kvs_param_get"},{"location":"api/Modules/group__KVS/#function-hse_kvs_prefix_delete","text":"hse_err_t hse_kvs_prefix_delete ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * pfx , size_t pfx_len ) Delete all key-value pairs matching the key prefix from a KVS storing segmented keys. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . flags Flags for operation specialization. txn Transaction context (optional). pfx Prefix of keys to delete. pfx_len Length of pfx . Return : Error status. Note : This function is thread safe. Remark : kvs must not be NULL. pfx_len must be less than or equal to HSE_KVS_PFX_LEN_MAX. This interface is used to delete an entire range of segmented keys. To do this the caller passes a filter with a length equal to the KVSs key prefix length. It is not an error if no keys exist matching the filter. If there is a filtered iteration in progress, then that iteration can fail if hse_kvs_prefix_delete() is called with a filter matching the iteration. If hse_kvs_prefix_delete() is called from a transaction context, it affects no key-value mutations that are part of the same transaction. Stated differently, for KVS commands issued within a transaction, all calls to hse_kvs_prefix_delete() are treated as though they were issued serially at the beginning of the transaction regardless of the actual order these commands appeared in. Flags: 0 - Reserved for future use.","title":"function hse_kvs_prefix_delete"},{"location":"api/Modules/group__KVS/#function-hse_kvs_put","text":"hse_err_t hse_kvs_put ( struct hse_kvs * kvs , unsigned int flags , struct hse_kvdb_txn * txn , const void * key , size_t key_len , const void * val , size_t val_len ) Put a key-value pair into KVS. Parameters : kvs KVS handle from hse_kvdb_kvs_open() . flags Flags for operation specialization. txn Transaction context (optional). key Key to put into kvs . key_len Length of key . val Value associated with key (optional). val_len Length of value . Return : Error status Note : This function is thread safe. Remark : kvs must not be NULL. key must not be NULL. key_len must be within the range of [1, HSE_KVS_KEY_LEN_MAX]. val_len must be within the range of [0, HSE_KVS_VALUE_LEN_MAX]. If the key already exists in the KVS then the value is effectively overwritten. See Transactions for information on how puts within transactions are handled. The HSE KVDB attempts to maintain reasonable QoS and for high-throughput clients this results in very short sleep's being inserted into the put path. For some kinds of data (e.g., control metadata) the client may wish to not experience that delay. For relatively low data rate uses, the caller can set the HSE_KVS_PUT_PRIO flag for an hse_kvs_put() . Care should be taken when doing so to ensure that the system does not become overrun. As a rough approximation, doing 1M priority puts per second marked as PRIO is likely an issue. On the other hand, doing 1K small puts per second marked as PRIO is almost certainly fine. If compression is enabled for the given kvs, then hse_kvs_put() will attempt to compress the value unless the HSE_KVS_PUT_VCOMP_OFF flag is given. Otherwise, the HSE_KVS_PUT_VCOMP_OFF flag is ignored. Flags: HSE_KVS_PUT_PRIO - Operation will not be throttled. HSE_KVS_PUT_VCOMP_OFF - Value will not be compressed.","title":"function hse_kvs_put"},{"location":"api/Modules/group__KVS/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"api/Modules/group__KVS/#define-hse_kvs_count_max","text":"#define HSE_KVS_COUNT_MAX (256) Maximum number of KVSs contained within one KVDB.","title":"define HSE_KVS_COUNT_MAX"},{"location":"api/Modules/group__KVS/#define-hse_kvs_key_len_max","text":"#define HSE_KVS_KEY_LEN_MAX 1344 Maximum key length. A common requirement clients have for key length is 1024. Combined with a discriminant and (potentially) a chunk key, this pushes us to 1030 bytes keys. Looking at the packing for the on-media format for data, we can have at most 3 keys of such large size in a 4k page. Lopping off 64-bytes for other data, and we can have 3 keys of 1344 bytes. Keys need not be NULL-terminated.","title":"define HSE_KVS_KEY_LEN_MAX"},{"location":"api/Modules/group__KVS/#define-hse_kvs_name_len_max","text":"#define HSE_KVS_NAME_LEN_MAX 32 Maximum length of a KVS name. KVS names are NULL-terminated strings. The string plus the NULL-terminator must fit into a HSE_KVS_NAME_LEN_MAX byte buffer.","title":"define HSE_KVS_NAME_LEN_MAX"},{"location":"api/Modules/group__KVS/#define-hse_kvs_pfx_len_max","text":"#define HSE_KVS_PFX_LEN_MAX 32 Max key prefix length.","title":"define HSE_KVS_PFX_LEN_MAX"},{"location":"api/Modules/group__KVS/#define-hse_kvs_value_len_max","text":"#define HSE_KVS_VALUE_LEN_MAX (1024 * 1024) Max value length is 1MiB. Values need not be NULL-terminated. Updated on 16 December 2021 at 14:04:27 CST","title":"define HSE_KVS_VALUE_LEN_MAX"},{"location":"api/Modules/group__SUBSYS/","text":"Subsystem Functions Name hse_err_t hse_init (const char * config, size_t paramc, const char *const * paramv) Initialize the HSE subsystem. void hse_fini (void ) Shutdown the HSE subsystem. hse_err_t hse_param_get (const char * param, char * buf, size_t buf_sz, size_t * needed_sz) Get HSE global parameter. Functions Documentation function hse_init hse_err_t hse_init ( const char * config , size_t paramc , const char * const * paramv ) Initialize the HSE subsystem. Parameters : config Path to a global configuration file. paramc Number of initialization parameters in paramv . paramv List of parameters in key=value format. Return : Error status. Note : This function is not thread safe and is idempotent. This function initializes a range of different internal HSE structures. It must be called before any other HSE functions are used. function hse_fini void hse_fini ( void ) Shutdown the HSE subsystem. Note : This function is not thread safe. Warning : After invoking this function, calling any other HSE functions will result in undefined behavior unless HSE is re-initialized. This function cleanly finalizes a range of different internal HSE structures. It should be called prior to application exit. function hse_param_get hse_err_t hse_param_get ( const char * param , char * buf , size_t buf_sz , size_t * needed_sz ) Get HSE global parameter. Parameters : param Parameter name. buf Buffer for writing stringified value of parameter. buf_sz Size of buf . needed_sz Needed size of buf . Return : Error status. Note : This function is thread safe. Remark : param must not be NULL. param must be a valid parameter. Puts the stringified version of the parameter value into buf . If buf_sz is NULL, then needed_sz will still be populated. Updated on 16 December 2021 at 14:04:27 CST","title":"Subsystem"},{"location":"api/Modules/group__SUBSYS/#subsystem","text":"","title":"Subsystem"},{"location":"api/Modules/group__SUBSYS/#functions","text":"Name hse_err_t hse_init (const char * config, size_t paramc, const char *const * paramv) Initialize the HSE subsystem. void hse_fini (void ) Shutdown the HSE subsystem. hse_err_t hse_param_get (const char * param, char * buf, size_t buf_sz, size_t * needed_sz) Get HSE global parameter.","title":"Functions"},{"location":"api/Modules/group__SUBSYS/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/Modules/group__SUBSYS/#function-hse_init","text":"hse_err_t hse_init ( const char * config , size_t paramc , const char * const * paramv ) Initialize the HSE subsystem. Parameters : config Path to a global configuration file. paramc Number of initialization parameters in paramv . paramv List of parameters in key=value format. Return : Error status. Note : This function is not thread safe and is idempotent. This function initializes a range of different internal HSE structures. It must be called before any other HSE functions are used.","title":"function hse_init"},{"location":"api/Modules/group__SUBSYS/#function-hse_fini","text":"void hse_fini ( void ) Shutdown the HSE subsystem. Note : This function is not thread safe. Warning : After invoking this function, calling any other HSE functions will result in undefined behavior unless HSE is re-initialized. This function cleanly finalizes a range of different internal HSE structures. It should be called prior to application exit.","title":"function hse_fini"},{"location":"api/Modules/group__SUBSYS/#function-hse_param_get","text":"hse_err_t hse_param_get ( const char * param , char * buf , size_t buf_sz , size_t * needed_sz ) Get HSE global parameter. Parameters : param Parameter name. buf Buffer for writing stringified value of parameter. buf_sz Size of buf . needed_sz Needed size of buf . Return : Error status. Note : This function is thread safe. Remark : param must not be NULL. param must be a valid parameter. Puts the stringified version of the parameter value into buf . If buf_sz is NULL, then needed_sz will still be populated. Updated on 16 December 2021 at 14:04:27 CST","title":"function hse_param_get"},{"location":"api/Modules/group__TRANSACTIONS/","text":"Transactions More... Data Structures Name struct hse_kvdb_txn Opaque structure, a pointer to which is a handle to a transaction within a KVDB. Types Name enum hse_kvdb_txn_state { HSE_KVDB_TXN_INVALID = 0, HSE_KVDB_TXN_ACTIVE = 1, HSE_KVDB_TXN_COMMITTED = 2, HSE_KVDB_TXN_ABORTED = 3} Transaction state. Functions Name hse_err_t hse_kvdb_txn_abort (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Abort/rollback transaction. struct hse_kvdb_txn * hse_kvdb_txn_alloc (struct hse_kvdb * kvdb) Allocate transaction object. hse_err_t hse_kvdb_txn_begin (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Initiate transaction. hse_err_t hse_kvdb_txn_commit (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Commit all the mutations of the referenced transaction. void hse_kvdb_txn_free (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Free transaction object. enum hse_kvdb_txn_state hse_kvdb_txn_state_get (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Retrieve the state of the referenced transaction. Detailed Description The HSE KVDB provides transactions with operations spanning KVSs within a single KVDB. These transactions have snapshot isolation (a specific form of MVCC) with the normal semantics (see \"Concurrency Control and Recovery in Database Systems\" by PA Bernstein). One unusual aspect of the API as it relates to transactions is that the data object that is used to hold client-level transaction state is allocated separately from the transaction being initiated. As a result, the same object handle should be reused again and again. In addition, there is very limited coupling between threading and transactions. A single thread may have many transactions in flight simultaneously. Also operations within a transaction can be performed by multiple threads. The latter mode of operation must currently restrict calls so that only one thread is actively performing an operation in the context of a particular transaction at any particular time. The general lifecycle of a transaction is as follows: +----------+ | INVALID | +----------+ | v +----------+ +---------------->| ACTIVE |<----------------+ | +----------+ | | +-----------+ | | +----------+ | +--| COMMITTED |<---+ +---->| ABORTED |--+ +-----------+ +----------+ When a transaction is initially allocated, it starts in the INVALID state. When hse_kvdb_txn_begin() is called with transaction in the INVALID, COMMITTED, or ABORTED states, it moves to the ACTIVE state. It is an error to call the hse_kvdb_txn_begin() function on a transaction in the ACTIVE state. For a transaction in the ACTIVE state, only the functions hse_kvdb_txn_commit() , hse_kvdb_txn_abort() , or hse_kvdb_txn_free() may be called (with the last doing an abort prior to the free). When a transaction becomes ACTIVE, it establishes an ephemeral snapshot view of the state of the KVDB. Any data mutations outside of the transaction's context after that point are not visible to the transaction. Similarly, any mutations performed within the context of the transaction are not visible outside of the transaction unless and until it is committed. All such mutations become visible atomically when the transaction commits. Within a transaction whenever a write operation e.g., put, delete, etc., encounters a write conflict, that operation returns an error code of ECANCELED. The caller is then expected to re-try the operation in a new transaction, see Errors . Types Documentation enum hse_kvdb_txn_state Enumerator Value Description HSE_KVDB_TXN_INVALID 0 invalid state HSE_KVDB_TXN_ACTIVE 1 active state HSE_KVDB_TXN_COMMITTED 2 committed state HSE_KVDB_TXN_ABORTED 3 aborted state Transaction state. Functions Documentation function hse_kvdb_txn_abort hse_err_t hse_kvdb_txn_abort ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Abort/rollback transaction. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle from hse_kvdb_txn_alloc() . Return : Error status. Note : This function is thread safe with different transactions. Warning : The call fails if the referenced transaction is not in the ACTIVE state. Remark : kvdb must not be NULL. txn must not be NULL. function hse_kvdb_txn_alloc struct hse_kvdb_txn * hse_kvdb_txn_alloc ( struct hse_kvdb * kvdb ) Allocate transaction object. Parameters : kvdb KVDB handle from hse_kvdb_open() . Return : The allocated transaction structure. Note : This function is thread safe. Remark : kvdb must not be NULL. This object can and should be re-used many times to avoid the overhead of allocation. function hse_kvdb_txn_begin hse_err_t hse_kvdb_txn_begin ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Initiate transaction. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle from hse_kvdb_txn_alloc() . Return : Error status. Note : This function is thread safe with different transactions. Warning : The call fails if the transaction handle refers to an ACTIVE transaction. Remark : kvdb must not be NULL. txn must not be NULL. function hse_kvdb_txn_commit hse_err_t hse_kvdb_txn_commit ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Commit all the mutations of the referenced transaction. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle from hse_kvdb_txn_alloc() . Return : Error status Note : This function is thread safe with different transactions. Warning : The call fails if the referenced transaction is not in the ACTIVE state. Remark : kvdb must not be NULL. txn must not be NULL. function hse_kvdb_txn_free void hse_kvdb_txn_free ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Free transaction object. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle. Note : If the transaction handle refers to an ACTIVE transaction, the transaction is aborted prior to being freed. This function is thread safe with different transactions. Warning : After invoking this function, calling any other transaction functions with this handle will result in undefined behavior. Remark : kvdb must not be NULL. txn must not be NULL. function hse_kvdb_txn_state_get enum hse_kvdb_txn_state hse_kvdb_txn_state_get ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Retrieve the state of the referenced transaction. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle from hse_kvdb_txn_alloc() . Return : Transaction's state. Remark : kvdb must not be NULL. txn must not be NULL. This function is thread safe with different transactions. Updated on 16 December 2021 at 14:04:27 CST","title":"Transactions"},{"location":"api/Modules/group__TRANSACTIONS/#transactions","text":"More...","title":"Transactions"},{"location":"api/Modules/group__TRANSACTIONS/#data-structures","text":"Name struct hse_kvdb_txn Opaque structure, a pointer to which is a handle to a transaction within a KVDB.","title":"Data Structures"},{"location":"api/Modules/group__TRANSACTIONS/#types","text":"Name enum hse_kvdb_txn_state { HSE_KVDB_TXN_INVALID = 0, HSE_KVDB_TXN_ACTIVE = 1, HSE_KVDB_TXN_COMMITTED = 2, HSE_KVDB_TXN_ABORTED = 3} Transaction state.","title":"Types"},{"location":"api/Modules/group__TRANSACTIONS/#functions","text":"Name hse_err_t hse_kvdb_txn_abort (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Abort/rollback transaction. struct hse_kvdb_txn * hse_kvdb_txn_alloc (struct hse_kvdb * kvdb) Allocate transaction object. hse_err_t hse_kvdb_txn_begin (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Initiate transaction. hse_err_t hse_kvdb_txn_commit (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Commit all the mutations of the referenced transaction. void hse_kvdb_txn_free (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Free transaction object. enum hse_kvdb_txn_state hse_kvdb_txn_state_get (struct hse_kvdb * kvdb, struct hse_kvdb_txn * txn) Retrieve the state of the referenced transaction.","title":"Functions"},{"location":"api/Modules/group__TRANSACTIONS/#detailed-description","text":"The HSE KVDB provides transactions with operations spanning KVSs within a single KVDB. These transactions have snapshot isolation (a specific form of MVCC) with the normal semantics (see \"Concurrency Control and Recovery in Database Systems\" by PA Bernstein). One unusual aspect of the API as it relates to transactions is that the data object that is used to hold client-level transaction state is allocated separately from the transaction being initiated. As a result, the same object handle should be reused again and again. In addition, there is very limited coupling between threading and transactions. A single thread may have many transactions in flight simultaneously. Also operations within a transaction can be performed by multiple threads. The latter mode of operation must currently restrict calls so that only one thread is actively performing an operation in the context of a particular transaction at any particular time. The general lifecycle of a transaction is as follows: +----------+ | INVALID | +----------+ | v +----------+ +---------------->| ACTIVE |<----------------+ | +----------+ | | +-----------+ | | +----------+ | +--| COMMITTED |<---+ +---->| ABORTED |--+ +-----------+ +----------+ When a transaction is initially allocated, it starts in the INVALID state. When hse_kvdb_txn_begin() is called with transaction in the INVALID, COMMITTED, or ABORTED states, it moves to the ACTIVE state. It is an error to call the hse_kvdb_txn_begin() function on a transaction in the ACTIVE state. For a transaction in the ACTIVE state, only the functions hse_kvdb_txn_commit() , hse_kvdb_txn_abort() , or hse_kvdb_txn_free() may be called (with the last doing an abort prior to the free). When a transaction becomes ACTIVE, it establishes an ephemeral snapshot view of the state of the KVDB. Any data mutations outside of the transaction's context after that point are not visible to the transaction. Similarly, any mutations performed within the context of the transaction are not visible outside of the transaction unless and until it is committed. All such mutations become visible atomically when the transaction commits. Within a transaction whenever a write operation e.g., put, delete, etc., encounters a write conflict, that operation returns an error code of ECANCELED. The caller is then expected to re-try the operation in a new transaction, see Errors .","title":"Detailed Description"},{"location":"api/Modules/group__TRANSACTIONS/#types-documentation","text":"","title":"Types Documentation"},{"location":"api/Modules/group__TRANSACTIONS/#enum-hse_kvdb_txn_state","text":"Enumerator Value Description HSE_KVDB_TXN_INVALID 0 invalid state HSE_KVDB_TXN_ACTIVE 1 active state HSE_KVDB_TXN_COMMITTED 2 committed state HSE_KVDB_TXN_ABORTED 3 aborted state Transaction state.","title":"enum hse_kvdb_txn_state"},{"location":"api/Modules/group__TRANSACTIONS/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"api/Modules/group__TRANSACTIONS/#function-hse_kvdb_txn_abort","text":"hse_err_t hse_kvdb_txn_abort ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Abort/rollback transaction. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle from hse_kvdb_txn_alloc() . Return : Error status. Note : This function is thread safe with different transactions. Warning : The call fails if the referenced transaction is not in the ACTIVE state. Remark : kvdb must not be NULL. txn must not be NULL.","title":"function hse_kvdb_txn_abort"},{"location":"api/Modules/group__TRANSACTIONS/#function-hse_kvdb_txn_alloc","text":"struct hse_kvdb_txn * hse_kvdb_txn_alloc ( struct hse_kvdb * kvdb ) Allocate transaction object. Parameters : kvdb KVDB handle from hse_kvdb_open() . Return : The allocated transaction structure. Note : This function is thread safe. Remark : kvdb must not be NULL. This object can and should be re-used many times to avoid the overhead of allocation.","title":"function hse_kvdb_txn_alloc"},{"location":"api/Modules/group__TRANSACTIONS/#function-hse_kvdb_txn_begin","text":"hse_err_t hse_kvdb_txn_begin ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Initiate transaction. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle from hse_kvdb_txn_alloc() . Return : Error status. Note : This function is thread safe with different transactions. Warning : The call fails if the transaction handle refers to an ACTIVE transaction. Remark : kvdb must not be NULL. txn must not be NULL.","title":"function hse_kvdb_txn_begin"},{"location":"api/Modules/group__TRANSACTIONS/#function-hse_kvdb_txn_commit","text":"hse_err_t hse_kvdb_txn_commit ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Commit all the mutations of the referenced transaction. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle from hse_kvdb_txn_alloc() . Return : Error status Note : This function is thread safe with different transactions. Warning : The call fails if the referenced transaction is not in the ACTIVE state. Remark : kvdb must not be NULL. txn must not be NULL.","title":"function hse_kvdb_txn_commit"},{"location":"api/Modules/group__TRANSACTIONS/#function-hse_kvdb_txn_free","text":"void hse_kvdb_txn_free ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Free transaction object. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle. Note : If the transaction handle refers to an ACTIVE transaction, the transaction is aborted prior to being freed. This function is thread safe with different transactions. Warning : After invoking this function, calling any other transaction functions with this handle will result in undefined behavior. Remark : kvdb must not be NULL. txn must not be NULL.","title":"function hse_kvdb_txn_free"},{"location":"api/Modules/group__TRANSACTIONS/#function-hse_kvdb_txn_state_get","text":"enum hse_kvdb_txn_state hse_kvdb_txn_state_get ( struct hse_kvdb * kvdb , struct hse_kvdb_txn * txn ) Retrieve the state of the referenced transaction. Parameters : kvdb KVDB handle from hse_kvdb_open() . txn KVDB transaction handle from hse_kvdb_txn_alloc() . Return : Transaction's state. Remark : kvdb must not be NULL. txn must not be NULL. This function is thread safe with different transactions. Updated on 16 December 2021 at 14:04:27 CST","title":"function hse_kvdb_txn_state_get"},{"location":"api/Modules/group__VERSION/","text":"Version Information More... Defines Name HSE_VERSION_STRING A string representing the HSE version. HSE_VERSION_MAJOR Major version of HSE. HSE_VERSION_MINOR Minor version of HSE. HSE_VERSION_PATCH Patch version of HSE. Detailed Description Various version contants describing the HSE build. Macros Documentation define HSE_VERSION_STRING #define HSE_VERSION_STRING \"r2.1.0-0-g90a19368\" A string representing the HSE version. define HSE_VERSION_MAJOR #define HSE_VERSION_MAJOR 2 Major version of HSE. define HSE_VERSION_MINOR #define HSE_VERSION_MINOR 1 Minor version of HSE. define HSE_VERSION_PATCH #define HSE_VERSION_PATCH 0 Patch version of HSE. Updated on 16 December 2021 at 14:04:27 CST","title":"Version Information"},{"location":"api/Modules/group__VERSION/#version-information","text":"More...","title":"Version Information"},{"location":"api/Modules/group__VERSION/#defines","text":"Name HSE_VERSION_STRING A string representing the HSE version. HSE_VERSION_MAJOR Major version of HSE. HSE_VERSION_MINOR Minor version of HSE. HSE_VERSION_PATCH Patch version of HSE.","title":"Defines"},{"location":"api/Modules/group__VERSION/#detailed-description","text":"Various version contants describing the HSE build.","title":"Detailed Description"},{"location":"api/Modules/group__VERSION/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"api/Modules/group__VERSION/#define-hse_version_string","text":"#define HSE_VERSION_STRING \"r2.1.0-0-g90a19368\" A string representing the HSE version.","title":"define HSE_VERSION_STRING"},{"location":"api/Modules/group__VERSION/#define-hse_version_major","text":"#define HSE_VERSION_MAJOR 2 Major version of HSE.","title":"define HSE_VERSION_MAJOR"},{"location":"api/Modules/group__VERSION/#define-hse_version_minor","text":"#define HSE_VERSION_MINOR 1 Minor version of HSE.","title":"define HSE_VERSION_MINOR"},{"location":"api/Modules/group__VERSION/#define-hse_version_patch","text":"#define HSE_VERSION_PATCH 0 Patch version of HSE. Updated on 16 December 2021 at 14:04:27 CST","title":"define HSE_VERSION_PATCH"},{"location":"api/Pages/","text":"Examples page Examples page Overview Updated on 16 December 2021 at 14:04:28 CST","title":"Examples"},{"location":"api/Pages/#examples","text":"page Examples page Overview Updated on 16 December 2021 at 14:04:28 CST","title":"Examples"},{"location":"api/Pages/examples/","text":"Examples See the samples directory in the source tree for examples. Here is a simple one. /* SPDX-License-Identifier: Apache-2.0 */ /* * Copyright (C) 2015-2021 Micron Technology, Inc. All rights reserved. */ #include <stdio.h> #include <string.h> #include <hse/hse.h> #include \"helper.h\" /* * This is a simple example application that performs basic key-value operations * on a KVS. * * This program * 1. puts few keys into a KVS * 2. verifies that hse_kvs_get() can find them. * 3. delete one of the keys * 4. verify that the deleted key cannot be found. */ int usage ( char * prog ) { printf ( \"usage: %s <kvdb_home> <kvs> \\n \" , prog ); return 1 ; } int main ( int argc , char ** argv ) { char * kvdb_home , * kvs_name ; struct hse_kvdb * kvdb ; struct hse_kvs * kvs ; const char * paramv [] = { \"logging.destination=stdout\" , \"logging.level=3\" , \"socket.enabled=false\" }; const size_t paramc = sizeof ( paramv ) / sizeof ( paramv [ 0 ]); size_t vlen ; char vbuf [ 32 ]; bool found ; hse_err_t rc , rc2 ; if ( argc != 3 ) return usage ( argv [ 0 ]); kvdb_home = argv [ 1 ]; kvs_name = argv [ 2 ]; rc = hse_init ( NULL , paramc , paramv ); if ( rc ) { error ( rc , \"Failed to initialize KVDB (%s)\" , kvdb_home ); goto out ; } rc = hse_kvdb_open ( kvdb_home , 0 , NULL , & kvdb ); if ( rc ) { error ( rc , \"Cannot open KVDB (%s)\" , kvdb_home ); goto hse_cleanup ; } rc = hse_kvdb_kvs_open ( kvdb , kvs_name , 0 , NULL , & kvs ); if ( rc ) { error ( rc , \"Cannot open KVS (%s)\" , kvs_name ); goto kvdb_cleanup ; } /* Error handling is elided for clarity */ /* 1. Put a few keys and verify that hse_kvs_get() can find them */ rc = hse_kvs_put ( kvs , 0 , NULL , \"k1\" , 2 , \"val1\" , 4 ); rc = rc ?: hse_kvs_put ( kvs , 0 , NULL , \"k2\" , 2 , \"val2\" , 4 ); rc = rc ?: hse_kvs_put ( kvs , 0 , NULL , \"k3\" , 2 , \"val3\" , 4 ); rc = rc ?: hse_kvs_put ( kvs , 0 , NULL , \"k4\" , 2 , NULL , 0 ); if ( rc ) { error ( rc , \"Failed to put data into KVS (%s)\" , kvs_name ); goto kvs_cleanup ; } rc = hse_kvs_get ( kvs , 0 , NULL , \"k1\" , 2 , & found , vbuf , sizeof ( vbuf ), & vlen ); if ( rc ) { error ( rc , \"Failed to get k1 data\" ); goto kvs_cleanup ; } printf ( \"k1 found = %s \\n \" , found ? \"true\" : \"false\" ); rc = hse_kvs_get ( kvs , 0 , NULL , \"k2\" , 2 , & found , vbuf , sizeof ( vbuf ), & vlen ); if ( rc ) { error ( rc , \"Failed to get k2 data\" ); goto kvs_cleanup ; } printf ( \"k2 found = %s \\n \" , found ? \"true\" : \"false\" ); rc = hse_kvs_get ( kvs , 0 , NULL , \"k3\" , 2 , & found , vbuf , sizeof ( vbuf ), & vlen ); if ( rc ) { error ( rc , \"Failed to get k3 data\" ); goto kvs_cleanup ; } printf ( \"k3 found = %s \\n \" , found ? \"true\" : \"false\" ); rc = hse_kvs_get ( kvs , 0 , NULL , \"k4\" , 2 , & found , vbuf , sizeof ( vbuf ), & vlen ); if ( rc ) { error ( rc , \"Failed to get k4 data\" ); goto kvs_cleanup ; } printf ( \"k4 found = %s, length was %lu bytes \\n \" , found ? \"true\" : \"false\" , vlen ); /* 2. Delete a key and ensure that it cannot be found by hse_kvs_get() */ rc = hse_kvs_delete ( kvs , 0 , NULL , \"k1\" , 2 ); if ( rc ) { error ( rc , \"Failed to delete k1 data\" ); goto kvs_cleanup ; } printf ( \"k1 deleted \\n \" ); rc = hse_kvs_get ( kvs , 0 , NULL , \"k1\" , 2 , & found , vbuf , sizeof ( vbuf ), & vlen ); if ( rc ) { error ( rc , \"Failed to get k1 data\" ); goto kvs_cleanup ; } printf ( \"k1 found = %s \\n \" , found ? \"true\" : \"false\" ); kvs_cleanup : rc2 = hse_kvdb_kvs_close ( kvs ); if ( rc2 ) error ( rc2 , \"Failed to close KVS (%s)\" , kvs_name ); rc = rc ?: rc2 ; kvdb_cleanup : rc2 = hse_kvdb_close ( kvdb ); if ( rc2 ) error ( rc2 , \"Failed to close KVDB (%s)\" , kvdb_home ); rc = rc ?: rc2 ; hse_cleanup : hse_fini (); out : return hse_err_to_errno ( rc ); } Filename: ex2_simple_ops.c Updated on 16 December 2021 at 14:04:28 CST","title":"Examples"},{"location":"api/Pages/examples/#examples","text":"See the samples directory in the source tree for examples. Here is a simple one. /* SPDX-License-Identifier: Apache-2.0 */ /* * Copyright (C) 2015-2021 Micron Technology, Inc. All rights reserved. */ #include <stdio.h> #include <string.h> #include <hse/hse.h> #include \"helper.h\" /* * This is a simple example application that performs basic key-value operations * on a KVS. * * This program * 1. puts few keys into a KVS * 2. verifies that hse_kvs_get() can find them. * 3. delete one of the keys * 4. verify that the deleted key cannot be found. */ int usage ( char * prog ) { printf ( \"usage: %s <kvdb_home> <kvs> \\n \" , prog ); return 1 ; } int main ( int argc , char ** argv ) { char * kvdb_home , * kvs_name ; struct hse_kvdb * kvdb ; struct hse_kvs * kvs ; const char * paramv [] = { \"logging.destination=stdout\" , \"logging.level=3\" , \"socket.enabled=false\" }; const size_t paramc = sizeof ( paramv ) / sizeof ( paramv [ 0 ]); size_t vlen ; char vbuf [ 32 ]; bool found ; hse_err_t rc , rc2 ; if ( argc != 3 ) return usage ( argv [ 0 ]); kvdb_home = argv [ 1 ]; kvs_name = argv [ 2 ]; rc = hse_init ( NULL , paramc , paramv ); if ( rc ) { error ( rc , \"Failed to initialize KVDB (%s)\" , kvdb_home ); goto out ; } rc = hse_kvdb_open ( kvdb_home , 0 , NULL , & kvdb ); if ( rc ) { error ( rc , \"Cannot open KVDB (%s)\" , kvdb_home ); goto hse_cleanup ; } rc = hse_kvdb_kvs_open ( kvdb , kvs_name , 0 , NULL , & kvs ); if ( rc ) { error ( rc , \"Cannot open KVS (%s)\" , kvs_name ); goto kvdb_cleanup ; } /* Error handling is elided for clarity */ /* 1. Put a few keys and verify that hse_kvs_get() can find them */ rc = hse_kvs_put ( kvs , 0 , NULL , \"k1\" , 2 , \"val1\" , 4 ); rc = rc ?: hse_kvs_put ( kvs , 0 , NULL , \"k2\" , 2 , \"val2\" , 4 ); rc = rc ?: hse_kvs_put ( kvs , 0 , NULL , \"k3\" , 2 , \"val3\" , 4 ); rc = rc ?: hse_kvs_put ( kvs , 0 , NULL , \"k4\" , 2 , NULL , 0 ); if ( rc ) { error ( rc , \"Failed to put data into KVS (%s)\" , kvs_name ); goto kvs_cleanup ; } rc = hse_kvs_get ( kvs , 0 , NULL , \"k1\" , 2 , & found , vbuf , sizeof ( vbuf ), & vlen ); if ( rc ) { error ( rc , \"Failed to get k1 data\" ); goto kvs_cleanup ; } printf ( \"k1 found = %s \\n \" , found ? \"true\" : \"false\" ); rc = hse_kvs_get ( kvs , 0 , NULL , \"k2\" , 2 , & found , vbuf , sizeof ( vbuf ), & vlen ); if ( rc ) { error ( rc , \"Failed to get k2 data\" ); goto kvs_cleanup ; } printf ( \"k2 found = %s \\n \" , found ? \"true\" : \"false\" ); rc = hse_kvs_get ( kvs , 0 , NULL , \"k3\" , 2 , & found , vbuf , sizeof ( vbuf ), & vlen ); if ( rc ) { error ( rc , \"Failed to get k3 data\" ); goto kvs_cleanup ; } printf ( \"k3 found = %s \\n \" , found ? \"true\" : \"false\" ); rc = hse_kvs_get ( kvs , 0 , NULL , \"k4\" , 2 , & found , vbuf , sizeof ( vbuf ), & vlen ); if ( rc ) { error ( rc , \"Failed to get k4 data\" ); goto kvs_cleanup ; } printf ( \"k4 found = %s, length was %lu bytes \\n \" , found ? \"true\" : \"false\" , vlen ); /* 2. Delete a key and ensure that it cannot be found by hse_kvs_get() */ rc = hse_kvs_delete ( kvs , 0 , NULL , \"k1\" , 2 ); if ( rc ) { error ( rc , \"Failed to delete k1 data\" ); goto kvs_cleanup ; } printf ( \"k1 deleted \\n \" ); rc = hse_kvs_get ( kvs , 0 , NULL , \"k1\" , 2 , & found , vbuf , sizeof ( vbuf ), & vlen ); if ( rc ) { error ( rc , \"Failed to get k1 data\" ); goto kvs_cleanup ; } printf ( \"k1 found = %s \\n \" , found ? \"true\" : \"false\" ); kvs_cleanup : rc2 = hse_kvdb_kvs_close ( kvs ); if ( rc2 ) error ( rc2 , \"Failed to close KVS (%s)\" , kvs_name ); rc = rc ?: rc2 ; kvdb_cleanup : rc2 = hse_kvdb_close ( kvdb ); if ( rc2 ) error ( rc2 , \"Failed to close KVDB (%s)\" , kvdb_home ); rc = rc ?: rc2 ; hse_cleanup : hse_fini (); out : return hse_err_to_errno ( rc ); } Filename: ex2_simple_ops.c Updated on 16 December 2021 at 14:04:28 CST","title":"Examples"},{"location":"api/Structs/","text":"Data Structures struct hse_kvdb Opaque structure, a pointer to which is a handle to an HSE key-value database (KVDB). struct hse_kvdb_txn Opaque structure, a pointer to which is a handle to a transaction within a KVDB. struct hse_kvs Opaque structure, a pointer to which is a handle to an HSE KVS within a KVDB. struct hse_kvs_cursor Opaque structure, a pointer to which is a handle to a cursor within a KVS. struct hse_mclass_info Media class information. Updated on 16 December 2021 at 14:04:28 CST","title":"Data Structures"},{"location":"api/Structs/#data-structures","text":"struct hse_kvdb Opaque structure, a pointer to which is a handle to an HSE key-value database (KVDB). struct hse_kvdb_txn Opaque structure, a pointer to which is a handle to a transaction within a KVDB. struct hse_kvs Opaque structure, a pointer to which is a handle to an HSE KVS within a KVDB. struct hse_kvs_cursor Opaque structure, a pointer to which is a handle to a cursor within a KVS. struct hse_mclass_info Media class information. Updated on 16 December 2021 at 14:04:28 CST","title":"Data Structures"},{"location":"api/Structs/structhse__kvdb/","text":"hse_kvdb Module: Key-Value Database (KVDB) Opaque structure, a pointer to which is a handle to an HSE key-value database (KVDB). #include <types.h> Updated on 16 December 2021 at 14:04:27 CST","title":"hse_kvdb"},{"location":"api/Structs/structhse__kvdb/#hse_kvdb","text":"Module: Key-Value Database (KVDB) Opaque structure, a pointer to which is a handle to an HSE key-value database (KVDB). #include <types.h> Updated on 16 December 2021 at 14:04:27 CST","title":"hse_kvdb"},{"location":"api/Structs/structhse__kvdb__txn/","text":"hse_kvdb_txn Module: Transactions Opaque structure, a pointer to which is a handle to a transaction within a KVDB. #include <types.h> Updated on 16 December 2021 at 14:04:27 CST","title":"hse_kvdb_txn"},{"location":"api/Structs/structhse__kvdb__txn/#hse_kvdb_txn","text":"Module: Transactions Opaque structure, a pointer to which is a handle to a transaction within a KVDB. #include <types.h> Updated on 16 December 2021 at 14:04:27 CST","title":"hse_kvdb_txn"},{"location":"api/Structs/structhse__kvs/","text":"hse_kvs Module: Key-Value Store (KVS) Opaque structure, a pointer to which is a handle to an HSE KVS within a KVDB. #include <types.h> Updated on 16 December 2021 at 14:04:27 CST","title":"hse_kvs"},{"location":"api/Structs/structhse__kvs/#hse_kvs","text":"Module: Key-Value Store (KVS) Opaque structure, a pointer to which is a handle to an HSE KVS within a KVDB. #include <types.h> Updated on 16 December 2021 at 14:04:27 CST","title":"hse_kvs"},{"location":"api/Structs/structhse__kvs__cursor/","text":"hse_kvs_cursor Module: Cursors Opaque structure, a pointer to which is a handle to a cursor within a KVS. #include <types.h> Updated on 16 December 2021 at 14:04:27 CST","title":"hse_kvs_cursor"},{"location":"api/Structs/structhse__kvs__cursor/#hse_kvs_cursor","text":"Module: Cursors Opaque structure, a pointer to which is a handle to a cursor within a KVS. #include <types.h> Updated on 16 December 2021 at 14:04:27 CST","title":"hse_kvs_cursor"},{"location":"api/Structs/structhse__mclass__info/","text":"hse_mclass_info Module: Key-Value Database (KVDB) Media class information. #include <types.h> Public Attributes Name uint64_t mi_allocated_bytes uint64_t mi_used_bytes uint64_t mi_reserved char mi_path Public Attributes Documentation variable mi_allocated_bytes uint64_t mi_allocated_bytes ; Allocated storage space for a media class. variable mi_used_bytes uint64_t mi_used_bytes ; Used storage space for a media class. variable mi_reserved uint64_t mi_reserved ; Reserved space for future expansion. variable mi_path char mi_path ; Path to the media class. Updated on 16 December 2021 at 14:04:27 CST","title":"hse_mclass_info"},{"location":"api/Structs/structhse__mclass__info/#hse_mclass_info","text":"Module: Key-Value Database (KVDB) Media class information. #include <types.h>","title":"hse_mclass_info"},{"location":"api/Structs/structhse__mclass__info/#public-attributes","text":"Name uint64_t mi_allocated_bytes uint64_t mi_used_bytes uint64_t mi_reserved char mi_path","title":"Public Attributes"},{"location":"api/Structs/structhse__mclass__info/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"api/Structs/structhse__mclass__info/#variable-mi_allocated_bytes","text":"uint64_t mi_allocated_bytes ; Allocated storage space for a media class.","title":"variable mi_allocated_bytes"},{"location":"api/Structs/structhse__mclass__info/#variable-mi_used_bytes","text":"uint64_t mi_used_bytes ; Used storage space for a media class.","title":"variable mi_used_bytes"},{"location":"api/Structs/structhse__mclass__info/#variable-mi_reserved","text":"uint64_t mi_reserved ; Reserved space for future expansion.","title":"variable mi_reserved"},{"location":"api/Structs/structhse__mclass__info/#variable-mi_path","text":"char mi_path ; Path to the media class. Updated on 16 December 2021 at 14:04:27 CST","title":"variable mi_path"},{"location":"dev/bp/","text":"Best Practices The following are best practices for developing HSE applications. Many of these are covered in greater detail in the discussion of HSE concepts . Keys and KVSs Use a segmented key in the common case where related sets of KV pairs in a KVS are accessed together. Choose a key prefix that groups related KV pairs when keys are sorted lexicographically, and always create the KVS storing these KV pairs with a prefix.length equal to the key prefix length. Choose a key prefix for segmented keys that will take on a modest number of different values over a consecutive sequence of puts. For example, in a sequence of one million put operations, ideally no more than 5% of the keys will have the same key prefix value. Use a different KVS for each collection of KV pairs requiring its own segmented key structure. Create index KVSs to efficiently implement query patterns that cannot be supported with a single segmented key prefix. Use an unsegmented key in the case where there is no relationship between KV pairs in a KVS, and always create the KVS storing these KV pairs with a prefix.length of zero (0). Cursors and Gets Always use get operations when iteration is not required. Gets are significantly faster than cursor seeks. Where iteration is required, use cursors with a KVS storing segmented keys, and with a filter whose length is equal to or greater than the key prefix length for that KVS. Otherwise, cursor performance can be greatly reduced. Use non-transaction cursors for most applications. Transaction cursors exist to support some specialized use cases. Transactions Use transactions when required for application correctness. Otherwise, for best performance open a KVS with transactions disabled ( transactions.enabled=false ) and use non-transaction operations. Application Lifecycle At application startup, call hse_init() to initialize the HSE subsystem within your application. This function should be called only once. From there you can create or open a KVDB and its associated KVSs and perform KV operations. At application shutdown, close all KVSs for a KVDB before closing that KVDB. After all KVDBs are closed, call hse_fini() to completely shutdown the HSE subsystem within your application. Using a signal handler to close resources can also be helpful when trying to handle unexpected application shutdown.","title":"Best Practices"},{"location":"dev/bp/#best-practices","text":"The following are best practices for developing HSE applications. Many of these are covered in greater detail in the discussion of HSE concepts .","title":"Best Practices"},{"location":"dev/bp/#keys-and-kvss","text":"Use a segmented key in the common case where related sets of KV pairs in a KVS are accessed together. Choose a key prefix that groups related KV pairs when keys are sorted lexicographically, and always create the KVS storing these KV pairs with a prefix.length equal to the key prefix length. Choose a key prefix for segmented keys that will take on a modest number of different values over a consecutive sequence of puts. For example, in a sequence of one million put operations, ideally no more than 5% of the keys will have the same key prefix value. Use a different KVS for each collection of KV pairs requiring its own segmented key structure. Create index KVSs to efficiently implement query patterns that cannot be supported with a single segmented key prefix. Use an unsegmented key in the case where there is no relationship between KV pairs in a KVS, and always create the KVS storing these KV pairs with a prefix.length of zero (0).","title":"Keys and KVSs"},{"location":"dev/bp/#cursors-and-gets","text":"Always use get operations when iteration is not required. Gets are significantly faster than cursor seeks. Where iteration is required, use cursors with a KVS storing segmented keys, and with a filter whose length is equal to or greater than the key prefix length for that KVS. Otherwise, cursor performance can be greatly reduced. Use non-transaction cursors for most applications. Transaction cursors exist to support some specialized use cases.","title":"Cursors and Gets"},{"location":"dev/bp/#transactions","text":"Use transactions when required for application correctness. Otherwise, for best performance open a KVS with transactions disabled ( transactions.enabled=false ) and use non-transaction operations.","title":"Transactions"},{"location":"dev/bp/#application-lifecycle","text":"At application startup, call hse_init() to initialize the HSE subsystem within your application. This function should be called only once. From there you can create or open a KVDB and its associated KVSs and perform KV operations. At application shutdown, close all KVSs for a KVDB before closing that KVDB. After all KVDBs are closed, call hse_fini() to completely shutdown the HSE subsystem within your application. Using a signal handler to close resources can also be helpful when trying to handle unexpected application shutdown.","title":"Application Lifecycle"},{"location":"dev/concepts/","text":"Concepts The following describes HSE concepts that are important to understand for developing HSE applications and making effective use of the HSE API. KVDB and KVS HSE provides functions to create and access a key-value database (KVDB). A KVDB comprises one or more named key-value stores (KVS), each of which is an independent collection of key-value (KV) pairs. A KVS is analogous to a table in a relational database. HSE provides the standard KV operators for managing KV pairs stored in a KVS: put, get, and delete. HSE also provides transactions, cursors, prefix deletes, and other advanced features. The HSE data model enables each KVS in a KVDB to be optimized for how the KV pairs it stores will be accessed. Data Model Understanding the HSE data model is fundamental to achieving maximum application performance. Adhering to the best practices of this data model can result in significantly greater performance than might be achieved otherwise. While this data model is simple, it has proven very effective. Key Structure To describe the HSE data model, we define the following terms. key \u2014 a byte string used to uniquely identify a value for storage, retrieval, and deletion in a KVS segmented key \u2014 a key that is logically divided into N segments, N >= 2 , arranged to group related KV pairs when keys are sorted lexicographically unsegmented key \u2014 a key not logically divided into segments For segmented keys, we further define the following. key prefix \u2014 the first K segments, 1 <= K < N , that group related KV pairs when keys are sorted lexicographically key prefix length \u2014 the length of a key prefix in bytes KVS Configuration In the common case where related sets of KV pairs are accessed together, best performance is generally achieved by: defining a segmented key with a key prefix such that KV pairs to be accessed together are grouped (contiguous) when keys are sorted lexicographically, and creating a KVS to store these KV pairs with a key prefix length parameter ( prefix.length ) equal to the key prefix length of the segmented key. In the case where there is no relationship between KV pairs, best performance is generally achieved by: defining an unsegmented key, and creating a KVS to store these KV pairs with a key prefix length parameter ( prefix.length ) of zero (0). Keep in mind that a KVDB may contain multiple KVSs. So in the case where there are multiple collections of KV pairs, each collection can be stored in a different KVS with a key structure, and corresponding KVS prefix.length parameter, that is appropriate for that collection. This is a powerful capability that enables HSE to optimize storage and access for all KV pairs in a KVDB without compromise. Operation Support HSE provides several advanced operations with features that directly support the HSE data model. These operations are described in detail later, but we briefly discuss how they support the data model here. Cursors are used to iterate over keys in a KVS in forward or reverse lexicographic order. Cursors support an optional filter , which is a byte string limiting a cursor's view to only those keys whose initial bytes match the filter. The primary use for cursors is with a KVS storing segmented keys, where the length of the specified filter is equal to or greater than the key prefix length for that KVS. Used this way, cursors provide efficient iteration over sets of related KV pairs. Prefix deletes are used to atomically remove all KV pairs in a KVS with keys whose initial bytes match a specified filter. The length of the filter must be equal to the prefix.length parameter of the KVS. The primary use for prefix deletes is with a KVS storing segmented keys. This is a powerful capability that enables sets of related KV pairs to be deleted from a KVS in a single operation without cursor iteration. Transactions are used to execute a sequence of KV operations atomically. Transactions support operating on KV pairs in one or more KVSs in a KVDB. This allows storing multiple collections of KV pairs in different KVSs to optimize access, without giving up the ability to operate on any of those KV pairs within the context of a single transaction. Modeling Examples Below we present examples of applying the HSE data model to the real-world problem of storing and analyzing machine-generated data. Specifically, log data captured from datacenter servers. System logs are commonly retrieved from datacenter servers on a periodic basis and stored for both real-time and historical analysis. We examine several ways this data might be modeled, depending on how it will be accessed and managed. Simple Log Storage We start with a simple data model for storing log data in a KVDB. This model uses a single KVS with segmented keys as defined below, and values which are individual log records. Key offset Segment Length (bytes) Segment Name Description 0 8 sysID System identifier 8 8 ts Timestamp 16 2 typeID Log type identifier In this and later examples, segment names are for convenience of presentation (they do not exist in the HSE API), and segment lengths are representative. Also, partial or complete keys may be represented as tuples using segment names. For example, (sysId) , (sysID, ts) , or (sysID, ts, typeID) . We define the key prefix to be (sysID) , yielding a key prefix length of 8 bytes. Hence, we would create a KVS for storing these KV pairs with a key prefix length parameter ( prefix.length ) of 8 bytes. With this data model and KVS configuration, a cursor with the filter (sysID) can be used to efficiently iterate over the log records associated with the system sysID . Furthermore, the cursor can be used to efficiently seek to the first key (in the cursor's view) that is lexicographically equal to or greater than a (sysID, ts) , and then iterate from there. This data model makes it easy and efficient to search the log records associated with system sysID over an arbitrary time span. However, pruning those log records, for example to retain only those from the past 30 days, requires iterating over all older records and deleting them individually. Next we will look at enhancing this data model to make log record maintenance more efficient. Per-System Epoch-based Log Storage We extend the simple data model from above to include an epoch identifier representing a well-defined time interval. For example, an epoch might be four hours in length, with 6 epochs per day, 42 epochs per week, and so forth. We assume that a log record's timestamp can be mapped to a specific epoch through simple computation. We again use a single KVS but with segmented keys as defined below, and values which are individual log records. Key offset Segment Length (bytes) Segment Name Description 0 8 sysID System identifier 8 8 epochID Epoch identifier 16 8 ts Timestamp 24 2 typeID Log type identifier We define the key prefix to be (sysID, epochID) , yielding a key prefix length of 16 bytes. Hence, we would create a KVS for storing these KV pairs with a key prefix length parameter ( prefix.length ) of 16 bytes. With this data model and KVS configuration, a cursor with the filter (sysID, epochID) can be used to efficiently iterate over the log records associated with the system sysID within the epoch epochID . Furthermore, the cursor can be used to efficiently seek to the first key (in the cursor's view) that is lexicographically equal to or greater than (sysID, epochID, ts) , and then iterate from there within the epoch. With this revised data model, it is still easy and efficient to search the log records associated with system sysID over an arbitrary time span, though it is necessary to configure a cursor to iterate over each epoch of interest (e.g., to cross epoch boundaries). However, we can now prune log records very efficiently by using a single prefix delete to remove all KV pairs with a specified key prefix of (sysID, epochID) . Next we examine a variation on this per-system epoch-based data model. All-Systems Epoch-based Log Storage The previous data model makes it easy and efficient to iterate over the log records associated with a given sysID for a specified epochID . However, to view records from multiple systems for a specified epochID requires a cursor iteration per sysID of interest. We can instead group the log records for all systems within an epoch by using a KVS with segmented keys as defined below, and values which are individual log records. Key offset Segment Length (bytes) Segment Name Description 0 8 epochID Epoch identifier 8 8 ts Timestamp 16 8 sysID System identifier 24 2 typeID Log type identifier We define the key prefix to be (epochID) , yielding a key prefix length of 8 bytes. Hence we would create a KVS for storing these KV pairs with a key prefix length parameter ( prefix.length ) of 8 bytes. With this data model and KVS configuration, a cursor with the filter (epochID) can be used to efficiently iterate over the log records for all systems within the epoch epochID in timestamp order. Furthermore, the cursor can be used to efficiently seek to the first key (in the cursor's view) that is lexicographically equal to or greater than (epochID, ts) , and then iterate from there within the epoch. It should be clear that there is some loss of efficiency, versus the prior data model, to obtain all the log records associated with a specified sysID over an arbitrary time span, because records associated with systems other than sysID will be in the cursor's view and must be skipped. However, this is still a reasonably efficient query because it meets the criteria that the length of the cursor filter be equal to or greater than the key prefix length to achieve maximum performance. With this revised data model, pruning log records remains efficient because we can still use a single prefix delete to remove all KV pairs with a specified key prefix of (epochID) . In this case, the records for all systems in the epoch are pruned together. Tip This particular data model provides the opportunity to point out another best practice that can result in significantly greater performance. For a KVS storing segmented keys, it is important that the key prefix specified in put operations takes on a modest number of different values over a consecutive sequence of puts. For this example, that means choosing an epoch that is relatively short versus what one might select with the prior data model. Finally, we will examine an index-based data model for log storage. Index-based Log Storage The prior data models for log storage have the benefit of simplicity in that the KVDB has only a single KVS. However, they may provide less flexibility than required by the application. In this next example, we demonstrate how to use multiple KVSs to effectively index log records. For brevity, we define the key structure for each KVS using the tuple syntax, segment names, and segment lengths adopted in prior examples. KVS Name Key Type Key Key Prefix KVS prefix.length Value logRec segmented (epochID, ts, sysID, typeID) (epochID) 8 Log record content sysIdx segmented (sysID, epochID, ts, typeID) (sysID, epochID) 16 The KVS logRec stores the content of all log records, with each log record uniquely identified by the segmented key (epochID, ts, sysID, typeID) with key prefix (epochID) . Hence we would create KVS logRec with a key prefix length parameter ( prefix.length ) of 8 bytes. The KVS sysIdx is an index for the log records stored in KVS logRec , with a key pefix of (sysID, epochID) . Hence we would create KVS sysIdx with a key prefix length parameter ( prefix.length ) of 16 bytes. Using KVS logRec , a cursor with the filter (epochID) can be used to efficiently iterate over the log records for all systems within the epoch epochID in timestamp order. Furthermore, the cursor can be used to efficiently seek to the first key (in the cursor's view) that is lexicographically equal to or greater than (epochID, ts) , and then iterate from there within the epoch. Using KVS sysIdx , a cursor with the filter (sysID, epochID) can be used to efficiently iterate over the log records associated with the system sysID within the epoch epochID . Furthermore, the cursor can be used to efficiently seek to the first key (in the cursor's view) that is lexicographically equal to or greater than (sysID, epochID, ts) , and then iterate from there within the epoch. Note that KVS sysIdx does not contain any log record contents, and in fact stores no values at all (i.e., all value lengths are zero). To obtain the contents of a specific log record, there is the added step of a get operation in KVS logRec with key (epochID, ts, sysID, typeID) . The above schema accomplishes the following. Efficient iteration over the log records from all systems in a specified epoch using a cursor with KVS logRec . Efficient iteration over the log records from a specific system in a specified epoch using a cursor with KVS sysIdx . No duplication of log record content. A transaction can be used to atomically put (insert) KV pairs for a given log record in KVS logRec and KVS sysIdx . This guarantees integrity of the sysIdx index. Pruning log records is a bit more complex than the prior data models, bit still relatively straight-forward. To delete all log records for a given epochID , where the epoch is assumed to have passed, you would use a cursor with filter (epochID) to iterate over KVS logRec to build a list of all sysID in the epoch, and then in a single transaction, prefix delete each key prefix (sysID, epochID) from KVS sysIdx , and prefix delete the key prefix (epochID) from KVS logRec . Snapshots HSE uses multiversion concurrency control ( MVCC ) techniques to implement industry-standard snapshot isolation semantics for transactions and cursors. In this model, transactions and cursors operate on KVS snapshots in a KVDB. Conceptually, a KVS snapshot contains KV pairs from all transactions committed, or non-transaction operations completed, at the time the KVS snapshot is taken. A KVS snapshot is ephemeral and ceases to exist when all associated transaction and cursor operations complete. Transactions Transactions are used to execute a sequence of KV operations as a unit of work that is atomic, consistent, isolated, and durable ( ACID ). A transaction may operate on KV pairs in one or more KVSs in a KVDB. When a KVS is opened, the transactions.enabled parameter specifies whether or not that KVS supports transactions. This is not a persistent setting in that the KVS may be closed and later reopened in a different mode. The following table specifies the operations that may be performed on a KVS opened with transactions enabled or disabled, where: Read is a query operation, such as get or cursor iteration Update is a mutation operation, such as put, delete, or prefix delete KVS Transactions Enabled KVS Transactions Disabled Transaction Read Transaction Update Non-transaction Read Non-transaction Update Conceptually, when a transaction is initiated an instantaneous snapshot is taken of all KVSs in the specified KVDB for which transactions are enabled. The transaction may then be used to read or update KV pairs in these KVS snapshots. Snapshot isolation is enforced by failing update operations in a transaction that collide with updates in concurrent transactions, after which the transaction may be aborted and retried. In rare cases, the collision detection mechanism may produce false positives. HSE implements asynchronous (non-durable) transaction commits. Committed transactions are made durable via one of several durability controls . Cursors Cursors are used to iterate over keys in a KVS snapshot. A cursor can iterate over keys in forward or reverse lexicographic order. Cursors support an optional filter , which is a byte string limiting a cursor's view to only those keys in a KVS snapshot whose initial bytes match the filter. Tip Cursors deliver significantly greater performance when used with a KVS storing segmented keys, and where a filter is specified with a length equal to or greater than the key prefix length for that KVS. To the degree practical, you should structure applications to avoid using cursors outside of this use case. Furthermore, you should always use get operations instead of cursor seeks when iteration is not required. A cursor can be used to seek to the first key in the cursor's view that is lexicographically equal to or greater than a specified key. The interaction of cursor filters and seek is best described by example. Consider a KVS storing the following keys, which are listed in lexicographic order: \"ab001\", \"af001\", \"af002\", \"ap001\". If a cursor is created for the KVS with a filter of \"af\", then the cursor's view is limited to the keys: \"af001\", \"af002\". If that cursor is then used to seek to the key \"ab\", it will be positioned at the first key in its view equal to or greater than \"ab\", which is \"af001\". Iterating (reading) with the cursor will return the key \"af001\", then \"af002\", and then the EOF condition indicating there are no more keys in view. If instead the cursor is used to seek to the key \"ap\", it will be positioned past the last key in its view, such that an attempt to iterate (read) with the cursor will indicate an EOF condition. There are two types of cursors: non-transaction and transaction. A non-transaction cursor iterates over a KVS snapshot that is taken at the time the cursor is created. However, the cursor's view may be explicitly updated to the latest snapshot of the KVS at any time. A non-transaction cursor can be created for a KVS independent of whether the KVS was opened with transactions enabled or disabled. A transaction cursor iterates over a KVS snapshot associated with an active transaction, including any updates made in that transaction. If the transaction commits or aborts before the cursor is destroyed, the cursor's view reverts to the KVS snapshot taken at the time the transaction first became active. I.e., updates made in the transaction are no longer in the cursor's view. By definition a transaction cursor can only be created for a KVS opened with transactions enabled. A transaction cursor's view cannot be explicitly updated. Durability Controls HSE provides the hse_kvdb_sync() API call to flush cached KVDB updates to stable storage, either synchronously or asynchronously. All cached updates are flushed, whether from non-transaction operations or committed transactions. In the normal case where journaling is enabled ( durability.enabled ), cached updates are written to the journal on stable storage. Otherwise, cached updates are written directly to a KVDB media class on stable storage. HSE also supports automatically flushing cached KVDB updates to the journal on stable storage. The frequency for automatically flushing cached updates is controlled by the durability interval ( durability.interval_ms ) configured for a KVDB. Multithreading HSE supports highly-concurrent multithreaded applications, and most functions in the HSE API are thread-safe. However, there are a few exceptions, as documented in the API reference . Delete Semantics Delete operations logically remove KV pairs from a KVS. However, HSE implements physical removal as a background operation, and hence capacity is not freed immediately.","title":"Concepts"},{"location":"dev/concepts/#concepts","text":"The following describes HSE concepts that are important to understand for developing HSE applications and making effective use of the HSE API.","title":"Concepts"},{"location":"dev/concepts/#kvdb-and-kvs","text":"HSE provides functions to create and access a key-value database (KVDB). A KVDB comprises one or more named key-value stores (KVS), each of which is an independent collection of key-value (KV) pairs. A KVS is analogous to a table in a relational database. HSE provides the standard KV operators for managing KV pairs stored in a KVS: put, get, and delete. HSE also provides transactions, cursors, prefix deletes, and other advanced features. The HSE data model enables each KVS in a KVDB to be optimized for how the KV pairs it stores will be accessed.","title":"KVDB and KVS"},{"location":"dev/concepts/#data-model","text":"Understanding the HSE data model is fundamental to achieving maximum application performance. Adhering to the best practices of this data model can result in significantly greater performance than might be achieved otherwise. While this data model is simple, it has proven very effective.","title":"Data Model"},{"location":"dev/concepts/#key-structure","text":"To describe the HSE data model, we define the following terms. key \u2014 a byte string used to uniquely identify a value for storage, retrieval, and deletion in a KVS segmented key \u2014 a key that is logically divided into N segments, N >= 2 , arranged to group related KV pairs when keys are sorted lexicographically unsegmented key \u2014 a key not logically divided into segments For segmented keys, we further define the following. key prefix \u2014 the first K segments, 1 <= K < N , that group related KV pairs when keys are sorted lexicographically key prefix length \u2014 the length of a key prefix in bytes","title":"Key Structure"},{"location":"dev/concepts/#kvs-configuration","text":"In the common case where related sets of KV pairs are accessed together, best performance is generally achieved by: defining a segmented key with a key prefix such that KV pairs to be accessed together are grouped (contiguous) when keys are sorted lexicographically, and creating a KVS to store these KV pairs with a key prefix length parameter ( prefix.length ) equal to the key prefix length of the segmented key. In the case where there is no relationship between KV pairs, best performance is generally achieved by: defining an unsegmented key, and creating a KVS to store these KV pairs with a key prefix length parameter ( prefix.length ) of zero (0). Keep in mind that a KVDB may contain multiple KVSs. So in the case where there are multiple collections of KV pairs, each collection can be stored in a different KVS with a key structure, and corresponding KVS prefix.length parameter, that is appropriate for that collection. This is a powerful capability that enables HSE to optimize storage and access for all KV pairs in a KVDB without compromise.","title":"KVS Configuration"},{"location":"dev/concepts/#operation-support","text":"HSE provides several advanced operations with features that directly support the HSE data model. These operations are described in detail later, but we briefly discuss how they support the data model here. Cursors are used to iterate over keys in a KVS in forward or reverse lexicographic order. Cursors support an optional filter , which is a byte string limiting a cursor's view to only those keys whose initial bytes match the filter. The primary use for cursors is with a KVS storing segmented keys, where the length of the specified filter is equal to or greater than the key prefix length for that KVS. Used this way, cursors provide efficient iteration over sets of related KV pairs. Prefix deletes are used to atomically remove all KV pairs in a KVS with keys whose initial bytes match a specified filter. The length of the filter must be equal to the prefix.length parameter of the KVS. The primary use for prefix deletes is with a KVS storing segmented keys. This is a powerful capability that enables sets of related KV pairs to be deleted from a KVS in a single operation without cursor iteration. Transactions are used to execute a sequence of KV operations atomically. Transactions support operating on KV pairs in one or more KVSs in a KVDB. This allows storing multiple collections of KV pairs in different KVSs to optimize access, without giving up the ability to operate on any of those KV pairs within the context of a single transaction.","title":"Operation Support"},{"location":"dev/concepts/#modeling-examples","text":"Below we present examples of applying the HSE data model to the real-world problem of storing and analyzing machine-generated data. Specifically, log data captured from datacenter servers. System logs are commonly retrieved from datacenter servers on a periodic basis and stored for both real-time and historical analysis. We examine several ways this data might be modeled, depending on how it will be accessed and managed.","title":"Modeling Examples"},{"location":"dev/concepts/#simple-log-storage","text":"We start with a simple data model for storing log data in a KVDB. This model uses a single KVS with segmented keys as defined below, and values which are individual log records. Key offset Segment Length (bytes) Segment Name Description 0 8 sysID System identifier 8 8 ts Timestamp 16 2 typeID Log type identifier In this and later examples, segment names are for convenience of presentation (they do not exist in the HSE API), and segment lengths are representative. Also, partial or complete keys may be represented as tuples using segment names. For example, (sysId) , (sysID, ts) , or (sysID, ts, typeID) . We define the key prefix to be (sysID) , yielding a key prefix length of 8 bytes. Hence, we would create a KVS for storing these KV pairs with a key prefix length parameter ( prefix.length ) of 8 bytes. With this data model and KVS configuration, a cursor with the filter (sysID) can be used to efficiently iterate over the log records associated with the system sysID . Furthermore, the cursor can be used to efficiently seek to the first key (in the cursor's view) that is lexicographically equal to or greater than a (sysID, ts) , and then iterate from there. This data model makes it easy and efficient to search the log records associated with system sysID over an arbitrary time span. However, pruning those log records, for example to retain only those from the past 30 days, requires iterating over all older records and deleting them individually. Next we will look at enhancing this data model to make log record maintenance more efficient.","title":"Simple Log Storage"},{"location":"dev/concepts/#per-system-epoch-based-log-storage","text":"We extend the simple data model from above to include an epoch identifier representing a well-defined time interval. For example, an epoch might be four hours in length, with 6 epochs per day, 42 epochs per week, and so forth. We assume that a log record's timestamp can be mapped to a specific epoch through simple computation. We again use a single KVS but with segmented keys as defined below, and values which are individual log records. Key offset Segment Length (bytes) Segment Name Description 0 8 sysID System identifier 8 8 epochID Epoch identifier 16 8 ts Timestamp 24 2 typeID Log type identifier We define the key prefix to be (sysID, epochID) , yielding a key prefix length of 16 bytes. Hence, we would create a KVS for storing these KV pairs with a key prefix length parameter ( prefix.length ) of 16 bytes. With this data model and KVS configuration, a cursor with the filter (sysID, epochID) can be used to efficiently iterate over the log records associated with the system sysID within the epoch epochID . Furthermore, the cursor can be used to efficiently seek to the first key (in the cursor's view) that is lexicographically equal to or greater than (sysID, epochID, ts) , and then iterate from there within the epoch. With this revised data model, it is still easy and efficient to search the log records associated with system sysID over an arbitrary time span, though it is necessary to configure a cursor to iterate over each epoch of interest (e.g., to cross epoch boundaries). However, we can now prune log records very efficiently by using a single prefix delete to remove all KV pairs with a specified key prefix of (sysID, epochID) . Next we examine a variation on this per-system epoch-based data model.","title":"Per-System Epoch-based Log Storage"},{"location":"dev/concepts/#all-systems-epoch-based-log-storage","text":"The previous data model makes it easy and efficient to iterate over the log records associated with a given sysID for a specified epochID . However, to view records from multiple systems for a specified epochID requires a cursor iteration per sysID of interest. We can instead group the log records for all systems within an epoch by using a KVS with segmented keys as defined below, and values which are individual log records. Key offset Segment Length (bytes) Segment Name Description 0 8 epochID Epoch identifier 8 8 ts Timestamp 16 8 sysID System identifier 24 2 typeID Log type identifier We define the key prefix to be (epochID) , yielding a key prefix length of 8 bytes. Hence we would create a KVS for storing these KV pairs with a key prefix length parameter ( prefix.length ) of 8 bytes. With this data model and KVS configuration, a cursor with the filter (epochID) can be used to efficiently iterate over the log records for all systems within the epoch epochID in timestamp order. Furthermore, the cursor can be used to efficiently seek to the first key (in the cursor's view) that is lexicographically equal to or greater than (epochID, ts) , and then iterate from there within the epoch. It should be clear that there is some loss of efficiency, versus the prior data model, to obtain all the log records associated with a specified sysID over an arbitrary time span, because records associated with systems other than sysID will be in the cursor's view and must be skipped. However, this is still a reasonably efficient query because it meets the criteria that the length of the cursor filter be equal to or greater than the key prefix length to achieve maximum performance. With this revised data model, pruning log records remains efficient because we can still use a single prefix delete to remove all KV pairs with a specified key prefix of (epochID) . In this case, the records for all systems in the epoch are pruned together. Tip This particular data model provides the opportunity to point out another best practice that can result in significantly greater performance. For a KVS storing segmented keys, it is important that the key prefix specified in put operations takes on a modest number of different values over a consecutive sequence of puts. For this example, that means choosing an epoch that is relatively short versus what one might select with the prior data model. Finally, we will examine an index-based data model for log storage.","title":"All-Systems Epoch-based Log Storage"},{"location":"dev/concepts/#index-based-log-storage","text":"The prior data models for log storage have the benefit of simplicity in that the KVDB has only a single KVS. However, they may provide less flexibility than required by the application. In this next example, we demonstrate how to use multiple KVSs to effectively index log records. For brevity, we define the key structure for each KVS using the tuple syntax, segment names, and segment lengths adopted in prior examples. KVS Name Key Type Key Key Prefix KVS prefix.length Value logRec segmented (epochID, ts, sysID, typeID) (epochID) 8 Log record content sysIdx segmented (sysID, epochID, ts, typeID) (sysID, epochID) 16 The KVS logRec stores the content of all log records, with each log record uniquely identified by the segmented key (epochID, ts, sysID, typeID) with key prefix (epochID) . Hence we would create KVS logRec with a key prefix length parameter ( prefix.length ) of 8 bytes. The KVS sysIdx is an index for the log records stored in KVS logRec , with a key pefix of (sysID, epochID) . Hence we would create KVS sysIdx with a key prefix length parameter ( prefix.length ) of 16 bytes. Using KVS logRec , a cursor with the filter (epochID) can be used to efficiently iterate over the log records for all systems within the epoch epochID in timestamp order. Furthermore, the cursor can be used to efficiently seek to the first key (in the cursor's view) that is lexicographically equal to or greater than (epochID, ts) , and then iterate from there within the epoch. Using KVS sysIdx , a cursor with the filter (sysID, epochID) can be used to efficiently iterate over the log records associated with the system sysID within the epoch epochID . Furthermore, the cursor can be used to efficiently seek to the first key (in the cursor's view) that is lexicographically equal to or greater than (sysID, epochID, ts) , and then iterate from there within the epoch. Note that KVS sysIdx does not contain any log record contents, and in fact stores no values at all (i.e., all value lengths are zero). To obtain the contents of a specific log record, there is the added step of a get operation in KVS logRec with key (epochID, ts, sysID, typeID) . The above schema accomplishes the following. Efficient iteration over the log records from all systems in a specified epoch using a cursor with KVS logRec . Efficient iteration over the log records from a specific system in a specified epoch using a cursor with KVS sysIdx . No duplication of log record content. A transaction can be used to atomically put (insert) KV pairs for a given log record in KVS logRec and KVS sysIdx . This guarantees integrity of the sysIdx index. Pruning log records is a bit more complex than the prior data models, bit still relatively straight-forward. To delete all log records for a given epochID , where the epoch is assumed to have passed, you would use a cursor with filter (epochID) to iterate over KVS logRec to build a list of all sysID in the epoch, and then in a single transaction, prefix delete each key prefix (sysID, epochID) from KVS sysIdx , and prefix delete the key prefix (epochID) from KVS logRec .","title":"Index-based Log Storage"},{"location":"dev/concepts/#snapshots","text":"HSE uses multiversion concurrency control ( MVCC ) techniques to implement industry-standard snapshot isolation semantics for transactions and cursors. In this model, transactions and cursors operate on KVS snapshots in a KVDB. Conceptually, a KVS snapshot contains KV pairs from all transactions committed, or non-transaction operations completed, at the time the KVS snapshot is taken. A KVS snapshot is ephemeral and ceases to exist when all associated transaction and cursor operations complete.","title":"Snapshots"},{"location":"dev/concepts/#transactions","text":"Transactions are used to execute a sequence of KV operations as a unit of work that is atomic, consistent, isolated, and durable ( ACID ). A transaction may operate on KV pairs in one or more KVSs in a KVDB. When a KVS is opened, the transactions.enabled parameter specifies whether or not that KVS supports transactions. This is not a persistent setting in that the KVS may be closed and later reopened in a different mode. The following table specifies the operations that may be performed on a KVS opened with transactions enabled or disabled, where: Read is a query operation, such as get or cursor iteration Update is a mutation operation, such as put, delete, or prefix delete KVS Transactions Enabled KVS Transactions Disabled Transaction Read Transaction Update Non-transaction Read Non-transaction Update Conceptually, when a transaction is initiated an instantaneous snapshot is taken of all KVSs in the specified KVDB for which transactions are enabled. The transaction may then be used to read or update KV pairs in these KVS snapshots. Snapshot isolation is enforced by failing update operations in a transaction that collide with updates in concurrent transactions, after which the transaction may be aborted and retried. In rare cases, the collision detection mechanism may produce false positives. HSE implements asynchronous (non-durable) transaction commits. Committed transactions are made durable via one of several durability controls .","title":"Transactions"},{"location":"dev/concepts/#cursors","text":"Cursors are used to iterate over keys in a KVS snapshot. A cursor can iterate over keys in forward or reverse lexicographic order. Cursors support an optional filter , which is a byte string limiting a cursor's view to only those keys in a KVS snapshot whose initial bytes match the filter. Tip Cursors deliver significantly greater performance when used with a KVS storing segmented keys, and where a filter is specified with a length equal to or greater than the key prefix length for that KVS. To the degree practical, you should structure applications to avoid using cursors outside of this use case. Furthermore, you should always use get operations instead of cursor seeks when iteration is not required. A cursor can be used to seek to the first key in the cursor's view that is lexicographically equal to or greater than a specified key. The interaction of cursor filters and seek is best described by example. Consider a KVS storing the following keys, which are listed in lexicographic order: \"ab001\", \"af001\", \"af002\", \"ap001\". If a cursor is created for the KVS with a filter of \"af\", then the cursor's view is limited to the keys: \"af001\", \"af002\". If that cursor is then used to seek to the key \"ab\", it will be positioned at the first key in its view equal to or greater than \"ab\", which is \"af001\". Iterating (reading) with the cursor will return the key \"af001\", then \"af002\", and then the EOF condition indicating there are no more keys in view. If instead the cursor is used to seek to the key \"ap\", it will be positioned past the last key in its view, such that an attempt to iterate (read) with the cursor will indicate an EOF condition. There are two types of cursors: non-transaction and transaction. A non-transaction cursor iterates over a KVS snapshot that is taken at the time the cursor is created. However, the cursor's view may be explicitly updated to the latest snapshot of the KVS at any time. A non-transaction cursor can be created for a KVS independent of whether the KVS was opened with transactions enabled or disabled. A transaction cursor iterates over a KVS snapshot associated with an active transaction, including any updates made in that transaction. If the transaction commits or aborts before the cursor is destroyed, the cursor's view reverts to the KVS snapshot taken at the time the transaction first became active. I.e., updates made in the transaction are no longer in the cursor's view. By definition a transaction cursor can only be created for a KVS opened with transactions enabled. A transaction cursor's view cannot be explicitly updated.","title":"Cursors"},{"location":"dev/concepts/#durability-controls","text":"HSE provides the hse_kvdb_sync() API call to flush cached KVDB updates to stable storage, either synchronously or asynchronously. All cached updates are flushed, whether from non-transaction operations or committed transactions. In the normal case where journaling is enabled ( durability.enabled ), cached updates are written to the journal on stable storage. Otherwise, cached updates are written directly to a KVDB media class on stable storage. HSE also supports automatically flushing cached KVDB updates to the journal on stable storage. The frequency for automatically flushing cached updates is controlled by the durability interval ( durability.interval_ms ) configured for a KVDB.","title":"Durability Controls"},{"location":"dev/concepts/#multithreading","text":"HSE supports highly-concurrent multithreaded applications, and most functions in the HSE API are thread-safe. However, there are a few exceptions, as documented in the API reference .","title":"Multithreading"},{"location":"dev/concepts/#delete-semantics","text":"Delete operations logically remove KV pairs from a KVS. However, HSE implements physical removal as a background operation, and hence capacity is not freed immediately.","title":"Delete Semantics"},{"location":"dev/limits/","text":"Limits The tables below provide guidance on HSE operating limits. A few are enforced, but most are based on testing and experience. The limits appropriate for a specific HSE application are largely dependent on the performance requirements of that application, and the hardware it runs on. Feel free to push these limits in testing and let us know how far you get and what you observe. KVDB Limits Entity Description Limit Enforced KVDB count Active KVDB per system 8 No KVS count KVSs in a KVDB 16 No Key count Total keys in a KVDB (billions) 200 No Capacity Total storage capacity of a KVDB (TB) 12 No Transaction count Concurrent transactions in a KVDB 1,000 per CPU Yes Cursor count Concurrent cursors in a KVDB 10,000 No Info An application can only have a single KVDB open at a time. We expect to remove this limitation in a later release. KVS Limits Entity Description Limit Enforced Key size Range of valid key sizes (bytes) 1 \u2013 1,334 Yes Value size Range of valid value sizes (bytes) 0 \u2013 1MiB Yes Key count Total keys in a KVS (billions) 50 No Capacity Total storage capacity of a KVS (TB) 4 No Cursor count Concurrent cursors in a KVS 8,000 No","title":"Limits"},{"location":"dev/limits/#limits","text":"The tables below provide guidance on HSE operating limits. A few are enforced, but most are based on testing and experience. The limits appropriate for a specific HSE application are largely dependent on the performance requirements of that application, and the hardware it runs on. Feel free to push these limits in testing and let us know how far you get and what you observe.","title":"Limits"},{"location":"dev/limits/#kvdb-limits","text":"Entity Description Limit Enforced KVDB count Active KVDB per system 8 No KVS count KVSs in a KVDB 16 No Key count Total keys in a KVDB (billions) 200 No Capacity Total storage capacity of a KVDB (TB) 12 No Transaction count Concurrent transactions in a KVDB 1,000 per CPU Yes Cursor count Concurrent cursors in a KVDB 10,000 No Info An application can only have a single KVDB open at a time. We expect to remove this limitation in a later release.","title":"KVDB Limits"},{"location":"dev/limits/#kvs-limits","text":"Entity Description Limit Enforced Key size Range of valid key sizes (bytes) 1 \u2013 1,334 Yes Value size Range of valid value sizes (bytes) 0 \u2013 1MiB Yes Key count Total keys in a KVS (billions) 50 No Capacity Total storage capacity of a KVS (TB) 4 No Cursor count Concurrent cursors in a KVS 8,000 No","title":"KVS Limits"},{"location":"gs/about/","text":"About HSE is a fast embeddable key-value store designed for SSDs and persistent memory. It is implemented as a C library that links with your application, directly or via alternate language bindings. Overview HSE provides functions to create and access a key-value database (KVDB). A KVDB comprises one or more named key-value stores (KVSs), each of which is an independent collection of key-value pairs. A KVS is analogous to a table in a relational database. The HSE data model enables each KVS in a KVDB to be optimized for how the key-value pairs it stores will be accessed. HSE provides the standard operators for managing key-value pairs in a KVS: put, get, and delete. HSE also provides transactions, cursors, prefix deletes, and other advanced features. Details on the HSE programming and data models can be found here . Details on how KVDB data is stored in file systems can be found here . Project Repos The HSE project includes the following repos: hse contains the HSE library source hse-python contains HSE Python bindings hse-mongo is a fork that integrates HSE with MongoDB hse-ycsb is a fork that integrates HSE with the YCSB benchmark rfcs contains RFCs for major enhancements to the HSE library or other project components hse-project.github.io contains the source for this documentation Instructions for building, installing, and contributing to repo contents are in their local README.md and CONTRIBUTING.md files. Forked repos, such as hse-mongo and hse-ycsb , contain this information in README.md and CONTRIBUTING.md files in the hse directory within those repos. To make these easy to locate, there are symlinks to them named README_HSE.md and CONTRIBUTING_HSE.md in the repo root directory. Using HSE After building and installing the hse repo, you can develop HSE applications in C/C++ by including the hse.h header file and linking with libhse-2 . Information on using an alternate HSE language binding is included in its associated repo. Releases See the release section of each HSE project repo for specific releases and associated release notes. For example, hse releases can be found here . Releases of the HSE library and associated language bindings use semantic versioning . Releases of forked repos use a versioning scheme that is documented in their associated README.md .","title":"About"},{"location":"gs/about/#about","text":"HSE is a fast embeddable key-value store designed for SSDs and persistent memory. It is implemented as a C library that links with your application, directly or via alternate language bindings.","title":"About"},{"location":"gs/about/#overview","text":"HSE provides functions to create and access a key-value database (KVDB). A KVDB comprises one or more named key-value stores (KVSs), each of which is an independent collection of key-value pairs. A KVS is analogous to a table in a relational database. The HSE data model enables each KVS in a KVDB to be optimized for how the key-value pairs it stores will be accessed. HSE provides the standard operators for managing key-value pairs in a KVS: put, get, and delete. HSE also provides transactions, cursors, prefix deletes, and other advanced features. Details on the HSE programming and data models can be found here . Details on how KVDB data is stored in file systems can be found here .","title":"Overview"},{"location":"gs/about/#project-repos","text":"The HSE project includes the following repos: hse contains the HSE library source hse-python contains HSE Python bindings hse-mongo is a fork that integrates HSE with MongoDB hse-ycsb is a fork that integrates HSE with the YCSB benchmark rfcs contains RFCs for major enhancements to the HSE library or other project components hse-project.github.io contains the source for this documentation Instructions for building, installing, and contributing to repo contents are in their local README.md and CONTRIBUTING.md files. Forked repos, such as hse-mongo and hse-ycsb , contain this information in README.md and CONTRIBUTING.md files in the hse directory within those repos. To make these easy to locate, there are symlinks to them named README_HSE.md and CONTRIBUTING_HSE.md in the repo root directory.","title":"Project Repos"},{"location":"gs/about/#using-hse","text":"After building and installing the hse repo, you can develop HSE applications in C/C++ by including the hse.h header file and linking with libhse-2 . Information on using an alternate HSE language binding is included in its associated repo.","title":"Using HSE"},{"location":"gs/about/#releases","text":"See the release section of each HSE project repo for specific releases and associated release notes. For example, hse releases can be found here . Releases of the HSE library and associated language bindings use semantic versioning . Releases of forked repos use a versioning scheme that is documented in their associated README.md .","title":"Releases"},{"location":"gs/cli/","text":"Command Line Interface Applications will normally use the HSE API to create and manage a KVDB. However, the HSE command line interface (CLI) can also be used for these tasks. The CLI is itself an HSE application. Below are several usage examples which assume the following. /var/bulk is a file system created on block storage suitable for a capacity media class /var/fast is a file system created on block storage suitable for a staging media class /var/pmem is a DAX-enabled file system created on persistent memory See the discussion on KVDB storage for more details on media classes and home directories. Create a KVDB Create a KVDB with its home directory in /var/bulk taking all the defaults. mkdir /var/bulk/kvdb1 hse kvdb create /var/bulk/kvdb1 The KVDB home directory is /var/bulk/kvdb1 and, because it resides on block storage, by default a capacity media class is created at /var/bulk/kvdb1/capacity . Next, create a KVDB with its home directory in /var/bulk specifying parameters for both capacity and staging media class directories. mkdir /var/bulk/kvdb2 mkdir /var/bulk/capacity2 mkdir /var/fast/staging2 hse kvdb create /var/bulk/kvdb2 storage.capacity.path = ../capacity2 storage.staging.path = /var/fast/staging2 The KVDB home directory is /var/bulk/kvdb2 and the capacity and staging media classes are created at /var/bulk/capacity2 and /var/fast/staging2 , respectively. Media class directory paths can be relative to the KVDB home directory or absolute, as in this example for the capacity and staging media class directories, respectively. Finally, create a KVDB with its home directory in /var/pmem taking all the defaults. mkdir /var/pmem/kvdb3 hse kvdb create /var/pmem/kvdb3 The KVDB home directory is /var/pmem/kvdb3 and, because it resides on persistent memory, by default a pmem media class is created at /var/pmem/kvdb3/pmem . Create a KVS Create a KVS in a KVDB taking all the defaults. hse kvs create /var/bulk/kvdb1 kvs1 The KVS named kvs1 is created in KVDB home directory /var/bulk/kvdb1 . KVS kvs1 is created with the default key prefix length ( prefix.length ) of zero (0). Next, create a KVS specifying the key prefix length. hse kvs create /var/bulk/kvdb2 kvs1 prefix.length = 8 The KVS named kvs1 is created in KVDB home directory /var/bulk/kvdb2 . KVS kvs1 is created with the specified key prefix length of 8 bytes. Get KVDB Info Get general information about a KVDB. hse kvdb info /var/bulk/kvdb1 This command displays general information for the KVDB home directory /var/bulk/kvdb1 , including its KVS list. Get KVDB Storage Info Get information about the media classes configured for a KVDB. hse storage info /var/bulk/kvdb1 This command displays media class information for the KVDB home directory /var/bulk/kvdb1 , including storage space metrics. These storage space metrics include: Total space in the file systems hosting the KVDB media classes Available space in the file systems hosting the KVDB media classes Space allocated for the KVDB Space used by the KVDB, which is always less than or equal to the allocated space Profile KVDB Storage For a KVDB configured with a capacity media class, profile the capacity storage to determine the appropriate throttling.init_policy parameter value for that KVDB. hse storage profile /var/bulk Here we specify /var/bulk as the storage path to profile because it is the file system storing the capacity media class for all KVDBs in these examples. Add a KVDB Media Class Add a media class to an existing KVDB. mkdir /var/fast/staging1 hse storage add /var/bulk/kvdb1 storage.staging.path = /var/fast/staging1 The staging media class directory /var/fast/staging1 is configured for the KVDB home directory /var/bulk/kvdb1 . The next time an application opens the KVDB, the newly added staging media class will be used for KVS storage as determined by the mclass.policy parameter for each KVS. Info This command will fail if an application has the KVDB open, or if adding the media class would result in an invalid storage configuration , for example attempting to add a staging media class to a KVDB configured with only a pmem media class. Compact a KVDB HSE implements the physical removal of logically deleted data via a background operation called compaction. Though generally not required, compaction can be initiated manually. Be aware that compaction can take several minutes or longer depending on the amount of data stored in the KVDB, among many other factors, so a timeout can be specified in seconds. hse kvdb compact --timeout 120 /var/bulk/kvdb1 The KVDB home directory is /var/bulk/kvdb1 , and compaction is started with a timeout of 120 seconds. If an application has the KVDB open, the compaction may continue past the timeout value. In this case, the status of the compaction can be queried. hse kvdb compact --status /var/bulk/kvdb1 A compaction operation can also be canceled. hse kvdb compact --cancel /var/bulk/kvdb1 Drop a KVS Drop (delete) a KVS in a KVDB. hse kvs drop /var/bulk/kvdb2 kvs1 The KVS named kvs1 is dropped from the KVDB home directory /var/bulk/kvdb2 . Drop a KVDB Drop (delete) a KVDB and all of its KVSs. hse kvdb drop /var/bulk/kvdb1 hse kvdb drop /var/bulk/kvdb2 hse kvdb drop /var/pmem/kvdb3 The KVDBs with home directories /var/bulk/kvdb1 , /var/bulk/kvdb2 , and /var/pmem/kvdb3 are dropped.","title":"Command Line Interface"},{"location":"gs/cli/#command-line-interface","text":"Applications will normally use the HSE API to create and manage a KVDB. However, the HSE command line interface (CLI) can also be used for these tasks. The CLI is itself an HSE application. Below are several usage examples which assume the following. /var/bulk is a file system created on block storage suitable for a capacity media class /var/fast is a file system created on block storage suitable for a staging media class /var/pmem is a DAX-enabled file system created on persistent memory See the discussion on KVDB storage for more details on media classes and home directories.","title":"Command Line Interface"},{"location":"gs/cli/#create-a-kvdb","text":"Create a KVDB with its home directory in /var/bulk taking all the defaults. mkdir /var/bulk/kvdb1 hse kvdb create /var/bulk/kvdb1 The KVDB home directory is /var/bulk/kvdb1 and, because it resides on block storage, by default a capacity media class is created at /var/bulk/kvdb1/capacity . Next, create a KVDB with its home directory in /var/bulk specifying parameters for both capacity and staging media class directories. mkdir /var/bulk/kvdb2 mkdir /var/bulk/capacity2 mkdir /var/fast/staging2 hse kvdb create /var/bulk/kvdb2 storage.capacity.path = ../capacity2 storage.staging.path = /var/fast/staging2 The KVDB home directory is /var/bulk/kvdb2 and the capacity and staging media classes are created at /var/bulk/capacity2 and /var/fast/staging2 , respectively. Media class directory paths can be relative to the KVDB home directory or absolute, as in this example for the capacity and staging media class directories, respectively. Finally, create a KVDB with its home directory in /var/pmem taking all the defaults. mkdir /var/pmem/kvdb3 hse kvdb create /var/pmem/kvdb3 The KVDB home directory is /var/pmem/kvdb3 and, because it resides on persistent memory, by default a pmem media class is created at /var/pmem/kvdb3/pmem .","title":"Create a KVDB"},{"location":"gs/cli/#create-a-kvs","text":"Create a KVS in a KVDB taking all the defaults. hse kvs create /var/bulk/kvdb1 kvs1 The KVS named kvs1 is created in KVDB home directory /var/bulk/kvdb1 . KVS kvs1 is created with the default key prefix length ( prefix.length ) of zero (0). Next, create a KVS specifying the key prefix length. hse kvs create /var/bulk/kvdb2 kvs1 prefix.length = 8 The KVS named kvs1 is created in KVDB home directory /var/bulk/kvdb2 . KVS kvs1 is created with the specified key prefix length of 8 bytes.","title":"Create a KVS"},{"location":"gs/cli/#get-kvdb-info","text":"Get general information about a KVDB. hse kvdb info /var/bulk/kvdb1 This command displays general information for the KVDB home directory /var/bulk/kvdb1 , including its KVS list.","title":"Get KVDB Info"},{"location":"gs/cli/#get-kvdb-storage-info","text":"Get information about the media classes configured for a KVDB. hse storage info /var/bulk/kvdb1 This command displays media class information for the KVDB home directory /var/bulk/kvdb1 , including storage space metrics. These storage space metrics include: Total space in the file systems hosting the KVDB media classes Available space in the file systems hosting the KVDB media classes Space allocated for the KVDB Space used by the KVDB, which is always less than or equal to the allocated space","title":"Get KVDB Storage Info"},{"location":"gs/cli/#profile-kvdb-storage","text":"For a KVDB configured with a capacity media class, profile the capacity storage to determine the appropriate throttling.init_policy parameter value for that KVDB. hse storage profile /var/bulk Here we specify /var/bulk as the storage path to profile because it is the file system storing the capacity media class for all KVDBs in these examples.","title":"Profile KVDB Storage"},{"location":"gs/cli/#add-a-kvdb-media-class","text":"Add a media class to an existing KVDB. mkdir /var/fast/staging1 hse storage add /var/bulk/kvdb1 storage.staging.path = /var/fast/staging1 The staging media class directory /var/fast/staging1 is configured for the KVDB home directory /var/bulk/kvdb1 . The next time an application opens the KVDB, the newly added staging media class will be used for KVS storage as determined by the mclass.policy parameter for each KVS. Info This command will fail if an application has the KVDB open, or if adding the media class would result in an invalid storage configuration , for example attempting to add a staging media class to a KVDB configured with only a pmem media class.","title":"Add a KVDB Media Class"},{"location":"gs/cli/#compact-a-kvdb","text":"HSE implements the physical removal of logically deleted data via a background operation called compaction. Though generally not required, compaction can be initiated manually. Be aware that compaction can take several minutes or longer depending on the amount of data stored in the KVDB, among many other factors, so a timeout can be specified in seconds. hse kvdb compact --timeout 120 /var/bulk/kvdb1 The KVDB home directory is /var/bulk/kvdb1 , and compaction is started with a timeout of 120 seconds. If an application has the KVDB open, the compaction may continue past the timeout value. In this case, the status of the compaction can be queried. hse kvdb compact --status /var/bulk/kvdb1 A compaction operation can also be canceled. hse kvdb compact --cancel /var/bulk/kvdb1","title":"Compact a KVDB"},{"location":"gs/cli/#drop-a-kvs","text":"Drop (delete) a KVS in a KVDB. hse kvs drop /var/bulk/kvdb2 kvs1 The KVS named kvs1 is dropped from the KVDB home directory /var/bulk/kvdb2 .","title":"Drop a KVS"},{"location":"gs/cli/#drop-a-kvdb","text":"Drop (delete) a KVDB and all of its KVSs. hse kvdb drop /var/bulk/kvdb1 hse kvdb drop /var/bulk/kvdb2 hse kvdb drop /var/pmem/kvdb3 The KVDBs with home directories /var/bulk/kvdb1 , /var/bulk/kvdb2 , and /var/pmem/kvdb3 are dropped.","title":"Drop a KVDB"},{"location":"gs/params/","text":"Configuration Parameters HSE defines global, KVDB, and KVS configuration parameters as described below. These are classified as either create-time parameters, which apply when an application creates a KVDB or KVS, or runtime parameters, which apply each time an application initializes the HSE library or opens a KVDB or KVS. In addition to the detailed descriptions below, you can find parameter usage examples in the API reference , CLI reference , and HSE sample programs . Global Parameters Global parameters are runtime parameters that apply at the application level. These parameters may be specified in the hse_init() API call or in the optional hse.conf JSON file, which is also specified in hse_init() . For hse_init() API calls, specify global parameters in the form <param>=<value> . For example, socket.enabled=false . The following global parameters are part of the stable API. Parameter Default Description logging.enabled true Logging mode (false==disabled, true==enabled) logging.structured false Logging style (false==basic, true==structured) logging.destination syslog Log destination (stdout, stderr, file, syslog) logging.path $PWD/hse.log Log file when logging.destination==file logging.level 7 Logging severity level (0==emergency; 7==debug) socket.enabled true REST interface mode (false==disabled, true==enabled) socket.path /tmp/hse-<pid>.sock UNIX domain socket file when socket.enabled==true KVDB Parameters KVDB parameters apply when a KVDB is created or opened. KVDB Create-time Parameters KVDB create-time parameters may be specified in the hse_kvdb_create() API call or when using the CLI to create a KVDB. In either case, specify KVDB create-time parameters in the form <param>=<value> . For example, storage.capacity.path=/path/to/capacity/dir . The following KVDB create-time parameters are part of the stable API. Parameter Default Description storage.capacity.path <KVDB home>/capacity Capacity media class directory storage.staging.path null Staging media class directory storage.pmem.path <KVDB home>/pmem Pmem media class directory Info Defaults for storage.capacity.path and storage.pmem.path are applied only when applicable based on the KVDB home directory storage . KVDB Runtime Parameters KVDB runtime parameters may be specified in the hse_kvdb_open() API call or in the optional kvdb.conf JSON file in the KVDB home directory, which is also specified in hse_kvdb_open() . For hse_kvdb_open() API calls, specify KVDB runtime parameters in the form <param>=<value> . For example, durability.interval_ms=1000 . The following KVDB runtime parameters are part of the stable API. Parameter Default Description read_only false Access mode (false==read/write, true==read-only) durability.enabled true Journaling mode (false==disabled, true==enabled) durability.interval_ms 100 Max time data is cached (in milliseconds) when durability.enabled==true durability.mclass auto Media class for journal (capacity, staging, pmem, auto) throttling.init_policy auto Ingest throttle at startup (light, medium, heavy, auto) Info The throttling.init_policy may also be set to default , which is an alias for heavy . This is to maintain backward compatibility with earlier releases of HSE. Durability Settings The KVDB durability parameters control how HSE journals updates for that KVDB to provide for recovery in the event of a failure. The parameter durability.enabled determines whether or not journaling is enabled. In general, you should always set this to true . As a rare exception, applications that implement their own form of durability may want to disable HSE journaling to increase performance. The parameter durability.interval_ms specifies the frequency (in milliseconds) for automatically flushing cached updates to the journal on stable storage. Increasing this value may improve performance but also increases the amount of data that may be lost in the event of a failure. The parameter durability.mclass specifies the media class for storing journal files. In general, best performance is achieved by storing the journal files on the fastest media class configured for a KVDB. If durability.mclass is set to auto , HSE selects (applies) the value pmem , or staging , or capacity , in that order, depending on the media classes configured for the KVDB. The media class value that HSE selects when auto is specified may change in future releases. See the discussion on HSE durability controls for additional details. Initial Throttle Setting On startup, HSE throttles the rate at which it processes updates in a KVDB, referred to as the ingest rate . HSE increases the ingest rate for the KVDB until it reaches the maximum sustainable value for the underlying storage. This ramp-up process can take up to 200 seconds . For benchmarks, this initial throttling can greatly distort results. In normal use, this initial throttling may impact the time before a service is fully operational. The throttling.init_policy parameter can be used to achieve the maximum ingest rate in far less time. It specifies a relative initial throttling value of light (minimum), medium , or heavy (maximum) throttling. If throttling.init_policy is set to auto , HSE selects (applies) the value heavy if the KVDB is configured with a capacity media class, or light if the KVDB is configured with only a pmem media class. The initial throttling value that HSE selects when auto is specified may change in future releases. Setting the throttling.init_policy parameter improperly for the underlying storage can cause the durability interval ( durability.interval_ms ) to be violated or internal indexing structures to become unbalanced for a period of time. For example, this may occur if throttling.init_policy is set to light with relatively slow KVDB storage. For a KVDB configured with a capacity media class, the CLI provides a command to determine the appropriate throttling.init_policy setting. You can run it as follows. hse storage profile /path/to/capacity/storage/for/the/kvdb The path specified in hse storage profile should be a directory in the file system hosting the capacity media class for the KVDB of interest. Use the output of hse storage profile to specify the throttling.init_policy value for that KVDB. For a KVDB configured with only a pmem media class, specify a throttling.init_policy value of light or auto . KVS Parameters KVS parameters apply when a KVS is created or opened. KVS Create-time Parameters KVS create-time parameters may be specified in the hse_kvdb_kvs_create() API call or when using the CLI to create a KVS. In either case, specify KVS create-time parameters in the form <param>=<value> . For example, prefix.length=8 . The following KVS create-time parameters are part of the stable API. Parameter Default Description prefix.length 0 Key prefix length (bytes) Info The KVS name default is reserved and may not be used in hse_kvdb_kvs_create() API calls or with the CLI. KVS Runtime Parameters KVS runtime parameters may be specified in the hse_kvdb_kvs_open() API call or in the optional kvdb.conf configuration file in the KVDB home directory, which is also specified in hse_kvdb_open() . For hse_kvdb_kvs_open() API calls, specify KVS runtime parameters in the form <param>=<value> . For example, compression.value.algorithm=lz4 . The following KVS runtime parameters are part of the stable API. Parameter Default Description transactions.enabled false Transaction mode (false==disabled, true==enabled) mclass.policy auto Media class usage (see discussion below for value strings) compression.value.algorithm none Value compression method (none, lz4) compression.value.min_length 12 Value length above which compression is attempted (bytes) Transaction Mode When a KVS is opened, the transactions.enabled value determines whether or not transactions are enabled for the KVS. This mode may be changed by closing and reopening the KVS. See the discussion on HSE transactions for additional details. Media Class Usage The media class usage policy for a KVS defines how the key-value data in that KVS is stored and managed in a KVDB. Key and value data in a KVS can either be pinned to a particular media class, or tiered from one media class to another as it ages. This behavior is determined by the mclass.policy setting for the KVS. The following mclass.policy settings pin key and value data: capacity_only pins all key and value data to the capacity media class staging_only pins all key and value data to the staging media class pmem_only pins all key and value data to the pmem media class The following mclass.policy settings tier key and value data: staging_max_capacity pins all key data to the staging media class and tiers all value data from staging to capacity staging_min_capacity tiers all key and value data from the staging to the capacity media class pmem_max_capacity pins all key data to the pmem media class and tiers all value data from pmem to capacity Below is a visualization of these mclass.policy settings in terms of the media classes that may contain key and value data for a KVS. mclass.policy pmem staging capacity capacity_only keys, values staging_only keys, values pmem_only keys, values staging_max_capacity keys, values values staging_min_capacity keys, values keys, values pmem_max_capacity keys, values values If mclass.policy is set to auto , HSE selects (applies) the value for the media class usage policy per the table below. The usage policy value that HSE selects when auto is specified may change in future releases. Media classes configured for the KVDB mclass.policy value selected capacity capacity_only staging, capacity staging_max_capacity pmem, staging, capacity pmem_max_capacity pmem, capacity pmem_max_capacity pmem pmem_only Configuration Files The following are the JSON file formats for the optional HSE configuration files. hse.conf JSON File See the discussion on global parameters for definitions, legal values, and defaults. { \"logging\": { \"enabled\": boolean, \"structured\": boolean, \"destination\": \"stdout | stderr | file | syslog\", \"path\": \"/log/file/path\", \"level\": integer }, \"socket\": { \"enabled\": boolean, \"path\": \"/UNIX/socket/file/path\" } } kvdb.conf JSON File See the discussions on KVDB runtime parameters and KVS runtime parameters for definitions, legal values, and defaults. { \"read_only\": boolean, \"durability\": { \"enabled\": boolean, \"interval\": integer, \"mclass\": \"capacity | staging | pmem | auto\" }, \"throttling\": { \"init_policy\": \"light | medium | heavy | auto\" }, \"kvs\": { \"<kvs name>\": { \"transactions\": { \"enabled\": boolean }, \"mclass\": { \"policy\": \"see KVS runtime parameter discussion for value strings\" }, \"compression\": { \"value\": { \"algorithm\": \"lz4 | none\", \"min_length\": integer } } } } } The KVS name default is reserved and its parameters apply to all the KVS in a KVDB. Parameters specified for a named KVS override those specified via default . Precedence of Parameters The final value for a specific configuration parameter is determined of follows: The built-in default value is applied first The value is then overridden by an API (or CLI) setting, if any The value is then overridden by an hse.conf or kvdb.conf setting, if any This ordering allows the effective value of a configuration parameter to be modified without recompiling an HSE application.","title":"Configuration Parameters"},{"location":"gs/params/#configuration-parameters","text":"HSE defines global, KVDB, and KVS configuration parameters as described below. These are classified as either create-time parameters, which apply when an application creates a KVDB or KVS, or runtime parameters, which apply each time an application initializes the HSE library or opens a KVDB or KVS. In addition to the detailed descriptions below, you can find parameter usage examples in the API reference , CLI reference , and HSE sample programs .","title":"Configuration Parameters"},{"location":"gs/params/#global-parameters","text":"Global parameters are runtime parameters that apply at the application level. These parameters may be specified in the hse_init() API call or in the optional hse.conf JSON file, which is also specified in hse_init() . For hse_init() API calls, specify global parameters in the form <param>=<value> . For example, socket.enabled=false . The following global parameters are part of the stable API. Parameter Default Description logging.enabled true Logging mode (false==disabled, true==enabled) logging.structured false Logging style (false==basic, true==structured) logging.destination syslog Log destination (stdout, stderr, file, syslog) logging.path $PWD/hse.log Log file when logging.destination==file logging.level 7 Logging severity level (0==emergency; 7==debug) socket.enabled true REST interface mode (false==disabled, true==enabled) socket.path /tmp/hse-<pid>.sock UNIX domain socket file when socket.enabled==true","title":"Global Parameters"},{"location":"gs/params/#kvdb-parameters","text":"KVDB parameters apply when a KVDB is created or opened.","title":"KVDB Parameters"},{"location":"gs/params/#kvdb-create-time-parameters","text":"KVDB create-time parameters may be specified in the hse_kvdb_create() API call or when using the CLI to create a KVDB. In either case, specify KVDB create-time parameters in the form <param>=<value> . For example, storage.capacity.path=/path/to/capacity/dir . The following KVDB create-time parameters are part of the stable API. Parameter Default Description storage.capacity.path <KVDB home>/capacity Capacity media class directory storage.staging.path null Staging media class directory storage.pmem.path <KVDB home>/pmem Pmem media class directory Info Defaults for storage.capacity.path and storage.pmem.path are applied only when applicable based on the KVDB home directory storage .","title":"KVDB Create-time Parameters"},{"location":"gs/params/#kvdb-runtime-parameters","text":"KVDB runtime parameters may be specified in the hse_kvdb_open() API call or in the optional kvdb.conf JSON file in the KVDB home directory, which is also specified in hse_kvdb_open() . For hse_kvdb_open() API calls, specify KVDB runtime parameters in the form <param>=<value> . For example, durability.interval_ms=1000 . The following KVDB runtime parameters are part of the stable API. Parameter Default Description read_only false Access mode (false==read/write, true==read-only) durability.enabled true Journaling mode (false==disabled, true==enabled) durability.interval_ms 100 Max time data is cached (in milliseconds) when durability.enabled==true durability.mclass auto Media class for journal (capacity, staging, pmem, auto) throttling.init_policy auto Ingest throttle at startup (light, medium, heavy, auto) Info The throttling.init_policy may also be set to default , which is an alias for heavy . This is to maintain backward compatibility with earlier releases of HSE.","title":"KVDB Runtime Parameters"},{"location":"gs/params/#durability-settings","text":"The KVDB durability parameters control how HSE journals updates for that KVDB to provide for recovery in the event of a failure. The parameter durability.enabled determines whether or not journaling is enabled. In general, you should always set this to true . As a rare exception, applications that implement their own form of durability may want to disable HSE journaling to increase performance. The parameter durability.interval_ms specifies the frequency (in milliseconds) for automatically flushing cached updates to the journal on stable storage. Increasing this value may improve performance but also increases the amount of data that may be lost in the event of a failure. The parameter durability.mclass specifies the media class for storing journal files. In general, best performance is achieved by storing the journal files on the fastest media class configured for a KVDB. If durability.mclass is set to auto , HSE selects (applies) the value pmem , or staging , or capacity , in that order, depending on the media classes configured for the KVDB. The media class value that HSE selects when auto is specified may change in future releases. See the discussion on HSE durability controls for additional details.","title":"Durability Settings"},{"location":"gs/params/#initial-throttle-setting","text":"On startup, HSE throttles the rate at which it processes updates in a KVDB, referred to as the ingest rate . HSE increases the ingest rate for the KVDB until it reaches the maximum sustainable value for the underlying storage. This ramp-up process can take up to 200 seconds . For benchmarks, this initial throttling can greatly distort results. In normal use, this initial throttling may impact the time before a service is fully operational. The throttling.init_policy parameter can be used to achieve the maximum ingest rate in far less time. It specifies a relative initial throttling value of light (minimum), medium , or heavy (maximum) throttling. If throttling.init_policy is set to auto , HSE selects (applies) the value heavy if the KVDB is configured with a capacity media class, or light if the KVDB is configured with only a pmem media class. The initial throttling value that HSE selects when auto is specified may change in future releases. Setting the throttling.init_policy parameter improperly for the underlying storage can cause the durability interval ( durability.interval_ms ) to be violated or internal indexing structures to become unbalanced for a period of time. For example, this may occur if throttling.init_policy is set to light with relatively slow KVDB storage. For a KVDB configured with a capacity media class, the CLI provides a command to determine the appropriate throttling.init_policy setting. You can run it as follows. hse storage profile /path/to/capacity/storage/for/the/kvdb The path specified in hse storage profile should be a directory in the file system hosting the capacity media class for the KVDB of interest. Use the output of hse storage profile to specify the throttling.init_policy value for that KVDB. For a KVDB configured with only a pmem media class, specify a throttling.init_policy value of light or auto .","title":"Initial Throttle Setting"},{"location":"gs/params/#kvs-parameters","text":"KVS parameters apply when a KVS is created or opened.","title":"KVS Parameters"},{"location":"gs/params/#kvs-create-time-parameters","text":"KVS create-time parameters may be specified in the hse_kvdb_kvs_create() API call or when using the CLI to create a KVS. In either case, specify KVS create-time parameters in the form <param>=<value> . For example, prefix.length=8 . The following KVS create-time parameters are part of the stable API. Parameter Default Description prefix.length 0 Key prefix length (bytes) Info The KVS name default is reserved and may not be used in hse_kvdb_kvs_create() API calls or with the CLI.","title":"KVS Create-time Parameters"},{"location":"gs/params/#kvs-runtime-parameters","text":"KVS runtime parameters may be specified in the hse_kvdb_kvs_open() API call or in the optional kvdb.conf configuration file in the KVDB home directory, which is also specified in hse_kvdb_open() . For hse_kvdb_kvs_open() API calls, specify KVS runtime parameters in the form <param>=<value> . For example, compression.value.algorithm=lz4 . The following KVS runtime parameters are part of the stable API. Parameter Default Description transactions.enabled false Transaction mode (false==disabled, true==enabled) mclass.policy auto Media class usage (see discussion below for value strings) compression.value.algorithm none Value compression method (none, lz4) compression.value.min_length 12 Value length above which compression is attempted (bytes)","title":"KVS Runtime Parameters"},{"location":"gs/params/#transaction-mode","text":"When a KVS is opened, the transactions.enabled value determines whether or not transactions are enabled for the KVS. This mode may be changed by closing and reopening the KVS. See the discussion on HSE transactions for additional details.","title":"Transaction Mode"},{"location":"gs/params/#media-class-usage","text":"The media class usage policy for a KVS defines how the key-value data in that KVS is stored and managed in a KVDB. Key and value data in a KVS can either be pinned to a particular media class, or tiered from one media class to another as it ages. This behavior is determined by the mclass.policy setting for the KVS. The following mclass.policy settings pin key and value data: capacity_only pins all key and value data to the capacity media class staging_only pins all key and value data to the staging media class pmem_only pins all key and value data to the pmem media class The following mclass.policy settings tier key and value data: staging_max_capacity pins all key data to the staging media class and tiers all value data from staging to capacity staging_min_capacity tiers all key and value data from the staging to the capacity media class pmem_max_capacity pins all key data to the pmem media class and tiers all value data from pmem to capacity Below is a visualization of these mclass.policy settings in terms of the media classes that may contain key and value data for a KVS. mclass.policy pmem staging capacity capacity_only keys, values staging_only keys, values pmem_only keys, values staging_max_capacity keys, values values staging_min_capacity keys, values keys, values pmem_max_capacity keys, values values If mclass.policy is set to auto , HSE selects (applies) the value for the media class usage policy per the table below. The usage policy value that HSE selects when auto is specified may change in future releases. Media classes configured for the KVDB mclass.policy value selected capacity capacity_only staging, capacity staging_max_capacity pmem, staging, capacity pmem_max_capacity pmem, capacity pmem_max_capacity pmem pmem_only","title":"Media Class Usage"},{"location":"gs/params/#configuration-files","text":"The following are the JSON file formats for the optional HSE configuration files.","title":"Configuration Files"},{"location":"gs/params/#hseconf-json-file","text":"See the discussion on global parameters for definitions, legal values, and defaults. { \"logging\": { \"enabled\": boolean, \"structured\": boolean, \"destination\": \"stdout | stderr | file | syslog\", \"path\": \"/log/file/path\", \"level\": integer }, \"socket\": { \"enabled\": boolean, \"path\": \"/UNIX/socket/file/path\" } }","title":"hse.conf JSON File"},{"location":"gs/params/#kvdbconf-json-file","text":"See the discussions on KVDB runtime parameters and KVS runtime parameters for definitions, legal values, and defaults. { \"read_only\": boolean, \"durability\": { \"enabled\": boolean, \"interval\": integer, \"mclass\": \"capacity | staging | pmem | auto\" }, \"throttling\": { \"init_policy\": \"light | medium | heavy | auto\" }, \"kvs\": { \"<kvs name>\": { \"transactions\": { \"enabled\": boolean }, \"mclass\": { \"policy\": \"see KVS runtime parameter discussion for value strings\" }, \"compression\": { \"value\": { \"algorithm\": \"lz4 | none\", \"min_length\": integer } } } } } The KVS name default is reserved and its parameters apply to all the KVS in a KVDB. Parameters specified for a named KVS override those specified via default .","title":"kvdb.conf JSON File"},{"location":"gs/params/#precedence-of-parameters","text":"The final value for a specific configuration parameter is determined of follows: The built-in default value is applied first The value is then overridden by an API (or CLI) setting, if any The value is then overridden by an hse.conf or kvdb.conf setting, if any This ordering allows the effective value of a configuration parameter to be modified without recompiling an HSE application.","title":"Precedence of Parameters"},{"location":"gs/storage/","text":"KVDB Storage The following provides an overview of important KVDB storage concepts. Media Classes The KVDB storage model is based on the concept of media classes, where each media class represents a tier of storage. HSE defines the following media classes for a KVDB: capacity , representing the bottom (bulk) tier of storage staging , representing a higher (faster) tier of storage than capacity pmem , representing byte-addressable persistent memory as the top (fastest) tier of storage Each media class for a KVDB is a directory in a file system. The capacity and staging media classes must reside in a file system created on block storage. The pmem media class must reside in a DAX-enabled file system created on persistent memory. Data for a KVDB is stored as a set of files in each of its configured media class directories. See the section on system requirements for additional details on creating file systems for media classes. Info HSE does not validate the performance of the media classes configured for a KVDB to confirm alignment with this tiered storage model. Also, KVDB data in the capacity or staging media classes may be cached in DRAM (specifically the OS page cache), and so those media classes may outperform pmem for working sets that fit in the DRAM cache. Valid Configurations The following are valid storage configurations for a KVDB: A capacity media class only A capacity media class plus one or both of a staging or pmem media class A pmem media class only A KVDB can be created with any valid storage configuration. Later, a media class can be added to the KVDB provided the result is also a valid storage configuration. Usage Example A KVDB can be configured with multiple media classes to increase overall performance and to reduce wear for the capacity media class in terms of total bytes written (TBW). For example, a KVDB might be configured with: a capacity media class in a file system created on cost-optimized QLC SSDs a staging media class in a file system created on performance-optimized TLC SSDs In this example, the media class usage policy ( mclass.policy ) for KVSs in the KVDB could be set to staging_max_capacity to pin all key data to the staging media class and tier all value data from the staging to the capacity media class. In addition, the durability setting for the KVDB controlling journal placement ( durability.mclass ) would be set to staging to store journal files in the staging media class. This KVDB configuration would increase overall performance, versus using the capacity media class only, while also greatly reducing the TBW to the lower endurance QLC SSDs. Home Directory Every KVDB has a home directory with files storing its metadata. A KVDB home directory may also contain an optional kvdb.conf file with user-defined KVDB and KVS parameter settings. When a KVDB is created with a home directory in a file system on block storage, by default a capacity media class is created within the home directory. Similarly, when a KVDB is created with a home directory in a DAX-enabled file system on persistent memory, by default a pmem media class is created within the home directory. In the common case where a KVDB is configured with only a single media class, these defaults result in all data, metadata, and parameter settings for the KVDB residing within its home directory.","title":"KVDB Storage"},{"location":"gs/storage/#kvdb-storage","text":"The following provides an overview of important KVDB storage concepts.","title":"KVDB Storage"},{"location":"gs/storage/#media-classes","text":"The KVDB storage model is based on the concept of media classes, where each media class represents a tier of storage. HSE defines the following media classes for a KVDB: capacity , representing the bottom (bulk) tier of storage staging , representing a higher (faster) tier of storage than capacity pmem , representing byte-addressable persistent memory as the top (fastest) tier of storage Each media class for a KVDB is a directory in a file system. The capacity and staging media classes must reside in a file system created on block storage. The pmem media class must reside in a DAX-enabled file system created on persistent memory. Data for a KVDB is stored as a set of files in each of its configured media class directories. See the section on system requirements for additional details on creating file systems for media classes. Info HSE does not validate the performance of the media classes configured for a KVDB to confirm alignment with this tiered storage model. Also, KVDB data in the capacity or staging media classes may be cached in DRAM (specifically the OS page cache), and so those media classes may outperform pmem for working sets that fit in the DRAM cache.","title":"Media Classes"},{"location":"gs/storage/#valid-configurations","text":"The following are valid storage configurations for a KVDB: A capacity media class only A capacity media class plus one or both of a staging or pmem media class A pmem media class only A KVDB can be created with any valid storage configuration. Later, a media class can be added to the KVDB provided the result is also a valid storage configuration.","title":"Valid Configurations"},{"location":"gs/storage/#usage-example","text":"A KVDB can be configured with multiple media classes to increase overall performance and to reduce wear for the capacity media class in terms of total bytes written (TBW). For example, a KVDB might be configured with: a capacity media class in a file system created on cost-optimized QLC SSDs a staging media class in a file system created on performance-optimized TLC SSDs In this example, the media class usage policy ( mclass.policy ) for KVSs in the KVDB could be set to staging_max_capacity to pin all key data to the staging media class and tier all value data from the staging to the capacity media class. In addition, the durability setting for the KVDB controlling journal placement ( durability.mclass ) would be set to staging to store journal files in the staging media class. This KVDB configuration would increase overall performance, versus using the capacity media class only, while also greatly reducing the TBW to the lower endurance QLC SSDs.","title":"Usage Example"},{"location":"gs/storage/#home-directory","text":"Every KVDB has a home directory with files storing its metadata. A KVDB home directory may also contain an optional kvdb.conf file with user-defined KVDB and KVS parameter settings. When a KVDB is created with a home directory in a file system on block storage, by default a capacity media class is created within the home directory. Similarly, when a KVDB is created with a home directory in a DAX-enabled file system on persistent memory, by default a pmem media class is created within the home directory. In the common case where a KVDB is configured with only a single media class, these defaults result in all data, metadata, and parameter settings for the KVDB residing within its home directory.","title":"Home Directory"},{"location":"gs/sysreqs/","text":"System Requirements The following are system requirements for running HSE applications. Hardware Hardware requirements are largely dictated by the application embedding HSE and the amount of data stored. The following are general guidelines. Architecture : 64-bit Intel\u00ae and AMD (x86_64); 64-bit IBM Z\u00ae (s390x) Memory : 32 GB or more Block Storage : SSD volumes only ; use NVMe for best performance Persistent Memory (optional): must support a DAX-enabled file system If a KVDB media class is configured on multiple block storage devices, such as when using XFS with LVM, performance can be significantly improved by balancing these devices across NUMA nodes. Tools like lstopo can be helpful in creating and verifying a balanced configuration. Operating System HSE should work with most modern Linux\u00ae 64-bit operating system distributions. We have run HSE on the following. Red Hat\u00ae Enterprise Linux\u00ae 8 (RHEL 8) Ubuntu\u00ae 18.04 and 20.04 Fedora\u00ae 34 and 35 AlmaLinux OS 8 File System HSE requires the following file system features. fallocate(2) with modes zero (0), FALLOC_FL_PUNCH_HOLE , FALLOC_FL_KEEP_SIZE openat(2) with flag O_DIRECT DAX if the file system will host a pmem media class Several common file systems support these features, including XFS and ext4. For most HSE applications we recommend using XFS. Info File systems hosting pmem media classes should be mounted with the option -o dax=always . Virtual Memory HSE performance and quality of service (QoS) can be significantly improved by configuring huge pages and other virtual memory tuning parameters . For most HSE applications we recommend the following settings. sudo sysctl -w vm.nr_hugepages = 256 sudo sysctl -w vm.swappiness = 1 sudo sysctl -w vm.dirty_background_ratio = 5 sudo sysctl -w vm.dirty_ratio = 15","title":"System Requirements"},{"location":"gs/sysreqs/#system-requirements","text":"The following are system requirements for running HSE applications.","title":"System Requirements"},{"location":"gs/sysreqs/#hardware","text":"Hardware requirements are largely dictated by the application embedding HSE and the amount of data stored. The following are general guidelines. Architecture : 64-bit Intel\u00ae and AMD (x86_64); 64-bit IBM Z\u00ae (s390x) Memory : 32 GB or more Block Storage : SSD volumes only ; use NVMe for best performance Persistent Memory (optional): must support a DAX-enabled file system If a KVDB media class is configured on multiple block storage devices, such as when using XFS with LVM, performance can be significantly improved by balancing these devices across NUMA nodes. Tools like lstopo can be helpful in creating and verifying a balanced configuration.","title":"Hardware"},{"location":"gs/sysreqs/#operating-system","text":"HSE should work with most modern Linux\u00ae 64-bit operating system distributions. We have run HSE on the following. Red Hat\u00ae Enterprise Linux\u00ae 8 (RHEL 8) Ubuntu\u00ae 18.04 and 20.04 Fedora\u00ae 34 and 35 AlmaLinux OS 8","title":"Operating System"},{"location":"gs/sysreqs/#file-system","text":"HSE requires the following file system features. fallocate(2) with modes zero (0), FALLOC_FL_PUNCH_HOLE , FALLOC_FL_KEEP_SIZE openat(2) with flag O_DIRECT DAX if the file system will host a pmem media class Several common file systems support these features, including XFS and ext4. For most HSE applications we recommend using XFS. Info File systems hosting pmem media classes should be mounted with the option -o dax=always .","title":"File System"},{"location":"gs/sysreqs/#virtual-memory","text":"HSE performance and quality of service (QoS) can be significantly improved by configuring huge pages and other virtual memory tuning parameters . For most HSE applications we recommend the following settings. sudo sysctl -w vm.nr_hugepages = 256 sudo sysctl -w vm.swappiness = 1 sudo sysctl -w vm.dirty_background_ratio = 5 sudo sysctl -w vm.dirty_ratio = 15","title":"Virtual Memory"},{"location":"res/benchmarking/","text":"Benchmarking Tips The following are tips for benchmarking HSE applications. System Requirements The system running the HSE application should meet the specified requirements . In particular: Configure huge pages and other virtual memory tuning parameters as documented Balance storage devices across NUMA nodes when applicable Configuration Parameters In the HSE application or kvdb.conf file, provide appropriate values for at least the following parameters. KVDB parameters : throttling.init_policy as determined by hse storage profile in the common case where the KVDB is configured with a capacity media class durability.interval_ms as appropriate for the application durability.mclass representing the fastest tier of storage configured for the KVDB KVS parameters : mclass.policy maximizing the use of faster tiers of storage for all KVSs when multiple media classes are configured for a KVDB compression.value.algorithm=lz4 for all KVSs, unless the application performs its own value compression or values are known to not compress","title":"Benchmarking Tips"},{"location":"res/benchmarking/#benchmarking-tips","text":"The following are tips for benchmarking HSE applications.","title":"Benchmarking Tips"},{"location":"res/benchmarking/#system-requirements","text":"The system running the HSE application should meet the specified requirements . In particular: Configure huge pages and other virtual memory tuning parameters as documented Balance storage devices across NUMA nodes when applicable","title":"System Requirements"},{"location":"res/benchmarking/#configuration-parameters","text":"In the HSE application or kvdb.conf file, provide appropriate values for at least the following parameters. KVDB parameters : throttling.init_policy as determined by hse storage profile in the common case where the KVDB is configured with a capacity media class durability.interval_ms as appropriate for the application durability.mclass representing the fastest tier of storage configured for the KVDB KVS parameters : mclass.policy maximizing the use of faster tiers of storage for all KVSs when multiple media classes are configured for a KVDB compression.value.algorithm=lz4 for all KVSs, unless the application performs its own value compression or values are known to not compress","title":"Configuration Parameters"},{"location":"res/community/","text":"Community Resources are available to report a bug, ask a question, provide feedback on how we can improve HSE, or contribute to development. Report a Bug You can file an issue to report an bug. In doing so, please provide all the information requested in the issue template. Ask a Question You can ask a question in the HSE discussions forum using the Q&A category. Participate in Discussions You can discuss all aspects of HSE in the discussions forum using the following categories. Q&A to ask a question Ideas to discuss a new feature or enhancement Show and tell to talk about your experiences with HSE General to discuss all other aspects of the project Contribute to Development We welcome your contributions to the HSE project. As a starting point, see CONTRIBUTING.md in the hse repo for instructions on how to participate.","title":"Community"},{"location":"res/community/#community","text":"Resources are available to report a bug, ask a question, provide feedback on how we can improve HSE, or contribute to development.","title":"Community"},{"location":"res/community/#report-a-bug","text":"You can file an issue to report an bug. In doing so, please provide all the information requested in the issue template.","title":"Report a Bug"},{"location":"res/community/#ask-a-question","text":"You can ask a question in the HSE discussions forum using the Q&A category.","title":"Ask a Question"},{"location":"res/community/#participate-in-discussions","text":"You can discuss all aspects of HSE in the discussions forum using the following categories. Q&A to ask a question Ideas to discuss a new feature or enhancement Show and tell to talk about your experiences with HSE General to discuss all other aspects of the project","title":"Participate in Discussions"},{"location":"res/community/#contribute-to-development","text":"We welcome your contributions to the HSE project. As a starting point, see CONTRIBUTING.md in the hse repo for instructions on how to participate.","title":"Contribute to Development"}]}